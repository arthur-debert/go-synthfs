
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>synthfs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arthur-debert/synthfs/pkg/synthfs/batch.go (60.0%)</option>
				
				<option value="file1">github.com/arthur-debert/synthfs/pkg/synthfs/convenience.go (100.0%)</option>
				
				<option value="file2">github.com/arthur-debert/synthfs/pkg/synthfs/errors.go (0.0%)</option>
				
				<option value="file3">github.com/arthur-debert/synthfs/pkg/synthfs/errors_enhanced.go (97.6%)</option>
				
				<option value="file4">github.com/arthur-debert/synthfs/pkg/synthfs/executor.go (56.4%)</option>
				
				<option value="file5">github.com/arthur-debert/synthfs/pkg/synthfs/idgen.go (100.0%)</option>
				
				<option value="file6">github.com/arthur-debert/synthfs/pkg/synthfs/items.go (40.0%)</option>
				
				<option value="file7">github.com/arthur-debert/synthfs/pkg/synthfs/log.go (100.0%)</option>
				
				<option value="file8">github.com/arthur-debert/synthfs/pkg/synthfs/logger_adapter.go (90.5%)</option>
				
				<option value="file9">github.com/arthur-debert/synthfs/pkg/synthfs/operations_adapter.go (30.6%)</option>
				
				<option value="file10">github.com/arthur-debert/synthfs/pkg/synthfs/path_aware_fs.go (67.4%)</option>
				
				<option value="file11">github.com/arthur-debert/synthfs/pkg/synthfs/path_handler.go (89.8%)</option>
				
				<option value="file12">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_archive.go (88.6%)</option>
				
				<option value="file13">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_copytree.go (53.1%)</option>
				
				<option value="file14">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_mirror.go (67.5%)</option>
				
				<option value="file15">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_structure.go (72.8%)</option>
				
				<option value="file16">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_sync.go (73.4%)</option>
				
				<option value="file17">github.com/arthur-debert/synthfs/pkg/synthfs/patterns_template.go (60.0%)</option>
				
				<option value="file18">github.com/arthur-debert/synthfs/pkg/synthfs/pipeline.go (85.0%)</option>
				
				<option value="file19">github.com/arthur-debert/synthfs/pkg/synthfs/pipeline_builder.go (66.1%)</option>
				
				<option value="file20">github.com/arthur-debert/synthfs/pkg/synthfs/pipeline_extensions.go (0.0%)</option>
				
				<option value="file21">github.com/arthur-debert/synthfs/pkg/synthfs/registry.go (61.5%)</option>
				
				<option value="file22">github.com/arthur-debert/synthfs/pkg/synthfs/simple_api.go (76.9%)</option>
				
				<option value="file23">github.com/arthur-debert/synthfs/pkg/synthfs/simple_batch.go (95.3%)</option>
				
				<option value="file24">github.com/arthur-debert/synthfs/pkg/synthfs/state.go (0.0%)</option>
				
				<option value="file25">github.com/arthur-debert/synthfs/pkg/synthfs/synthfs.go (58.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package synthfs

import (
        "context"
        "io/fs"

        "github.com/arthur-debert/synthfs/pkg/synthfs/batch"
        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// Batch is a wrapper around batch.Batch that provides convenience methods for operation results
type Batch struct {
        impl batch.Batch
}

// NewBatch creates a new batch with the clean implementation that has prerequisite resolution enabled by default
func NewBatch(fs interface{}) *Batch <span class="cov8" title="1">{
        return &amp;Batch{
                impl: batch.NewBatch(fs, NewOperationRegistry()),
        }
}</span>

// Operations returns all operations currently in the batch.
func (b *Batch) Operations() []interface{} <span class="cov8" title="1">{
        return b.impl.Operations()
}</span>

// Operation creation methods

// CreateDir adds a directory creation operation to the batch.
func (b *Batch) CreateDir(path string, mode ...fs.FileMode) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.CreateDir(path, mode...)
}</span>

// CreateFile adds a file creation operation to the batch.
func (b *Batch) CreateFile(path string, content []byte, mode ...fs.FileMode) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.CreateFile(path, content, mode...)
}</span>

// Copy adds a copy operation to the batch.
func (b *Batch) Copy(src, dst string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.Copy(src, dst)
}</span>

// Move adds a move operation to the batch.
func (b *Batch) Move(src, dst string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.Move(src, dst)
}</span>

// Delete adds a delete operation to the batch.
func (b *Batch) Delete(path string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.Delete(path)
}</span>

// CreateSymlink adds a symbolic link creation operation to the batch.
func (b *Batch) CreateSymlink(target, linkPath string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.CreateSymlink(target, linkPath)
}</span>

// CreateArchive adds an archive creation operation to the batch.
func (b *Batch) CreateArchive(archivePath string, format interface{}, sources ...string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.CreateArchive(archivePath, format, sources...)
}</span>

// Unarchive adds an unarchive operation to the batch.
func (b *Batch) Unarchive(archivePath, extractPath string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.Unarchive(archivePath, extractPath)
}</span>

// UnarchiveWithPatterns adds an unarchive operation with pattern filtering to the batch.
func (b *Batch) UnarchiveWithPatterns(archivePath, extractPath string, patterns ...string) (interface{}, error) <span class="cov8" title="1">{
        return b.impl.UnarchiveWithPatterns(archivePath, extractPath, patterns...)
}</span>

// Configuration methods

// WithFileSystem sets the filesystem for the batch operations.
func (b *Batch) WithFileSystem(fs interface{}) *Batch <span class="cov8" title="1">{
        b.impl = b.impl.WithFileSystem(fs)
        return b
}</span>

// WithContext sets the context for the batch operations.
func (b *Batch) WithContext(ctx context.Context) *Batch <span class="cov8" title="1">{
        b.impl = b.impl.WithContext(ctx)
        return b
}</span>

// WithRegistry sets a custom operation registry for the batch.
func (b *Batch) WithRegistry(registry core.OperationFactory) *Batch <span class="cov0" title="0">{
        b.impl = b.impl.WithRegistry(registry)
        return b
}</span>

// WithLogger sets the logger for the batch.
func (b *Batch) WithLogger(logger core.Logger) *Batch <span class="cov0" title="0">{
        b.impl = b.impl.WithLogger(logger)
        return b
}</span>

// Execution methods

// Run runs all operations in the batch using default options with prerequisite resolution.
func (b *Batch) Run() (*Result, error) <span class="cov8" title="1">{
        batchResult, err := b.impl.Run()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ConvertBatchResult(batchResult), nil</span>
}

// RunWithOptions runs all operations in the batch with specified options.
func (b *Batch) RunWithOptions(opts interface{}) (*Result, error) <span class="cov0" title="0">{
        batchResult, err := b.impl.RunWithOptions(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertBatchResult(batchResult), nil</span>
}

// RunRestorable runs all operations with backup enabled using the default 10MB budget.
func (b *Batch) RunRestorable() (*Result, error) <span class="cov0" title="0">{
        batchResult, err := b.impl.RunRestorable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertBatchResult(batchResult), nil</span>
}

// RunRestorableWithBudget runs all operations with backup enabled using a custom budget.
func (b *Batch) RunRestorableWithBudget(maxBackupMB int) (*Result, error) <span class="cov0" title="0">{
        batchResult, err := b.impl.RunRestorableWithBudget(maxBackupMB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertBatchResult(batchResult), nil</span>
}

// Result conversion utilities

// ConvertBatchResult converts a batch result interface{} to our typed Result
func ConvertBatchResult(batchResult interface{}) *Result <span class="cov8" title="1">{
        if r, ok := batchResult.(interface {
                IsSuccess() bool
                GetOperations() []interface{}
                GetRestoreOps() []interface{}
                GetDuration() interface{}
                GetError() error
                GetBudget() interface{}
                GetRollback() interface{}
        }); ok </span><span class="cov8" title="1">{
                return &amp;Result{
                        success:    r.IsSuccess(),
                        operations: r.GetOperations(),
                        restoreOps: r.GetRestoreOps(),
                        duration:   r.GetDuration(),
                        err:        r.GetError(),
                        budget:     r.GetBudget(),
                        rollback:   r.GetRollback(),
                }
        }</span>

        // Fallback for basic result structure
        <span class="cov0" title="0">return &amp;Result{
                success:    true,
                operations: []interface{}{},
                restoreOps: []interface{}{},
                duration:   nil,
                err:        nil,
                budget:     nil,
                rollback:   nil,
        }</span>
}

// Result represents the outcome of executing a batch of operations
type Result struct {
        success    bool
        operations []interface{}
        restoreOps []interface{}
        duration   interface{}
        err        error
        budget     interface{}
        rollback   interface{}
}

// IsSuccess returns whether the batch execution was successful
func (r *Result) IsSuccess() bool <span class="cov8" title="1">{
        return r.success
}</span>

// GetOperations returns the operations that were executed
func (r *Result) GetOperations() []interface{} <span class="cov8" title="1">{
        return r.operations
}</span>

// GetRestoreOps returns operations needed to restore the state
func (r *Result) GetRestoreOps() []interface{} <span class="cov8" title="1">{
        return r.restoreOps
}</span>

// GetDuration returns the execution duration
func (r *Result) GetDuration() interface{} <span class="cov8" title="1">{
        return r.duration
}</span>

// GetError returns any error that occurred during execution
func (r *Result) GetError() error <span class="cov8" title="1">{
        return r.err
}</span>

// GetBudget returns budget information if available
func (r *Result) GetBudget() interface{} <span class="cov8" title="1">{
        return r.budget
}</span>

// GetRollback returns rollback information if available
func (r *Result) GetRollback() interface{} <span class="cov8" title="1">{
        return r.rollback
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package synthfs

import (
        "context"
        "io/fs"

        "github.com/arthur-debert/synthfs/pkg/synthfs/filesystem"
)

// Direct execution methods for simple use cases

// WriteFile writes a file directly to the filesystem.
//
// This is a convenience function for simple file writing operations.
// For batch operations or complex workflows, consider using SimpleBatch or Pipeline.
//
// Example:
//
//        fs := synthfs.NewOSFileSystem("/tmp")
//        err := synthfs.WriteFile(ctx, fs, "config.json", []byte(`{"debug": true}`), 0644)
//        if err != nil {
//                log.Fatal(err)
//        }
//
// For multiple related operations, use SimpleBatch:
//
//        batch := synthfs.NewSimpleBatch(fs)
//        err := batch.
//                CreateDir("project", 0755).
//                WriteFile("project/config.json", []byte(`{}`), 0644).
//                WriteFile("project/README.md", []byte("# Project"), 0644).
//                Execute(ctx)
func WriteFile(ctx context.Context, fs filesystem.FileSystem, path string, content []byte, mode fs.FileMode) error <span class="cov8" title="1">{
        op := New().CreateFile(path, content, mode)
        return executeDirectOp(ctx, fs, op)
}</span>

// MkdirAll creates a directory and all necessary parents.
//
// This function automatically creates parent directories as needed, similar to `mkdir -p`.
// It's ideal for single directory creation; for complex directory structures, consider
// using patterns like CreateStructure or SimpleBatch.
//
// Example:
//
//        fs := synthfs.NewOSFileSystem("/")
//        err := synthfs.MkdirAll(ctx, fs, "/tmp/project/data/logs", 0755)
//        if err != nil {
//                log.Fatal(err)
//        }
//
// For creating multiple directories with files, use SimpleBatch:
//
//        batch := synthfs.NewSimpleBatch(fs)
//        err := batch.
//                CreateDir("app/config", 0755).
//                CreateDir("app/data", 0755).
//                CreateDir("app/logs", 0755).
//                WriteFile("app/config/app.conf", configData, 0644).
//                Execute(ctx)
func MkdirAll(ctx context.Context, fs filesystem.FileSystem, path string, mode fs.FileMode) error <span class="cov8" title="1">{
        op := New().CreateDir(path, mode)
        return executeDirectOp(ctx, fs, op)
}</span>

// Remove removes a file or empty directory.
//
// This function removes a single file or empty directory. For recursive directory
// removal or batch deletions, consider using the Delete operation in a Pipeline
// or use patterns like CopyTree with filters.
//
// Example:
//
//        fs := synthfs.NewOSFileSystem("/tmp")
//        err := synthfs.Remove(ctx, fs, "temp-file.txt")
//        if err != nil {
//                log.Fatal(err)
//        }
//
// For removing multiple files or directories, use SimpleBatch:
//
//        batch := synthfs.NewSimpleBatch(fs)
//        err := batch.
//                Delete("temp1.txt").
//                Delete("temp2.txt").
//                Delete("empty-dir").
//                Execute(ctx)
//
// For recursive directory removal, use the low-level API:
//
//        sfs := synthfs.New()
//        pipeline := synthfs.BuildPipeline(sfs.Delete("directory-tree"))
//        result, err := pipeline.Execute(ctx, fs)
func Remove(ctx context.Context, fs filesystem.FileSystem, path string) error <span class="cov8" title="1">{
        op := New().Delete(path)
        return executeDirectOp(ctx, fs, op)
}</span>

// executeDirectOp executes a single operation directly
func executeDirectOp(ctx context.Context, fs filesystem.FileSystem, op Operation) error <span class="cov8" title="1">{
        // Get operation description for error context
        desc := op.Describe()
        action := getOperationAction(desc.Type)

        // Validate first
        if err := op.Validate(ctx, fs); err != nil </span><span class="cov8" title="1">{
                return WrapOperationError(op, action, err)
        }</span>

        // Execute
        <span class="cov8" title="1">if err := op.Execute(ctx, fs); err != nil </span><span class="cov8" title="1">{
                return WrapOperationError(op, action, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package synthfs

import (
        "fmt"
)

// --- Error Types ---

// DependencyError represents an error with operation dependencies.
type DependencyError struct {
        Operation    Operation
        Dependencies []OperationID
        Missing      []OperationID
}

func (e *DependencyError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("dependency error for operation %s: missing dependencies %v (required: %v)",
                e.Operation.ID(), e.Missing, e.Dependencies)
}</span>

// ConflictError represents an error when operations conflict with each other.
type ConflictError struct {
        Operation Operation
        Conflicts []OperationID
}

func (e *ConflictError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("conflict error for operation %s: conflicts with operations %v",
                e.Operation.ID(), e.Conflicts)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package synthfs

import (
        "fmt"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// OperationError provides rich context about operation failures
type OperationError struct {
        Op      string                 // Operation type (e.g., "create-dir", "write-file")
        ID      core.OperationID       // Operation ID
        Path    string                 // Primary path being operated on
        Action  string                 // Human-readable action (e.g., "create directory", "write file")
        Err     error                  // Underlying error
        Context map[string]interface{} // Additional context
}

// Error returns a formatted error message
func (e *OperationError) Error() string <span class="cov8" title="1">{
        // Format: "failed to &lt;action&gt; '&lt;path&gt;': &lt;reason&gt; (operation: &lt;type&gt;-&lt;id&gt;)"
        msg := fmt.Sprintf("failed to %s '%s': %v (operation: %s)",
                e.Action, e.Path, e.Err, e.ID)

        // Add context if available
        if len(e.Context) &gt; 0 </span><span class="cov8" title="1">{
                var contextParts []string
                for k, v := range e.Context </span><span class="cov8" title="1">{
                        contextParts = append(contextParts, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov8" title="1">msg += fmt.Sprintf(" [%s]", strings.Join(contextParts, ", "))</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// Unwrap returns the underlying error
func (e *OperationError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// WithContext adds additional context to the error
func (e *OperationError) WithContext(key string, value interface{}) *OperationError <span class="cov8" title="1">{
        if e.Context == nil </span><span class="cov8" title="1">{
                e.Context = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">e.Context[key] = value
        return e</span>
}

// PipelineError represents a failure during pipeline execution
type PipelineError struct {
        FailedOp      Operation          // The operation that failed
        FailedIndex   int                // Index of failed operation (1-based)
        TotalOps      int                // Total operations in pipeline
        Err           error              // The actual error
        SuccessfulOps []core.OperationID // IDs of operations that succeeded before failure
}

// Error returns a formatted pipeline error message
func (e *PipelineError) Error() string <span class="cov8" title="1">{
        msg := fmt.Sprintf("Pipeline execution failed at operation %d of %d:\n  %v",
                e.FailedIndex, e.TotalOps, e.Err)

        if len(e.SuccessfulOps) &gt; 0 </span><span class="cov8" title="1">{
                msg += "\n\nPrevious successful operations:"
                for i, id := range e.SuccessfulOps </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("\n  %d. %s", i+1, id)
                }</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// Unwrap returns the underlying error
func (e *PipelineError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// RollbackError represents failures during rollback
type RollbackError struct {
        OriginalErr  error                      // The original operation error
        RollbackErrs map[core.OperationID]error // Rollback errors by operation ID
}

// Error returns a formatted rollback error message
func (e *RollbackError) Error() string <span class="cov8" title="1">{
        msg := fmt.Sprintf("Operation failed: %v", e.OriginalErr)

        if len(e.RollbackErrs) &gt; 0 </span><span class="cov8" title="1">{
                msg += "\n\nRollback also failed:"
                for id, err := range e.RollbackErrs </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("\n  - %s: %v", id, err)
                }</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// Unwrap returns the original error
func (e *RollbackError) Unwrap() error <span class="cov8" title="1">{
        return e.OriginalErr
}</span>

// WrapOperationError wraps an error with operation context
func WrapOperationError(op Operation, action string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If it's already an OperationError, add more context
        <span class="cov8" title="1">if opErr, ok := err.(*OperationError); ok </span><span class="cov8" title="1">{
                return opErr
        }</span>

        <span class="cov8" title="1">desc := op.Describe()
        return &amp;OperationError{
                Op:     desc.Type,
                ID:     op.ID(),
                Path:   desc.Path,
                Action: action,
                Err:    err,
        }</span>
}

// getOperationAction returns a human-readable action for an operation type
func getOperationAction(opType string) string <span class="cov8" title="1">{
        switch opType </span>{
        case "create_file":<span class="cov8" title="1">
                return "create file"</span>
        case "create_directory":<span class="cov8" title="1">
                return "create directory"</span>
        case "create_symlink":<span class="cov8" title="1">
                return "create symlink"</span>
        case "delete":<span class="cov8" title="1">
                return "delete"</span>
        case "copy":<span class="cov8" title="1">
                return "copy"</span>
        case "move":<span class="cov8" title="1">
                return "move"</span>
        case "write_file":<span class="cov8" title="1">
                return "write file"</span>
        case "mkdir":<span class="cov8" title="1">
                return "create directory"</span>
        default:<span class="cov8" title="1">
                return opType</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package synthfs

import (
        "context"
        "time"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
        "github.com/arthur-debert/synthfs/pkg/synthfs/execution"
)

// PipelineOptions controls how operations are executed
type PipelineOptions = core.PipelineOptions

// OperationResult holds the outcome of a single operation's execution
type OperationResult struct {
        OperationID  OperationID
        Operation    Operation // The operation that was executed
        Status       OperationStatus
        Error        error
        Duration     time.Duration
        BackupData   *BackupData
        BackupSizeMB float64
}

// DefaultPipelineOptions returns sensible defaults for pipeline execution
func DefaultPipelineOptions() PipelineOptions <span class="cov8" title="1">{
        return execution.DefaultPipelineOptions()
}</span>

// Executor processes a pipeline of operations.
type Executor struct {
        executor *execution.Executor
}

// NewExecutor creates a new Executor.
func NewExecutor() *Executor <span class="cov8" title="1">{
        logger := DefaultLogger()
        return &amp;Executor{
                executor: execution.NewExecutor(NewLoggerAdapter(&amp;logger)),
        }
}</span>

// EventBus returns the executor's event bus for subscription
func (e *Executor) EventBus() core.EventBus <span class="cov8" title="1">{
        return e.executor.EventBus()
}</span>

// Run runs all operations in the pipeline with default options.
func (e *Executor) Run(ctx context.Context, pipeline Pipeline, fs FileSystem) *Result <span class="cov8" title="1">{
        return e.RunWithOptions(ctx, pipeline, fs, DefaultPipelineOptions())
}</span>

// RunWithOptions runs all operations in the pipeline with specified options.
func (e *Executor) RunWithOptions(ctx context.Context, pipeline Pipeline, fs FileSystem, opts PipelineOptions) *Result <span class="cov8" title="1">{
        // Create pipeline wrapper
        wrapper := &amp;pipelineWrapper{pipeline: pipeline}
        coreResult := e.executor.RunWithOptions(ctx, wrapper, fs, opts)

        // Convert core.Result back to main package Result
        return e.convertResult(coreResult)
}</span>

// convertResult converts core.Result to main package Result
func (e *Executor) convertResult(coreResult *core.Result) *Result <span class="cov8" title="1">{
        // Create operations list
        operations := make([]interface{}, 0, len(coreResult.Operations))
        for _, coreOpResult := range coreResult.Operations </span><span class="cov8" title="1">{
                opResult := OperationResult{
                        OperationID:  coreOpResult.OperationID,
                        Status:       coreOpResult.Status,
                        Error:        coreOpResult.Error,
                        Duration:     coreOpResult.Duration,
                        BackupData:   coreOpResult.BackupData,
                        BackupSizeMB: coreOpResult.BackupSizeMB,
                }

                // Convert operation from interface{} back to Operation
                if op, ok := coreOpResult.Operation.(Operation); ok </span><span class="cov0" title="0">{
                        opResult.Operation = op
                }</span> else<span class="cov8" title="1"> if wrapper, ok := coreOpResult.Operation.(*operationWrapper); ok </span><span class="cov8" title="1">{
                        opResult.Operation = wrapper.op
                }</span>

                <span class="cov8" title="1">operations = append(operations, opResult)</span>
        }

        // Convert restore operations
        <span class="cov8" title="1">restoreOps := make([]interface{}, 0, len(coreResult.RestoreOps))
        restoreOps = append(restoreOps, coreResult.RestoreOps...)

        // Get first error if any
        var firstErr error
        if len(coreResult.Errors) &gt; 0 </span><span class="cov8" title="1">{
                firstErr = coreResult.Errors[0]
        }</span>

        // Create the result using the simplified structure
        <span class="cov8" title="1">return &amp;Result{
                success:    coreResult.Success,
                operations: operations,
                restoreOps: restoreOps,
                duration:   coreResult.Duration,
                err:        firstErr,
                budget:     coreResult.Budget,
                rollback:   coreResult.Rollback,
        }</span>
}

// pipelineWrapper wraps Pipeline to implement execution.PipelineInterface
type pipelineWrapper struct {
        pipeline Pipeline
}

func (pw *pipelineWrapper) Add(ops ...interface{}) error <span class="cov0" title="0">{
        // Convert operations and add to pipeline
        for _, op := range ops </span><span class="cov0" title="0">{
                if opTyped, ok := op.(Operation); ok </span><span class="cov0" title="0">{
                        if err := pw.pipeline.Add(opTyped); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (pw *pipelineWrapper) Operations() []interface{} <span class="cov8" title="1">{
        ops := pw.pipeline.Operations()
        var result []interface{}
        for _, op := range ops </span><span class="cov8" title="1">{
                result = append(result, &amp;operationWrapper{op: op})
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (pw *pipelineWrapper) Resolve() error <span class="cov8" title="1">{
        return pw.pipeline.Resolve()
}</span>

func (pw *pipelineWrapper) Validate(ctx context.Context, fs interface{}) error <span class="cov8" title="1">{
        fsys, ok := fs.(FileSystem)
        if !ok </span><span class="cov0" title="0">{
                return nil // Skip validation if filesystem interface doesn't match
        }</span>
        <span class="cov8" title="1">return pw.pipeline.Validate(ctx, fsys)</span>
}

func (pw *pipelineWrapper) ResolvePrerequisites(resolver core.PrerequisiteResolver, fs interface{}) error <span class="cov0" title="0">{
        // The main package pipeline doesn't support prerequisite resolution yet
        // This is a no-op for now
        return nil
}</span>

// operationWrapper wraps Operation to implement execution.OperationInterface
type operationWrapper struct {
        op Operation
}

func (ow *operationWrapper) ID() core.OperationID <span class="cov8" title="1">{
        return ow.op.ID()
}</span>

func (ow *operationWrapper) Describe() core.OperationDesc <span class="cov8" title="1">{
        return ow.op.Describe()
}</span>

func (ow *operationWrapper) Dependencies() []core.OperationID <span class="cov8" title="1">{
        return ow.op.Dependencies()
}</span>

func (ow *operationWrapper) Conflicts() []core.OperationID <span class="cov8" title="1">{
        return ow.op.Conflicts()
}</span>

func (ow *operationWrapper) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        // Check if operation implements Prerequisites method
        if prereqOp, ok := ow.op.(interface{ Prerequisites() []core.Prerequisite }); ok </span><span class="cov0" title="0">{
                return prereqOp.Prerequisites()
        }</span>
        <span class="cov0" title="0">return []core.Prerequisite{}</span>
}

func (ow *operationWrapper) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov8" title="1">{
        // Delegate to the original operation's ExecuteV2 if available, otherwise Execute
        if execV2Op, ok := ow.op.(interface {
                ExecuteV2(interface{}, *core.ExecutionContext, interface{}) error
        }); ok </span><span class="cov8" title="1">{
                return execV2Op.ExecuteV2(ctx, execCtx, fsys)
        }</span>

        // Fallback to original Execute method
        <span class="cov0" title="0">if contextOp, ok := ctx.(context.Context); ok </span><span class="cov0" title="0">{
                if fsysOp, ok := fsys.(FileSystem); ok </span><span class="cov0" title="0">{
                        return ow.op.Execute(contextOp, fsysOp)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ow *operationWrapper) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov8" title="1">{
        // Delegate to the original operation's ValidateV2 if available, otherwise Validate
        if validateV2Op, ok := ow.op.(interface {
                ValidateV2(interface{}, *core.ExecutionContext, interface{}) error
        }); ok </span><span class="cov8" title="1">{
                return validateV2Op.ValidateV2(ctx, execCtx, fsys)
        }</span>

        // Fallback to original Validate method
        <span class="cov0" title="0">if contextOp, ok := ctx.(context.Context); ok </span><span class="cov0" title="0">{
                if fsysOp, ok := fsys.(FileSystem); ok </span><span class="cov0" title="0">{
                        return ow.op.Validate(contextOp, fsysOp)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ow *operationWrapper) ReverseOps(ctx context.Context, fsys interface{}, budget *core.BackupBudget) ([]interface{}, *core.BackupData, error) <span class="cov8" title="1">{
        // Delegate to the original operation's ReverseOps
        if fsysOp, ok := fsys.(FileSystem); ok </span><span class="cov8" title="1">{
                reverseOps, backupData, err := ow.op.ReverseOps(ctx, fsysOp, budget)

                // Convert []Operation to []interface{} even if there's an error
                // This preserves partial backup data in case of budget exhaustion
                var result []interface{}
                for _, op := range reverseOps </span><span class="cov8" title="1">{
                        result = append(result, op)
                }</span>
                <span class="cov8" title="1">return result, backupData, err</span>
        }
        <span class="cov0" title="0">return nil, nil, nil</span>
}

func (ow *operationWrapper) Rollback(ctx context.Context, fsys interface{}) error <span class="cov0" title="0">{
        // Delegate to the original operation's Rollback
        if fsysOp, ok := fsys.(FileSystem); ok </span><span class="cov0" title="0">{
                return ow.op.Rollback(ctx, fsysOp)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ow *operationWrapper) GetItem() interface{} <span class="cov0" title="0">{
        return ow.op.GetItem()
}</span>

func (ow *operationWrapper) GetSrcPath() string <span class="cov0" title="0">{
        if adapter, ok := ow.op.(*OperationsPackageAdapter); ok </span><span class="cov0" title="0">{
                src, _ := adapter.opsOperation.GetPaths()
                return src
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (ow *operationWrapper) GetDstPath() string <span class="cov0" title="0">{
        if adapter, ok := ow.op.(*OperationsPackageAdapter); ok </span><span class="cov0" title="0">{
                _, dst := adapter.opsOperation.GetPaths()
                return dst
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (ow *operationWrapper) AddDependency(depID core.OperationID) <span class="cov0" title="0">{
        // Delegate to the original operation's AddDependency method
        ow.op.AddDependency(depID)
}</span>

func (ow *operationWrapper) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        // Delegate to the original operation's SetDescriptionDetail method
        ow.op.SetDescriptionDetail(key, value)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package synthfs

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "sync/atomic"
        "time"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// IDGenerator defines the interface for generating operation IDs
type IDGenerator func(opType, path string) core.OperationID

var (
        // sequenceCounter for SequenceIDGenerator
        sequenceCounter atomic.Uint64
)

// HashIDGenerator generates IDs based on operation type and path hash
func HashIDGenerator(opType, path string) core.OperationID <span class="cov8" title="1">{
        h := sha256.New()
        h.Write([]byte(opType))
        h.Write([]byte(path))
        _, _ = fmt.Fprintf(h, "%d", time.Now().UnixNano())
        hash := hex.EncodeToString(h.Sum(nil))[:8]
        return core.OperationID(fmt.Sprintf("%s-%s", opType, hash))
}</span>

// SequenceIDGenerator generates sequential IDs (useful for testing)
func SequenceIDGenerator(opType, path string) core.OperationID <span class="cov8" title="1">{
        seq := sequenceCounter.Add(1)
        return core.OperationID(fmt.Sprintf("%s-%d", opType, seq))
}</span>

// TimestampIDGenerator generates IDs based on timestamp
func TimestampIDGenerator(opType, path string) core.OperationID <span class="cov8" title="1">{
        ts := time.Now().UnixNano()
        return core.OperationID(fmt.Sprintf("%s-%d", opType, ts))
}</span>

// ResetSequenceCounter resets the sequence counter (for testing)
func ResetSequenceCounter() <span class="cov8" title="1">{
        sequenceCounter.Store(0)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package synthfs provides a high-level API for filesystem operations.
package synthfs

import (
        "github.com/arthur-debert/synthfs/pkg/synthfs/targets"
)

// This file provides backward compatibility for the public API.
// It forwards type and function definitions to the new `targets` package.

// --- Item Types ---

// FileItem forwards to targets.FileItem.
type FileItem = targets.FileItem

// DirectoryItem forwards to targets.DirectoryItem.
type DirectoryItem = targets.DirectoryItem

// SymlinkItem forwards to targets.SymlinkItem.
type SymlinkItem = targets.SymlinkItem

// ArchiveItem forwards to targets.ArchiveItem.
type ArchiveItem = targets.ArchiveItem

// UnarchiveItem forwards to targets.UnarchiveItem.
type UnarchiveItem = targets.UnarchiveItem

// --- Functions ---

// NewFile forwards to targets.NewFile.
func NewFile(path string) *targets.FileItem <span class="cov8" title="1">{
        return targets.NewFile(path)
}</span>

// NewDirectory forwards to targets.NewDirectory.
func NewDirectory(path string) *targets.DirectoryItem <span class="cov0" title="0">{
        return targets.NewDirectory(path)
}</span>

// NewSymlink forwards to targets.NewSymlink.
func NewSymlink(path, target string) *targets.SymlinkItem <span class="cov0" title="0">{
        return targets.NewSymlink(path, target)
}</span>

// NewArchive forwards to targets.NewArchive.
func NewArchive(path string, format ArchiveFormat, sources []string) *targets.ArchiveItem <span class="cov0" title="0">{
        return targets.NewArchive(path, targets.ArchiveFormat(format), sources)
}</span>

// NewUnarchive forwards to targets.NewUnarchive.
func NewUnarchive(archivePath, extractPath string) *targets.UnarchiveItem <span class="cov8" title="1">{
        return targets.NewUnarchive(archivePath, extractPath)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package synthfs

import (
        "io"
        "os"
        "strings"
        "time"

        "github.com/rs/zerolog"
)

// NewLogger creates a new logger instance with a specified level and output.
func NewLogger(w io.Writer, level zerolog.Level) zerolog.Logger <span class="cov8" title="1">{
        output := zerolog.ConsoleWriter{
                Out:        w,
                TimeFormat: time.RFC3339,
                NoColor:    true,
        }
        return zerolog.New(output).
                Level(level).
                With().
                Timestamp().
                Str("lib", "synthfs").
                Logger()
}</span>

// NewTestLogger creates a logger instance for tests with a specified verbosity.
func NewTestLogger(w io.Writer, verbose int) zerolog.Logger <span class="cov8" title="1">{
        var level zerolog.Level
        switch verbose </span>{
        case 0:<span class="cov8" title="1">
                level = zerolog.WarnLevel</span>
        case 1:<span class="cov8" title="1">
                level = zerolog.InfoLevel</span>
        case 2:<span class="cov8" title="1">
                level = zerolog.DebugLevel</span>
        default:<span class="cov8" title="1">
                level = zerolog.TraceLevel</span>
        }
        <span class="cov8" title="1">return NewLogger(w, level)</span>
}

// LogLevelFromString parses a string to a zerolog.Level.
func LogLevelFromString(levelStr string) (zerolog.Level, error) <span class="cov8" title="1">{
        return zerolog.ParseLevel(strings.ToLower(levelStr))
}</span>

// DefaultLogger returns a logger with default settings (warn level, stderr output).
func DefaultLogger() zerolog.Logger <span class="cov8" title="1">{
        return NewLogger(os.Stderr, zerolog.WarnLevel)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package synthfs

import (
        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
        "github.com/rs/zerolog"
)

// loggerAdapter adapts zerolog.Logger to core.Logger interface
type loggerAdapter struct {
        logger *zerolog.Logger
}

// NewLoggerAdapter creates a new logger adapter
func NewLoggerAdapter(logger *zerolog.Logger) core.Logger <span class="cov8" title="1">{
        return &amp;loggerAdapter{logger: logger}
}</span>

// logEventAdapter adapts zerolog.Event to core.LogEvent interface
type logEventAdapter struct {
        event *zerolog.Event
}

func (l *loggerAdapter) Info() core.LogEvent <span class="cov8" title="1">{
        return &amp;logEventAdapter{event: l.logger.Info()}
}</span>

func (l *loggerAdapter) Debug() core.LogEvent <span class="cov8" title="1">{
        return &amp;logEventAdapter{event: l.logger.Debug()}
}</span>

func (l *loggerAdapter) Warn() core.LogEvent <span class="cov0" title="0">{
        return &amp;logEventAdapter{event: l.logger.Warn()}
}</span>

func (l *loggerAdapter) Error() core.LogEvent <span class="cov0" title="0">{
        return &amp;logEventAdapter{event: l.logger.Error()}
}</span>

func (l *loggerAdapter) Trace() core.LogEvent <span class="cov8" title="1">{
        return &amp;logEventAdapter{event: l.logger.Trace()}
}</span>

// Implement LogEvent methods
func (e *logEventAdapter) Str(key, val string) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Str(key, val)
        return e
}</span>

func (e *logEventAdapter) Int(key string, val int) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Int(key, val)
        return e
}</span>

func (e *logEventAdapter) Err(err error) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Err(err)
        return e
}</span>

func (e *logEventAdapter) Float64(key string, val float64) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Float64(key, val)
        return e
}</span>

func (e *logEventAdapter) Bool(key string, val bool) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Bool(key, val)
        return e
}</span>

func (e *logEventAdapter) Dur(key string, val interface{}) core.LogEvent <span class="cov8" title="1">{
        // Convert to time.Duration if possible
        e.event = e.event.Interface(key, val)
        return e
}</span>

func (e *logEventAdapter) Interface(key string, val interface{}) core.LogEvent <span class="cov8" title="1">{
        e.event = e.event.Interface(key, val)
        return e
}</span>

func (e *logEventAdapter) Msg(msg string) <span class="cov8" title="1">{
        e.event.Msg(msg)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package synthfs

import (
        "context"
        "time"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
        "github.com/arthur-debert/synthfs/pkg/synthfs/operations"
)

// OperationsPackageAdapter adapts an operations.Operation to implement the main package Operation interface.
// This allows gradual migration from SimpleOperation to the operations package.
type OperationsPackageAdapter struct {
        opsOperation operations.Operation
}

// NewOperationsPackageAdapter creates a new adapter for an operations package operation.
func NewOperationsPackageAdapter(opsOp operations.Operation) Operation <span class="cov8" title="1">{
        return &amp;OperationsPackageAdapter{
                opsOperation: opsOp,
        }
}</span>

// ID returns the operation's ID.
func (a *OperationsPackageAdapter) ID() core.OperationID <span class="cov8" title="1">{
        return a.opsOperation.ID()
}</span>

// Describe returns the operation's description.
func (a *OperationsPackageAdapter) Describe() core.OperationDesc <span class="cov8" title="1">{
        return a.opsOperation.Describe()
}</span>

// Dependencies returns the operation's dependencies.
func (a *OperationsPackageAdapter) Dependencies() []core.OperationID <span class="cov8" title="1">{
        return a.opsOperation.Dependencies()
}</span>

// Conflicts returns the operation's conflicts.
func (a *OperationsPackageAdapter) Conflicts() []core.OperationID <span class="cov8" title="1">{
        return a.opsOperation.Conflicts()
}</span>

// Prerequisites returns the operation's prerequisites.
func (a *OperationsPackageAdapter) Prerequisites() []core.Prerequisite <span class="cov8" title="1">{
        return a.opsOperation.Prerequisites()
}</span>

// Execute performs the operation.
func (a *OperationsPackageAdapter) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        return a.opsOperation.Execute(ctx, fsys)
}</span>

// Validate checks if the operation can be performed.
func (a *OperationsPackageAdapter) Validate(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        return a.opsOperation.Validate(ctx, fsys)
}</span>

// ExecuteV2 performs the operation using ExecutionContext.
func (a *OperationsPackageAdapter) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov8" title="1">{
        return a.opsOperation.ExecuteV2(ctx, execCtx, fsys)
}</span>

// ValidateV2 checks if the operation can be performed using ExecutionContext.
func (a *OperationsPackageAdapter) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov8" title="1">{
        return a.opsOperation.ValidateV2(ctx, execCtx, fsys)
}</span>

// Rollback undoes the operation.
func (a *OperationsPackageAdapter) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        return a.opsOperation.Rollback(ctx, fsys)
}</span>

// GetItem returns the item associated with this operation.
func (a *OperationsPackageAdapter) GetItem() FsItem <span class="cov0" title="0">{
        item := a.opsOperation.GetItem()
        if item == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try to convert interface{} to FsItem
        <span class="cov0" title="0">if fsItem, ok := item.(FsItem); ok </span><span class="cov0" title="0">{
                return fsItem
        }</span>

        // If it's from the operations package, we might need to adapt it
        // For now, return nil if we can't convert
        <span class="cov0" title="0">return nil</span>
}

// GetChecksum returns a checksum for the given path.
func (a *OperationsPackageAdapter) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        cs := a.opsOperation.GetChecksum(path)
        if cs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try to convert interface{} to ChecksumRecord
        <span class="cov0" title="0">if checksum, ok := cs.(*ChecksumRecord); ok </span><span class="cov0" title="0">{
                return checksum
        }</span>

        // If it's a different type, try to adapt it
        // For now, return nil if we can't convert
        <span class="cov0" title="0">return nil</span>
}

// GetAllChecksums returns all checksums.
func (a *OperationsPackageAdapter) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        checksums := a.opsOperation.GetAllChecksums()
        if checksums == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string]*ChecksumRecord)
        for path, cs := range checksums </span><span class="cov0" title="0">{
                if checksum, ok := cs.(*ChecksumRecord); ok </span><span class="cov0" title="0">{
                        result[path] = checksum
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ReverseOps generates operations to reverse this operation.
func (a *OperationsPackageAdapter) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        ops, data, err := a.opsOperation.ReverseOps(ctx, fsys, budget)

        // Convert operations
        var result []Operation
        for _, op := range ops </span><span class="cov0" title="0">{
                if opsOp, ok := op.(operations.Operation); ok </span><span class="cov0" title="0">{
                        result = append(result, NewOperationsPackageAdapter(opsOp))
                }</span> else<span class="cov0" title="0"> if mainOp, ok := op.(Operation); ok </span><span class="cov0" title="0">{
                        result = append(result, mainOp)
                }</span>
        }

        // Convert backup data
        <span class="cov0" title="0">var backupData *core.BackupData
        if data != nil </span><span class="cov0" title="0">{
                if bd, ok := data.(*core.BackupData); ok </span><span class="cov0" title="0">{
                        backupData = bd
                }</span>
        } else<span class="cov0" title="0"> if err == nil &amp;&amp; len(result) &gt; 0 </span><span class="cov0" title="0">{
                // If no backup data but operation succeeded, create a "none" type backup data
                // This maintains compatibility with synthfs package expectations
                backupData = &amp;core.BackupData{
                        OperationID: a.opsOperation.ID(),
                        BackupType:  "none",
                        BackupTime:  time.Now(),
                        SizeMB:      0,
                }
        }</span>

        // Return the backup data even if there was an error
        <span class="cov0" title="0">return result, backupData, err</span>
}

// SetDescriptionDetail sets a detail in the operation's description.
func (a *OperationsPackageAdapter) SetDescriptionDetail(key string, value interface{}) <span class="cov8" title="1">{
        a.opsOperation.SetDescriptionDetail(key, value)
}</span>

// AddDependency adds a dependency to the operation.
func (a *OperationsPackageAdapter) AddDependency(depID core.OperationID) <span class="cov8" title="1">{
        a.opsOperation.AddDependency(depID)
}</span>

// SetPaths sets the source and destination paths.
func (a *OperationsPackageAdapter) SetPaths(src, dst string) <span class="cov8" title="1">{
        a.opsOperation.SetPaths(src, dst)
}</span>

// SetChecksum sets a checksum for the given path.
func (a *OperationsPackageAdapter) SetChecksum(path string, checksum *ChecksumRecord) <span class="cov8" title="1">{
        // The operations package uses interface{}, so we can pass ChecksumRecord directly
        a.opsOperation.SetChecksum(path, checksum)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package synthfs

import (
        "io/fs"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/filesystem"
)

// NewOSFileSystemWithPaths creates an OS filesystem with path handling
func NewOSFileSystemWithPaths(root string) *PathAwareFileSystem <span class="cov8" title="1">{
        osfs := filesystem.NewOSFileSystem(root)
        return NewPathAwareFileSystem(osfs, root)
}</span>

// NewTestFileSystemWithPaths creates a test filesystem with path handling
func NewTestFileSystemWithPaths(root string) *PathAwareFileSystem <span class="cov8" title="1">{
        testfs := filesystem.NewTestFileSystem()
        return NewPathAwareFileSystem(testfs, root)
}</span>

// PathAwareFileSystem wraps a FileSystem with intelligent path handling
type PathAwareFileSystem struct {
        fs      FileSystem
        handler *PathHandler
}

// NewPathAwareFileSystem creates a filesystem with path handling
func NewPathAwareFileSystem(fs FileSystem, base string) *PathAwareFileSystem <span class="cov8" title="1">{
        return &amp;PathAwareFileSystem{
                fs:      fs,
                handler: NewPathHandler(base, PathModeAuto),
        }
}</span>

// WithPathMode sets the path handling mode
func (pfs *PathAwareFileSystem) WithPathMode(mode PathMode) *PathAwareFileSystem <span class="cov8" title="1">{
        pfs.handler = NewPathHandler(pfs.handler.base, mode)
        return pfs
}</span>

// WithAbsolutePaths forces absolute path handling
func (pfs *PathAwareFileSystem) WithAbsolutePaths() *PathAwareFileSystem <span class="cov8" title="1">{
        return pfs.WithPathMode(PathModeAbsolute)
}</span>

// WithRelativePaths forces relative path handling
func (pfs *PathAwareFileSystem) WithRelativePaths() *PathAwareFileSystem <span class="cov8" title="1">{
        return pfs.WithPathMode(PathModeRelative)
}</span>

// WithAutoDetectPaths enables automatic path detection (default)
func (pfs *PathAwareFileSystem) WithAutoDetectPaths() *PathAwareFileSystem <span class="cov8" title="1">{
        return pfs.WithPathMode(PathModeAuto)
}</span>

// Open implements fs.FS
func (pfs *PathAwareFileSystem) Open(name string) (fs.File, error) <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;fs.PathError{Op: "open", Path: name, Err: err}
        }</span>
        <span class="cov8" title="1">return pfs.fs.Open(resolved)</span>
}

// Stat implements StatFS
func (pfs *PathAwareFileSystem) Stat(name string) (fs.FileInfo, error) <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;fs.PathError{Op: "stat", Path: name, Err: err}
        }</span>

        // Check if the underlying FS implements StatFS
        <span class="cov8" title="1">if statFS, ok := pfs.fs.(filesystem.StatFS); ok </span><span class="cov8" title="1">{
                return statFS.Stat(resolved)
        }</span>

        // Fallback to Open + Stat
        <span class="cov0" title="0">f, err := pfs.fs.Open(resolved)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()
        <span class="cov0" title="0">return f.Stat()</span>
}

// ReadFile implements ReadFS
func (pfs *PathAwareFileSystem) ReadFile(name string) ([]byte, error) <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;fs.PathError{Op: "readfile", Path: name, Err: err}
        }</span>

        <span class="cov8" title="1">f, err := pfs.fs.Open(resolved)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

        // Use fs.ReadFile if available
        <span class="cov8" title="1">return fs.ReadFile(pfs.fs, resolved)</span>
}

// WriteFile implements WriteFS
func (pfs *PathAwareFileSystem) WriteFile(name string, data []byte, perm fs.FileMode) error <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;fs.PathError{Op: "writefile", Path: name, Err: err}
        }</span>

        <span class="cov8" title="1">if writeFS, ok := pfs.fs.(filesystem.WriteFS); ok </span><span class="cov8" title="1">{
                return writeFS.WriteFile(resolved, data, perm)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "writefile", Path: name, Err: fs.ErrInvalid}</span>
}

// MkdirAll implements WriteFS
func (pfs *PathAwareFileSystem) MkdirAll(path string, perm fs.FileMode) error <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(path)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;fs.PathError{Op: "mkdirall", Path: path, Err: err}
        }</span>

        <span class="cov8" title="1">if writeFS, ok := pfs.fs.(filesystem.WriteFS); ok </span><span class="cov8" title="1">{
                return writeFS.MkdirAll(resolved, perm)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "mkdirall", Path: path, Err: fs.ErrInvalid}</span>
}

// Remove implements WriteFS
func (pfs *PathAwareFileSystem) Remove(name string) error <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "remove", Path: name, Err: err}
        }</span>

        <span class="cov8" title="1">if writeFS, ok := pfs.fs.(filesystem.WriteFS); ok </span><span class="cov8" title="1">{
                return writeFS.Remove(resolved)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}</span>
}

// RemoveAll implements WriteFS
func (pfs *PathAwareFileSystem) RemoveAll(name string) error <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "removeall", Path: name, Err: err}
        }</span>

        <span class="cov8" title="1">if writeFS, ok := pfs.fs.(filesystem.WriteFS); ok </span><span class="cov8" title="1">{
                return writeFS.RemoveAll(resolved)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}</span>
}

// Rename implements FullFileSystem
func (pfs *PathAwareFileSystem) Rename(oldpath, newpath string) error <span class="cov8" title="1">{
        resolvedOld, err := pfs.resolvePath(oldpath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "rename", Path: oldpath, Err: err}
        }</span>

        <span class="cov8" title="1">resolvedNew, err := pfs.resolvePath(newpath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "rename", Path: newpath, Err: err}
        }</span>

        <span class="cov8" title="1">if fullFS, ok := pfs.fs.(filesystem.FullFileSystem); ok </span><span class="cov8" title="1">{
                return fullFS.Rename(resolvedOld, resolvedNew)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "rename", Path: oldpath, Err: fs.ErrInvalid}</span>
}

// Symlink implements FullFileSystem
func (pfs *PathAwareFileSystem) Symlink(oldname, newname string) error <span class="cov8" title="1">{
        // For symlinks, we need to be careful about the target
        // The target (oldname) might be relative to the link location
        resolvedNew, err := pfs.resolvePath(newname)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "symlink", Path: newname, Err: err}
        }</span>

        // The target can be absolute or relative
        // If it's relative, it's relative to the link's directory
        <span class="cov8" title="1">targetPath := oldname
        if filepath.IsAbs(oldname) </span><span class="cov0" title="0">{
                // Resolve absolute target
                targetPath, err = pfs.resolvePath(oldname)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;fs.PathError{Op: "symlink", Path: oldname, Err: err}
                }</span>
        }

        <span class="cov8" title="1">if fullFS, ok := pfs.fs.(filesystem.FullFileSystem); ok </span><span class="cov8" title="1">{
                return fullFS.Symlink(targetPath, resolvedNew)
        }</span>

        <span class="cov0" title="0">return &amp;fs.PathError{Op: "symlink", Path: newname, Err: fs.ErrInvalid}</span>
}

// Readlink implements FullFileSystem
func (pfs *PathAwareFileSystem) Readlink(name string) (string, error) <span class="cov8" title="1">{
        resolved, err := pfs.resolvePath(name)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: err}
        }</span>

        <span class="cov8" title="1">if fullFS, ok := pfs.fs.(filesystem.FullFileSystem); ok </span><span class="cov8" title="1">{
                return fullFS.Readlink(resolved)
        }</span>

        <span class="cov0" title="0">return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: fs.ErrInvalid}</span>
}

// resolvePath handles the path resolution, converting to relative for the underlying FS
func (pfs *PathAwareFileSystem) resolvePath(path string) (string, error) <span class="cov8" title="1">{
        // First resolve the path according to our rules
        resolved, err := pfs.handler.ResolvePath(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Now make it relative for the underlying filesystem
        // The underlying FS expects relative paths from its root
        <span class="cov8" title="1">rel, err := pfs.handler.MakeRelative(resolved)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't make it relative, try stripping the base
                if strings.HasPrefix(resolved, pfs.handler.base) </span><span class="cov0" title="0">{
                        rel = strings.TrimPrefix(resolved, pfs.handler.base)
                        rel = strings.TrimPrefix(rel, "/")
                }</span> else<span class="cov0" title="0"> {
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">return rel, nil</span>
}

// GetPathHandler returns the underlying path handler for direct access
func (pfs *PathAwareFileSystem) GetPathHandler() *PathHandler <span class="cov0" title="0">{
        return pfs.handler
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package synthfs

import (
        "fmt"
        "path/filepath"
        "strings"
)

// PathMode defines how paths are handled
type PathMode int

const (
        // PathModeAuto automatically detects and handles both absolute and relative paths
        PathModeAuto PathMode = iota
        // PathModeAbsolute forces all paths to be treated as absolute
        PathModeAbsolute
        // PathModeRelative forces all paths to be treated as relative to the base
        PathModeRelative
)

// PathHandler manages path resolution and normalization
type PathHandler struct {
        base string
        mode PathMode
}

// NewPathHandler creates a new path handler with the given base and mode
func NewPathHandler(base string, mode PathMode) *PathHandler <span class="cov8" title="1">{
        // Ensure base is clean and absolute
        if base == "" </span><span class="cov8" title="1">{
                base = "/"
        }</span>
        <span class="cov8" title="1">base = filepath.Clean(base)
        if !filepath.IsAbs(base) </span><span class="cov8" title="1">{
                // Try to make it absolute
                if abs, err := filepath.Abs(base); err == nil </span><span class="cov8" title="1">{
                        base = abs
                }</span>
        }

        <span class="cov8" title="1">return &amp;PathHandler{
                base: base,
                mode: mode,
        }</span>
}

// ResolvePath resolves a path according to the handler's mode
func (ph *PathHandler) ResolvePath(path string) (string, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("empty path")
        }</span>

        // Clean the path first
        <span class="cov8" title="1">path = filepath.Clean(path)

        switch ph.mode </span>{
        case PathModeAuto:<span class="cov8" title="1">
                return ph.resolveAuto(path)</span>
        case PathModeAbsolute:<span class="cov8" title="1">
                return ph.resolveAbsolute(path)</span>
        case PathModeRelative:<span class="cov8" title="1">
                return ph.resolveRelative(path)</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid path mode: %v", ph.mode)</span>
        }
}

// resolveAuto automatically detects path type and resolves appropriately
func (ph *PathHandler) resolveAuto(path string) (string, error) <span class="cov8" title="1">{
        if filepath.IsAbs(path) </span><span class="cov8" title="1">{
                // Absolute path - use as is but validate it doesn't escape root
                if ph.base != "/" &amp;&amp; !strings.HasPrefix(path, ph.base) </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("path %q escapes filesystem root in Auto mode (absolute path outside root %q)", path, ph.base)
                }</span>
                <span class="cov8" title="1">return path, nil</span>
        }

        // Relative path - resolve against base
        <span class="cov8" title="1">resolved := filepath.Join(ph.base, path)

        // Ensure resolved path doesn't escape the base
        if !strings.HasPrefix(resolved, ph.base) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path %q escapes filesystem root in Auto mode (resolved as %q)", path, resolved)
        }</span>

        <span class="cov8" title="1">return resolved, nil</span>
}

// resolveAbsolute treats all paths as absolute
func (ph *PathHandler) resolveAbsolute(path string) (string, error) <span class="cov8" title="1">{
        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                // Convert to absolute by prepending /
                path = "/" + strings.TrimPrefix(path, "./")
        }</span>

        // Validate it doesn't escape root
        <span class="cov8" title="1">if ph.base != "/" &amp;&amp; !strings.HasPrefix(path, ph.base) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path %q escapes filesystem root in Absolute mode (outside root %q)", path, ph.base)
        }</span>

        <span class="cov8" title="1">return path, nil</span>
}

// resolveRelative treats all paths as relative to base
func (ph *PathHandler) resolveRelative(path string) (string, error) <span class="cov8" title="1">{
        // Strip any leading / to make it relative
        originalPath := path
        path = strings.TrimPrefix(path, "/")

        // Resolve against base
        resolved := filepath.Join(ph.base, path)

        // Ensure resolved path doesn't escape the base
        if !strings.HasPrefix(resolved, ph.base) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path %q escapes filesystem root in Relative mode (resolved as %q)", originalPath, resolved)
        }</span>

        <span class="cov8" title="1">return resolved, nil</span>
}

// MakeRelative converts an absolute path to relative from the base
func (ph *PathHandler) MakeRelative(path string) (string, error) <span class="cov8" title="1">{
        path = filepath.Clean(path)

        if !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                return path, nil // Already relative
        }</span>

        <span class="cov8" title="1">rel, err := filepath.Rel(ph.base, path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Ensure it doesn't escape
        <span class="cov8" title="1">if strings.HasPrefix(rel, "..") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path %q is outside filesystem root %q", path, ph.base)
        }</span>

        <span class="cov8" title="1">return rel, nil</span>
}

// ValidatePath checks if a path is valid without modifying it
func (ph *PathHandler) ValidatePath(path string) error <span class="cov0" title="0">{
        _, err := ph.ResolvePath(path)
        return err
}</span>

// NormalizePath cleans and normalizes a path
func NormalizePath(path string) string <span class="cov8" title="1">{
        // Clean the path
        path = filepath.Clean(path)

        // Remove double slashes
        for strings.Contains(path, "//") </span><span class="cov0" title="0">{
                path = strings.ReplaceAll(path, "//", "/")
        }</span>

        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package synthfs

import (
        "context"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/operations"
        "github.com/arthur-debert/synthfs/pkg/synthfs/targets"
)

// detectArchiveFormat detects the archive format from the file extension
func detectArchiveFormat(path string) targets.ArchiveFormat <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(path))
        switch ext </span>{
        case ".zip":<span class="cov8" title="1">
                return targets.ArchiveFormatZip</span>
        case ".tar":<span class="cov8" title="1">
                return targets.ArchiveFormatTarGz</span> // Default tar to tar.gz for now
        case ".gz", ".tgz":<span class="cov8" title="1">
                if strings.HasSuffix(strings.ToLower(path), ".tar.gz") || ext == ".tgz" </span><span class="cov8" title="1">{
                        return targets.ArchiveFormatTarGz
                }</span>
        }
        <span class="cov8" title="1">return targets.ArchiveFormatZip</span> // Default to zip
}

// CreateArchive creates an archive operation
func (s *SynthFS) CreateArchive(archivePath string, sources ...string) Operation <span class="cov8" title="1">{
        id := s.idGen("create_archive", archivePath)

        // Detect format from file extension
        format := detectArchiveFormat(archivePath)

        // Create the archive target
        archive := targets.NewArchive(archivePath, format, sources)

        // Create the operation
        op := operations.NewCreateArchiveOperation(id, archivePath)
        op.SetItem(archive)

        // Also set sources and format in description details as fallback
        op.SetDescriptionDetail("sources", sources)
        op.SetDescriptionDetail("format", format.String())

        return &amp;OperationsPackageAdapter{opsOperation: op}
}</span>

// CreateZipArchive creates a ZIP archive operation
func (s *SynthFS) CreateZipArchive(archivePath string, sources ...string) Operation <span class="cov8" title="1">{
        id := s.idGen("create_archive", archivePath)

        // Create the archive target with ZIP format
        archive := targets.NewArchive(archivePath, targets.ArchiveFormatZip, sources)

        // Create the operation
        op := operations.NewCreateArchiveOperation(id, archivePath)
        op.SetItem(archive)

        // Also set sources and format in description details as fallback
        op.SetDescriptionDetail("sources", sources)
        op.SetDescriptionDetail("format", "zip")

        return &amp;OperationsPackageAdapter{opsOperation: op}
}</span>

// CreateTarArchive creates a TAR archive operation
func (s *SynthFS) CreateTarArchive(archivePath string, sources ...string) Operation <span class="cov0" title="0">{
        // Note: We don't have a plain TAR format in targets, so we use TarGz
        return s.CreateTarGzArchive(archivePath, sources...)
}</span>

// CreateTarGzArchive creates a gzipped TAR archive operation
func (s *SynthFS) CreateTarGzArchive(archivePath string, sources ...string) Operation <span class="cov8" title="1">{
        id := s.idGen("create_archive", archivePath)

        // Create the archive target with TAR.GZ format
        archive := targets.NewArchive(archivePath, targets.ArchiveFormatTarGz, sources)

        // Create the operation
        op := operations.NewCreateArchiveOperation(id, archivePath)
        op.SetItem(archive)

        // Also set sources and format in description details as fallback
        op.SetDescriptionDetail("sources", sources)
        op.SetDescriptionDetail("format", "tar.gz")

        return &amp;OperationsPackageAdapter{opsOperation: op}
}</span>

// ExtractArchive creates an unarchive operation
func (s *SynthFS) ExtractArchive(archivePath, extractPath string) Operation <span class="cov8" title="1">{
        id := s.idGen("unarchive", archivePath)

        // Create the unarchive item
        unarchive := targets.NewUnarchive(archivePath, extractPath)

        // Create the operation
        op := operations.NewUnarchiveOperation(id, archivePath)
        op.SetItem(unarchive)

        return &amp;OperationsPackageAdapter{opsOperation: op}
}</span>

// ExtractArchiveWithPatterns creates an unarchive operation with file patterns
func (s *SynthFS) ExtractArchiveWithPatterns(archivePath, extractPath string, patterns ...string) Operation <span class="cov8" title="1">{
        id := s.idGen("unarchive", archivePath)

        // Create the unarchive item with patterns
        unarchive := targets.NewUnarchive(archivePath, extractPath).WithPatterns(patterns...)

        // Create the operation
        op := operations.NewUnarchiveOperation(id, archivePath)
        op.SetItem(unarchive)

        return &amp;OperationsPackageAdapter{opsOperation: op}
}</span>

// Archive provides direct archive creation with execution
func Archive(ctx context.Context, fs FileSystem, archivePath string, sources ...string) error <span class="cov8" title="1">{
        op := New().CreateArchive(archivePath, sources...)
        return op.Execute(ctx, fs)
}</span>

// Extract provides direct archive extraction with execution
func Extract(ctx context.Context, fs FileSystem, archivePath, extractPath string) error <span class="cov0" title="0">{
        op := New().ExtractArchive(archivePath, extractPath)
        return op.Execute(ctx, fs)
}</span>

// ArchiveBuilder provides a fluent interface for creating archives
type ArchiveBuilder struct {
        archivePath string
        sources     []string
        format      targets.ArchiveFormat
}

// NewArchiveBuilder creates a new archive builder
func NewArchiveBuilder(archivePath string) *ArchiveBuilder <span class="cov8" title="1">{
        return &amp;ArchiveBuilder{
                archivePath: archivePath,
                sources:     []string{},
                format:      detectArchiveFormat(archivePath),
        }
}</span>

// AddSource adds a source to the archive
func (ab *ArchiveBuilder) AddSource(source string) *ArchiveBuilder <span class="cov8" title="1">{
        ab.sources = append(ab.sources, source)
        return ab
}</span>

// AddSources adds multiple sources to the archive
func (ab *ArchiveBuilder) AddSources(sources ...string) *ArchiveBuilder <span class="cov8" title="1">{
        ab.sources = append(ab.sources, sources...)
        return ab
}</span>

// WithFormat sets the archive format explicitly
func (ab *ArchiveBuilder) WithFormat(format targets.ArchiveFormat) *ArchiveBuilder <span class="cov8" title="1">{
        ab.format = format
        return ab
}</span>

// AsZip sets the format to ZIP
func (ab *ArchiveBuilder) AsZip() *ArchiveBuilder <span class="cov8" title="1">{
        return ab.WithFormat(targets.ArchiveFormatZip)
}</span>

// AsTar sets the format to TAR
func (ab *ArchiveBuilder) AsTar() *ArchiveBuilder <span class="cov0" title="0">{
        // Note: We don't have a plain TAR format, so we use TarGz
        return ab.WithFormat(targets.ArchiveFormatTarGz)
}</span>

// AsTarGz sets the format to gzipped TAR
func (ab *ArchiveBuilder) AsTarGz() *ArchiveBuilder <span class="cov8" title="1">{
        return ab.WithFormat(targets.ArchiveFormatTarGz)
}</span>

// Build creates the archive operation
func (ab *ArchiveBuilder) Build() Operation <span class="cov8" title="1">{
        sfs := New()
        if len(ab.sources) == 0 </span><span class="cov0" title="0">{
                // Return an operation that will fail validation
                return sfs.CreateArchive(ab.archivePath)
        }</span>

        <span class="cov8" title="1">var op Operation
        switch ab.format </span>{
        case targets.ArchiveFormatZip:<span class="cov8" title="1">
                op = sfs.CreateZipArchive(ab.archivePath, ab.sources...)</span>
        case targets.ArchiveFormatTarGz:<span class="cov8" title="1">
                op = sfs.CreateTarGzArchive(ab.archivePath, ab.sources...)</span>
        default:<span class="cov0" title="0">
                op = sfs.CreateArchive(ab.archivePath, ab.sources...)</span>
        }

        <span class="cov8" title="1">return op</span>
}

// Execute creates and executes the archive operation
func (ab *ArchiveBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        op := ab.Build()
        return op.Execute(ctx, fs)
}</span>

// ExtractBuilder provides a fluent interface for extracting archives
type ExtractBuilder struct {
        archivePath string
        extractPath string
        patterns    []string
}

// NewExtractBuilder creates a new extract builder
func NewExtractBuilder(archivePath string) *ExtractBuilder <span class="cov8" title="1">{
        return &amp;ExtractBuilder{
                archivePath: archivePath,
                extractPath: ".",
                patterns:    []string{},
        }
}</span>

// To sets the extraction destination
func (eb *ExtractBuilder) To(path string) *ExtractBuilder <span class="cov8" title="1">{
        eb.extractPath = path
        return eb
}</span>

// WithPattern adds a file pattern to extract
func (eb *ExtractBuilder) WithPattern(pattern string) *ExtractBuilder <span class="cov8" title="1">{
        eb.patterns = append(eb.patterns, pattern)
        return eb
}</span>

// WithPatterns adds multiple file patterns to extract
func (eb *ExtractBuilder) WithPatterns(patterns ...string) *ExtractBuilder <span class="cov8" title="1">{
        eb.patterns = append(eb.patterns, patterns...)
        return eb
}</span>

// OnlyFiles extracts only files matching the given patterns
func (eb *ExtractBuilder) OnlyFiles(patterns ...string) *ExtractBuilder <span class="cov8" title="1">{
        return eb.WithPatterns(patterns...)
}</span>

// Build creates the extract operation
func (eb *ExtractBuilder) Build() Operation <span class="cov8" title="1">{
        sfs := New()
        if len(eb.patterns) &gt; 0 </span><span class="cov8" title="1">{
                return sfs.ExtractArchiveWithPatterns(eb.archivePath, eb.extractPath, eb.patterns...)
        }</span>
        <span class="cov0" title="0">return sfs.ExtractArchive(eb.archivePath, eb.extractPath)</span>
}

// Execute creates and executes the extract operation
func (eb *ExtractBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov0" title="0">{
        op := eb.Build()
        return op.Execute(ctx, fs)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package synthfs

import (
        "context"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// CopyTreeOptions configures how a directory tree is copied
type CopyTreeOptions struct {
        // Filter determines which files/dirs to include (return true to include)
        Filter func(path string, info fs.FileInfo) bool
        // PreservePermissions copies file permissions
        PreservePermissions bool
        // PreserveTimestamps copies modification times
        PreserveTimestamps bool
        // FollowSymlinks follows symlinks instead of copying them
        FollowSymlinks bool
        // Overwrite existing files
        Overwrite bool
}

// CopyTree creates operations to recursively copy a directory tree
func (s *SynthFS) CopyTree(srcDir, dstDir string, opts ...CopyTreeOptions) ([]Operation, error) <span class="cov0" title="0">{
        var options CopyTreeOptions
        if len(opts) &gt; 0 </span><span class="cov0" title="0">{
                options = opts[0]
        }</span>

        // Default filter accepts everything
        <span class="cov0" title="0">if options.Filter == nil </span><span class="cov0" title="0">{
                options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov0" title="0">{ return true }</span>
        }

        <span class="cov0" title="0">var ops []Operation

        // Walk the source directory and create copy operations
        _ = func(srcPath string, dstPath string, info fs.FileInfo) error </span><span class="cov0" title="0">{
                // Apply filter
                if !options.Filter(srcPath, info) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(srcDir, srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">targetPath := filepath.Join(dstDir, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        // Create directory
                        op := s.CreateDir(targetPath, info.Mode())
                        ops = append(ops, op)
                }</span> else<span class="cov0" title="0"> if info.Mode()&amp;fs.ModeSymlink != 0 &amp;&amp; !options.FollowSymlinks </span><span class="cov0" title="0">{
                        // Copy symlink
                        op := s.CreateSymlink("", targetPath) // We'd need to read the link target
                        ops = append(ops, op)
                }</span> else<span class="cov0" title="0"> {
                        // Copy file
                        op := s.Copy(srcPath, targetPath)
                        if options.PreservePermissions </span><span class="cov0" title="0">{
                                if adapter, ok := op.(*OperationsPackageAdapter); ok </span><span class="cov0" title="0">{
                                        adapter.SetDescriptionDetail("preserve_mode", true)
                                        adapter.SetDescriptionDetail("mode", info.Mode())
                                }</span>
                        }
                        <span class="cov0" title="0">ops = append(ops, op)</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        // Since we can't actually walk the filesystem here (no fs parameter),
        // we'll return a function that creates the operations when executed
        // For now, we'll create a custom operation that handles this
        <span class="cov0" title="0">return nil, fmt.Errorf("CopyTree requires filesystem access - use CopyTreeOperation instead")</span>
}

// CopyTreeOperation is a special operation that copies an entire directory tree
type CopyTreeOperation struct {
        id      OperationID
        desc    OperationDesc
        srcDir  string
        dstDir  string
        options CopyTreeOptions
}

// NewCopyTreeOperation creates a new copy tree operation
func (s *SynthFS) NewCopyTreeOperation(srcDir, dstDir string, opts ...CopyTreeOptions) *CopyTreeOperation <span class="cov8" title="1">{
        var options CopyTreeOptions
        if len(opts) &gt; 0 </span><span class="cov8" title="1">{
                options = opts[0]
        }</span>

        // Default filter accepts everything
        <span class="cov8" title="1">if options.Filter == nil </span><span class="cov8" title="1">{
                options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{ return true }</span>
        }

        <span class="cov8" title="1">id := s.idGen("copy_tree", srcDir)
        return &amp;CopyTreeOperation{
                id: id,
                desc: OperationDesc{
                        Type: "copy_tree",
                        Path: srcDir,
                        Details: map[string]interface{}{
                                "src": srcDir,
                                "dst": dstDir,
                        },
                },
                srcDir:  srcDir,
                dstDir:  dstDir,
                options: options,
        }</span>
}

// ID returns the operation ID
func (op *CopyTreeOperation) ID() OperationID <span class="cov0" title="0">{
        return op.id
}</span>

// Describe returns the operation description
func (op *CopyTreeOperation) Describe() OperationDesc <span class="cov0" title="0">{
        return op.desc
}</span>

// Dependencies returns empty - no dependencies
func (op *CopyTreeOperation) Dependencies() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Conflicts returns empty - no conflicts
func (op *CopyTreeOperation) Conflicts() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Prerequisites returns prerequisites for the operation
func (op *CopyTreeOperation) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        return []core.Prerequisite{
                core.NewSourceExistsPrerequisite(op.srcDir),
                core.NewParentDirPrerequisite(op.dstDir),
        }
}</span>

// GetItem returns nil - no specific item
func (op *CopyTreeOperation) GetItem() FsItem <span class="cov0" title="0">{
        return nil
}</span>

// SetDescriptionDetail sets a detail in the description
func (op *CopyTreeOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        if op.desc.Details == nil </span><span class="cov0" title="0">{
                op.desc.Details = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">op.desc.Details[key] = value</span>
}

// AddDependency adds a dependency
func (op *CopyTreeOperation) AddDependency(depID OperationID) {<span class="cov0" title="0">
        // Not implemented for this operation
}</span>

// SetPaths sets source and destination paths
func (op *CopyTreeOperation) SetPaths(src, dst string) <span class="cov0" title="0">{
        op.srcDir = src
        op.dstDir = dst
        op.desc.Path = src
        op.desc.Details["src"] = src
        op.desc.Details["dst"] = dst
}</span>

// GetChecksum returns nil
func (op *CopyTreeOperation) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// GetAllChecksums returns nil
func (op *CopyTreeOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// ExecuteV2 is not implemented
func (op *CopyTreeOperation) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ExecuteV2 not implemented for CopyTreeOperation")
}</span>

// ValidateV2 is not implemented
func (op *CopyTreeOperation) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ValidateV2 not implemented for CopyTreeOperation")
}</span>

// Rollback is not implemented yet
func (op *CopyTreeOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        // Would need to track all created files/dirs
        return fmt.Errorf("rollback not implemented for CopyTreeOperation")
}</span>

// ReverseOps generates reverse operations
func (op *CopyTreeOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        // Would create a delete operation for the destination
        return nil, nil, fmt.Errorf("reverse ops not implemented for CopyTreeOperation")
}</span>

// Execute performs the copy tree operation
func (op *CopyTreeOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Check if filesystem supports full operations
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support full operations")
        }</span>

        // We need a way to walk the filesystem
        // For now, we'll use a simple recursive approach
        <span class="cov8" title="1">var walk func(string) error
        walk = func(dir string) error </span><span class="cov8" title="1">{
                // Open directory
                f, err := fsys.Open(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

                // Read directory entries
                <span class="cov8" title="1">if dirReader, ok := f.(interface {
                        ReadDir(int) ([]fs.DirEntry, error)
                }); ok </span><span class="cov8" title="1">{
                        entries, err := dirReader.ReadDir(-1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                                srcPath := filepath.Join(dir, entry.Name())
                                info, err := entry.Info()
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Apply filter
                                <span class="cov8" title="1">if !op.options.Filter(srcPath, info) </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">relPath, err := filepath.Rel(op.srcDir, srcPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">dstPath := filepath.Join(op.dstDir, relPath)

                                if entry.IsDir() </span><span class="cov8" title="1">{
                                        // Create directory
                                        err = fullFS.MkdirAll(dstPath, info.Mode())
                                        if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        // Recurse
                                        <span class="cov8" title="1">if err := walk(srcPath); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } else<span class="cov8" title="1"> if info.Mode()&amp;fs.ModeSymlink != 0 &amp;&amp; !op.options.FollowSymlinks </span><span class="cov0" title="0">{
                                        // Read symlink
                                        target, err := fullFS.Readlink(srcPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        // Create symlink
                                        <span class="cov0" title="0">_ = fullFS.Symlink(target, dstPath)</span>
                                } else<span class="cov8" title="1"> {
                                        // Copy file
                                        content, err := fs.ReadFile(fsys, srcPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">mode := fs.FileMode(0644)
                                        if op.options.PreservePermissions </span><span class="cov8" title="1">{
                                                mode = info.Mode()
                                        }</span>

                                        <span class="cov8" title="1">err = fullFS.WriteFile(dstPath, content, mode)
                                        if err != nil &amp;&amp; !op.options.Overwrite </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">return nil</span>
        }

        // Create destination directory
        <span class="cov8" title="1">if err := fullFS.MkdirAll(op.dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start walking from source
        <span class="cov8" title="1">return walk(op.srcDir)</span>
}

// Validate checks if the operation can be performed
func (op *CopyTreeOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Check if filesystem supports Stat
        statFS, ok := fsys.(StatFS)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support Stat")
        }</span>

        // Check source exists
        <span class="cov8" title="1">info, err := statFS.Stat(op.srcDir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("source directory does not exist: %w", err)
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return fmt.Errorf("source is not a directory: %s", op.srcDir)
        }</span>

        // Check if destination exists
        <span class="cov8" title="1">if _, err := statFS.Stat(op.dstDir); err == nil &amp;&amp; !op.options.Overwrite </span><span class="cov8" title="1">{
                return fmt.Errorf("destination already exists: %s", op.dstDir)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CopyTreeBuilder provides a fluent interface for configuring tree copies
type CopyTreeBuilder struct {
        srcDir  string
        dstDir  string
        options CopyTreeOptions
}

// NewCopyTreeBuilder creates a new copy tree builder
func NewCopyTreeBuilder(srcDir, dstDir string) *CopyTreeBuilder <span class="cov8" title="1">{
        return &amp;CopyTreeBuilder{
                srcDir: srcDir,
                dstDir: dstDir,
                options: CopyTreeOptions{
                        Filter: func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{ return true }</span>,
                },
        }
}

// WithFilter sets a filter function
func (b *CopyTreeBuilder) WithFilter(filter func(path string, info fs.FileInfo) bool) *CopyTreeBuilder <span class="cov8" title="1">{
        b.options.Filter = filter
        return b
}</span>

// ExcludeHidden excludes hidden files (starting with .)
func (b *CopyTreeBuilder) ExcludeHidden() *CopyTreeBuilder <span class="cov8" title="1">{
        originalFilter := b.options.Filter
        b.options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{
                name := filepath.Base(path)
                if strings.HasPrefix(name, ".") </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return originalFilter(path, info)</span>
        }
        <span class="cov8" title="1">return b</span>
}

// ExcludePattern excludes files matching the pattern
func (b *CopyTreeBuilder) ExcludePattern(pattern string) *CopyTreeBuilder <span class="cov8" title="1">{
        originalFilter := b.options.Filter
        b.options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{
                matched, _ := filepath.Match(pattern, filepath.Base(path))
                if matched </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return originalFilter(path, info)</span>
        }
        <span class="cov8" title="1">return b</span>
}

// PreservePermissions enables permission preservation
func (b *CopyTreeBuilder) PreservePermissions() *CopyTreeBuilder <span class="cov8" title="1">{
        b.options.PreservePermissions = true
        return b
}</span>

// PreserveTimestamps enables timestamp preservation
func (b *CopyTreeBuilder) PreserveTimestamps() *CopyTreeBuilder <span class="cov0" title="0">{
        b.options.PreserveTimestamps = true
        return b
}</span>

// FollowSymlinks enables following symlinks
func (b *CopyTreeBuilder) FollowSymlinks() *CopyTreeBuilder <span class="cov0" title="0">{
        b.options.FollowSymlinks = true
        return b
}</span>

// Overwrite enables overwriting existing files
func (b *CopyTreeBuilder) Overwrite() *CopyTreeBuilder <span class="cov0" title="0">{
        b.options.Overwrite = true
        return b
}</span>

// Build creates the copy tree operation
func (b *CopyTreeBuilder) Build() Operation <span class="cov8" title="1">{
        return New().NewCopyTreeOperation(b.srcDir, b.dstDir, b.options)
}</span>

// Execute builds and executes the operation
func (b *CopyTreeBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        op := b.Build()
        return op.Execute(ctx, fs)
}</span>

// CopyTreeFunc is a convenience function for copying directory trees
func CopyTreeFunc(ctx context.Context, fs FileSystem, srcDir, dstDir string) error <span class="cov8" title="1">{
        op := New().NewCopyTreeOperation(srcDir, dstDir)
        return op.Execute(ctx, fs)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package synthfs

import (
        "context"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// MirrorOptions configures how a directory is mirrored with symlinks
type MirrorOptions struct {
        // Filter determines which files/dirs to include (return true to include)
        Filter func(path string, info fs.FileInfo) bool
        // IncludeDirectories creates directories instead of symlinking them
        IncludeDirectories bool
        // Overwrite existing symlinks
        Overwrite bool
}

// MirrorWithSymlinksOperation creates a directory structure with symlinks to original files
type MirrorWithSymlinksOperation struct {
        id      OperationID
        desc    OperationDesc
        srcDir  string
        dstDir  string
        options MirrorOptions
}

// NewMirrorWithSymlinksOperation creates a new mirror operation
func (s *SynthFS) NewMirrorWithSymlinksOperation(srcDir, dstDir string, opts ...MirrorOptions) *MirrorWithSymlinksOperation <span class="cov8" title="1">{
        var options MirrorOptions
        if len(opts) &gt; 0 </span><span class="cov8" title="1">{
                options = opts[0]
        }</span>

        // Default filter accepts everything
        <span class="cov8" title="1">if options.Filter == nil </span><span class="cov8" title="1">{
                options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{ return true }</span>
        }

        <span class="cov8" title="1">id := s.idGen("mirror_symlinks", srcDir)
        return &amp;MirrorWithSymlinksOperation{
                id: id,
                desc: OperationDesc{
                        Type: "mirror_symlinks",
                        Path: srcDir,
                        Details: map[string]interface{}{
                                "src": srcDir,
                                "dst": dstDir,
                        },
                },
                srcDir:  srcDir,
                dstDir:  dstDir,
                options: options,
        }</span>
}

// ID returns the operation ID
func (op *MirrorWithSymlinksOperation) ID() OperationID <span class="cov0" title="0">{
        return op.id
}</span>

// Describe returns the operation description
func (op *MirrorWithSymlinksOperation) Describe() OperationDesc <span class="cov0" title="0">{
        return op.desc
}</span>

// Dependencies returns empty - no dependencies
func (op *MirrorWithSymlinksOperation) Dependencies() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Conflicts returns empty - no conflicts
func (op *MirrorWithSymlinksOperation) Conflicts() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Prerequisites returns prerequisites for the operation
func (op *MirrorWithSymlinksOperation) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        return []core.Prerequisite{
                core.NewSourceExistsPrerequisite(op.srcDir),
                core.NewParentDirPrerequisite(op.dstDir),
        }
}</span>

// GetItem returns nil - no specific item
func (op *MirrorWithSymlinksOperation) GetItem() FsItem <span class="cov0" title="0">{
        return nil
}</span>

// SetDescriptionDetail sets a detail in the description
func (op *MirrorWithSymlinksOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        if op.desc.Details == nil </span><span class="cov0" title="0">{
                op.desc.Details = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">op.desc.Details[key] = value</span>
}

// AddDependency adds a dependency
func (op *MirrorWithSymlinksOperation) AddDependency(depID OperationID) {<span class="cov0" title="0">
        // Not implemented for this operation
}</span>

// SetPaths sets source and destination paths
func (op *MirrorWithSymlinksOperation) SetPaths(src, dst string) <span class="cov0" title="0">{
        op.srcDir = src
        op.dstDir = dst
        op.desc.Path = src
        op.desc.Details["src"] = src
        op.desc.Details["dst"] = dst
}</span>

// GetChecksum returns nil
func (op *MirrorWithSymlinksOperation) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// GetAllChecksums returns nil
func (op *MirrorWithSymlinksOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// ExecuteV2 is not implemented
func (op *MirrorWithSymlinksOperation) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ExecuteV2 not implemented for MirrorWithSymlinksOperation")
}</span>

// ValidateV2 is not implemented
func (op *MirrorWithSymlinksOperation) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ValidateV2 not implemented for MirrorWithSymlinksOperation")
}</span>

// Rollback is not implemented yet
func (op *MirrorWithSymlinksOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        return fmt.Errorf("rollback not implemented for MirrorWithSymlinksOperation")
}</span>

// ReverseOps generates reverse operations
func (op *MirrorWithSymlinksOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        return nil, nil, fmt.Errorf("reverse ops not implemented for MirrorWithSymlinksOperation")
}</span>

// Execute performs the mirror operation
func (op *MirrorWithSymlinksOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Check if filesystem supports full operations
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support full operations (symlinks)")
        }</span>

        // Recursive walk function
        <span class="cov8" title="1">var walk func(string) error
        walk = func(dir string) error </span><span class="cov8" title="1">{
                // Open directory
                f, err := fsys.Open(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

                // Read directory entries
                <span class="cov8" title="1">if dirReader, ok := f.(interface {
                        ReadDir(int) ([]fs.DirEntry, error)
                }); ok </span><span class="cov8" title="1">{
                        entries, err := dirReader.ReadDir(-1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                                srcPath := filepath.Join(dir, entry.Name())
                                info, err := entry.Info()
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Apply filter
                                <span class="cov8" title="1">if !op.options.Filter(srcPath, info) </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                // Calculate relative and destination paths
                                <span class="cov8" title="1">relPath, err := filepath.Rel(op.srcDir, srcPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">dstPath := filepath.Join(op.dstDir, relPath)

                                if entry.IsDir() </span><span class="cov8" title="1">{
                                        if op.options.IncludeDirectories </span><span class="cov8" title="1">{
                                                // Create real directory
                                                err = fullFS.MkdirAll(dstPath, info.Mode())
                                                if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>

                                                // Recurse into directory
                                                <span class="cov8" title="1">if err := walk(srcPath); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                // Create parent directory if needed
                                                dstParent := filepath.Dir(dstPath)
                                                if dstParent != "." &amp;&amp; dstParent != "/" </span><span class="cov8" title="1">{
                                                        err = fullFS.MkdirAll(dstParent, 0755)
                                                        if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                }

                                                // Symlink the directory with relative path
                                                <span class="cov8" title="1">relTarget, err := filepath.Rel(filepath.Dir(dstPath), srcPath)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        // Fallback to absolute within the filesystem
                                                        relTarget = srcPath
                                                }</span>

                                                // Remove existing if overwrite is enabled
                                                <span class="cov8" title="1">if op.options.Overwrite </span><span class="cov0" title="0">{
                                                        _ = fullFS.Remove(dstPath)
                                                }</span>

                                                <span class="cov8" title="1">err = fullFS.Symlink(relTarget, dstPath)
                                                if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("failed to create symlink %s -&gt; %s: %w", dstPath, relTarget, err)
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        // Create parent directory if needed
                                        dstParent := filepath.Dir(dstPath)
                                        if dstParent != "." &amp;&amp; dstParent != "/" </span><span class="cov8" title="1">{
                                                err = fullFS.MkdirAll(dstParent, 0755)
                                                if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }

                                        // Create symlink to file with relative path
                                        <span class="cov8" title="1">relTarget, err := filepath.Rel(filepath.Dir(dstPath), srcPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // Fallback to absolute within the filesystem
                                                relTarget = srcPath
                                        }</span>

                                        // Remove existing if overwrite is enabled
                                        <span class="cov8" title="1">if op.options.Overwrite </span><span class="cov0" title="0">{
                                                _ = fullFS.Remove(dstPath)
                                        }</span>

                                        <span class="cov8" title="1">err = fullFS.Symlink(relTarget, dstPath)
                                        if err != nil &amp;&amp; !strings.Contains(err.Error(), "exists") </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to create symlink %s -&gt; %s: %w", dstPath, relTarget, err)
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">return nil</span>
        }

        // Create destination directory
        <span class="cov8" title="1">if err := fullFS.MkdirAll(op.dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start walking from source
        <span class="cov8" title="1">return walk(op.srcDir)</span>
}

// Validate checks if the operation can be performed
func (op *MirrorWithSymlinksOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Check if filesystem supports Stat
        statFS, ok := fsys.(StatFS)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support Stat")
        }</span>

        // Check if filesystem supports symlinks
        <span class="cov8" title="1">if _, ok := fsys.(FullFileSystem); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support symlinks")
        }</span>

        // Check source exists
        <span class="cov8" title="1">info, err := statFS.Stat(op.srcDir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("source directory does not exist: %w", err)
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return fmt.Errorf("source is not a directory: %s", op.srcDir)
        }</span>

        // Check if destination exists
        <span class="cov8" title="1">if _, err := statFS.Stat(op.dstDir); err == nil &amp;&amp; !op.options.Overwrite </span><span class="cov8" title="1">{
                return fmt.Errorf("destination already exists: %s", op.dstDir)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MirrorBuilder provides a fluent interface for creating mirror operations
type MirrorBuilder struct {
        srcDir  string
        dstDir  string
        options MirrorOptions
}

// NewMirrorBuilder creates a new mirror builder
func NewMirrorBuilder(srcDir, dstDir string) *MirrorBuilder <span class="cov8" title="1">{
        return &amp;MirrorBuilder{
                srcDir: srcDir,
                dstDir: dstDir,
                options: MirrorOptions{
                        Filter: func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{ return true }</span>,
                },
        }
}

// WithFilter sets a filter function
func (b *MirrorBuilder) WithFilter(filter func(path string, info fs.FileInfo) bool) *MirrorBuilder <span class="cov8" title="1">{
        b.options.Filter = filter
        return b
}</span>

// ExcludeHidden excludes hidden files (starting with .)
func (b *MirrorBuilder) ExcludeHidden() *MirrorBuilder <span class="cov8" title="1">{
        originalFilter := b.options.Filter
        b.options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{
                name := filepath.Base(path)
                if strings.HasPrefix(name, ".") </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return originalFilter(path, info)</span>
        }
        <span class="cov8" title="1">return b</span>
}

// IncludeDirectories creates real directories instead of symlinking them
func (b *MirrorBuilder) IncludeDirectories() *MirrorBuilder <span class="cov8" title="1">{
        b.options.IncludeDirectories = true
        return b
}</span>

// Overwrite enables overwriting existing symlinks
func (b *MirrorBuilder) Overwrite() *MirrorBuilder <span class="cov0" title="0">{
        b.options.Overwrite = true
        return b
}</span>

// Build creates the mirror operation
func (b *MirrorBuilder) Build() Operation <span class="cov8" title="1">{
        return New().NewMirrorWithSymlinksOperation(b.srcDir, b.dstDir, b.options)
}</span>

// Execute builds and executes the operation
func (b *MirrorBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        op := b.Build()
        return op.Execute(ctx, fs)
}</span>

// MirrorWithSymlinks is a convenience function
func MirrorWithSymlinks(ctx context.Context, fs FileSystem, srcDir, dstDir string) error <span class="cov8" title="1">{
        op := New().NewMirrorWithSymlinksOperation(srcDir, dstDir)
        return op.Execute(ctx, fs)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package synthfs

import (
        "context"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// StructureEntry represents a single entry in a directory structure
type StructureEntry struct {
        Path      string
        IsDir     bool
        Content   []byte
        Mode      fs.FileMode
        IsSymlink bool
        Target    string
}

// ParseStructure parses a tree-like structure definition
func ParseStructure(structure string) ([]StructureEntry, error) <span class="cov8" title="1">{
        var entries []StructureEntry
        lines := strings.Split(structure, "\n")

        // Track directory stack for path construction
        dirStack := []string{}
        lastDepth := -1

        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Count leading spaces/tabs to determine depth
                // For tree-style format, we need to handle tree characters specially
                <span class="cov8" title="1">depth := 0
                hasTreeChars := strings.ContainsAny(line, "")

                if hasTreeChars </span><span class="cov8" title="1">{
                        // For tree format, count the  prefixes first
                        tempLine := line
                        for strings.HasPrefix(tempLine, "   ") </span><span class="cov8" title="1">{
                                depth++
                                tempLine = tempLine[4:]
                        }</span>
                        // Trim any spaces between  and branch characters
                        <span class="cov8" title="1">tempLine = strings.TrimLeft(tempLine, " ")
                        // Then check for branch characters
                        if strings.HasPrefix(tempLine, " ") || strings.HasPrefix(tempLine, " ") </span><span class="cov8" title="1">{
                                depth++
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Normal indentation counting
                        for i, ch := range line </span><span class="cov8" title="1">{
                                if ch == ' ' || ch == '\t' </span><span class="cov8" title="1">{
                                        depth = i + 1
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                        // Normalize depth (4 spaces = 1 level)
                        <span class="cov8" title="1">depth = depth / 4</span>
                }

                // Adjust directory stack based on depth
                <span class="cov8" title="1">if depth &lt;= lastDepth </span><span class="cov8" title="1">{
                        // Pop directories to match depth
                        keep := depth
                        if keep &lt; 0 </span><span class="cov0" title="0">{
                                keep = 0
                        }</span>
                        <span class="cov8" title="1">if keep &lt; len(dirStack) </span><span class="cov8" title="1">{
                                dirStack = dirStack[:keep]
                        }</span>
                }
                <span class="cov8" title="1">lastDepth = depth

                // Parse the line
                trimmed := strings.TrimSpace(line)

                // Skip tree drawing characters (and their variations)
                trimmed = strings.TrimPrefix(trimmed, " ")
                trimmed = strings.TrimPrefix(trimmed, " ")
                trimmed = strings.TrimPrefix(trimmed, "   ")
                trimmed = strings.TrimPrefix(trimmed, "")
                trimmed = strings.TrimPrefix(trimmed, "")
                trimmed = strings.TrimPrefix(trimmed, "")
                trimmed = strings.TrimSpace(trimmed)

                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for symlink syntax: name -&gt; target
                <span class="cov8" title="1">isSymlink := false
                target := ""
                if parts := strings.Split(trimmed, " -&gt; "); len(parts) == 2 </span><span class="cov8" title="1">{
                        trimmed = parts[0]
                        target = parts[1]
                        isSymlink = true
                }</span>

                // Check if it's a directory (ends with /)
                <span class="cov8" title="1">isDir := strings.HasSuffix(trimmed, "/")
                if isDir </span><span class="cov8" title="1">{
                        trimmed = strings.TrimSuffix(trimmed, "/")
                }</span>

                // Build full path
                <span class="cov8" title="1">fullPath := trimmed
                if len(dirStack) &gt; 0 </span><span class="cov8" title="1">{
                        fullPath = filepath.Join(append(dirStack, trimmed)...)
                }</span>

                // Create entry
                <span class="cov8" title="1">entry := StructureEntry{
                        Path:      fullPath,
                        IsDir:     isDir,
                        Mode:      0644,
                        IsSymlink: isSymlink,
                        Target:    target,
                }

                if isDir </span><span class="cov8" title="1">{
                        entry.Mode = 0755
                }</span>

                <span class="cov8" title="1">entries = append(entries, entry)

                // Update directory stack AFTER creating the entry
                if isDir </span><span class="cov8" title="1">{
                        dirStack = append(dirStack, trimmed)
                }</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// CreateStructureOperation creates a directory structure from a definition
type CreateStructureOperation struct {
        id          OperationID
        desc        OperationDesc
        structure   string
        entries     []StructureEntry
        baseDir     string
        fileContent map[string][]byte
}

// NewCreateStructureOperation creates a new structure creation operation
func (s *SynthFS) NewCreateStructureOperation(structure string, baseDir string) (*CreateStructureOperation, error) <span class="cov8" title="1">{
        entries, err := ParseStructure(structure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">id := s.idGen("create_structure", baseDir)
        return &amp;CreateStructureOperation{
                id: id,
                desc: OperationDesc{
                        Type: "create_structure",
                        Path: baseDir,
                        Details: map[string]interface{}{
                                "structure":   structure,
                                "entry_count": len(entries),
                        },
                },
                structure:   structure,
                entries:     entries,
                baseDir:     baseDir,
                fileContent: make(map[string][]byte),
        }, nil</span>
}

// WithFileContent sets content for a specific file in the structure
func (op *CreateStructureOperation) WithFileContent(path string, content []byte) *CreateStructureOperation <span class="cov8" title="1">{
        op.fileContent[path] = content
        return op
}</span>

// ID returns the operation ID
func (op *CreateStructureOperation) ID() OperationID <span class="cov0" title="0">{
        return op.id
}</span>

// Describe returns the operation description
func (op *CreateStructureOperation) Describe() OperationDesc <span class="cov0" title="0">{
        return op.desc
}</span>

// Dependencies returns empty - no dependencies
func (op *CreateStructureOperation) Dependencies() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Conflicts returns empty - no conflicts
func (op *CreateStructureOperation) Conflicts() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Prerequisites returns prerequisites for the operation
func (op *CreateStructureOperation) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        var prereqs []core.Prerequisite

        // Need base directory parent to exist
        if op.baseDir != "" &amp;&amp; op.baseDir != "." </span><span class="cov0" title="0">{
                prereqs = append(prereqs, core.NewParentDirPrerequisite(op.baseDir))
        }</span>

        <span class="cov0" title="0">return prereqs</span>
}

// GetItem returns nil - no specific item
func (op *CreateStructureOperation) GetItem() FsItem <span class="cov0" title="0">{
        return nil
}</span>

// SetDescriptionDetail sets a detail in the description
func (op *CreateStructureOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        if op.desc.Details == nil </span><span class="cov0" title="0">{
                op.desc.Details = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">op.desc.Details[key] = value</span>
}

// AddDependency adds a dependency
func (op *CreateStructureOperation) AddDependency(depID OperationID) {<span class="cov0" title="0">
        // Not implemented for this operation
}</span>

// SetPaths sets source and destination paths
func (op *CreateStructureOperation) SetPaths(src, dst string) <span class="cov0" title="0">{
        op.baseDir = dst
        op.desc.Path = dst
}</span>

// GetChecksum returns nil
func (op *CreateStructureOperation) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// GetAllChecksums returns nil
func (op *CreateStructureOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// ExecuteV2 is not implemented
func (op *CreateStructureOperation) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ExecuteV2 not implemented for CreateStructureOperation")
}</span>

// ValidateV2 is not implemented
func (op *CreateStructureOperation) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ValidateV2 not implemented for CreateStructureOperation")
}</span>

// Rollback is not implemented yet
func (op *CreateStructureOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        // Would need to track all created files/dirs
        return fmt.Errorf("rollback not implemented for CreateStructureOperation")
}</span>

// ReverseOps generates reverse operations
func (op *CreateStructureOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        // Would create delete operations for all created items
        return nil, nil, fmt.Errorf("reverse ops not implemented for CreateStructureOperation")
}</span>

// Execute performs the structure creation
func (op *CreateStructureOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        writeFS, ok := fsys.(WriteFS)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support write operations")
        }</span>

        // Sort entries: directories first, then files, then symlinks
        // This ensures targets exist before symlinks are created
        <span class="cov8" title="1">sortedEntries := make([]StructureEntry, len(op.entries))
        copy(sortedEntries, op.entries)

        // Custom sort
        for i := 0; i &lt; len(sortedEntries)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(sortedEntries); j++ </span><span class="cov8" title="1">{
                        // Directories come first
                        if sortedEntries[j].IsDir &amp;&amp; !sortedEntries[i].IsDir &amp;&amp; !sortedEntries[i].IsSymlink </span><span class="cov8" title="1">{
                                sortedEntries[i], sortedEntries[j] = sortedEntries[j], sortedEntries[i]
                        }</span>
                        // Files come before symlinks
                        <span class="cov8" title="1">if !sortedEntries[j].IsSymlink &amp;&amp; sortedEntries[i].IsSymlink </span><span class="cov8" title="1">{
                                sortedEntries[i], sortedEntries[j] = sortedEntries[j], sortedEntries[i]
                        }</span>
                }
        }

        // Create entries
        <span class="cov8" title="1">for _, entry := range sortedEntries </span><span class="cov8" title="1">{
                fullPath := entry.Path
                if op.baseDir != "" &amp;&amp; op.baseDir != "." </span><span class="cov8" title="1">{
                        fullPath = filepath.Join(op.baseDir, entry.Path)
                }</span>

                <span class="cov8" title="1">if entry.IsSymlink </span><span class="cov8" title="1">{
                        // Create symlink
                        if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov8" title="1">{
                                // Ensure parent directory exists
                                parent := filepath.Dir(fullPath)
                                if parent != "." &amp;&amp; parent != "/" </span><span class="cov8" title="1">{
                                        _ = writeFS.MkdirAll(parent, 0755)
                                }</span>

                                <span class="cov8" title="1">if err := fullFS.Symlink(entry.Target, fullPath); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create symlink %s -&gt; %s: %w", fullPath, entry.Target, err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("filesystem does not support symlinks")
                        }</span>
                } else<span class="cov8" title="1"> if entry.IsDir </span><span class="cov8" title="1">{
                        // Create directory
                        if err := writeFS.MkdirAll(fullPath, entry.Mode); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", fullPath, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Create file
                        // Ensure parent directory exists
                        parent := filepath.Dir(fullPath)
                        if parent != "." &amp;&amp; parent != "/" </span><span class="cov8" title="1">{
                                _ = writeFS.MkdirAll(parent, 0755)
                        }</span>

                        // Get content if provided
                        <span class="cov8" title="1">content := entry.Content
                        // Try to find content by various path formats
                        if customContent, ok := op.fileContent[entry.Path]; ok </span><span class="cov0" title="0">{
                                content = customContent
                        }</span> else<span class="cov8" title="1"> if customContent, ok := op.fileContent[fullPath]; ok </span><span class="cov0" title="0">{
                                content = customContent
                        }</span> else<span class="cov8" title="1"> {
                                // Try relative path without the root directory
                                relPath := entry.Path
                                if idx := strings.Index(relPath, "/"); idx &gt; 0 </span><span class="cov8" title="1">{
                                        relPath = relPath[idx+1:]
                                        if customContent, ok := op.fileContent[relPath]; ok </span><span class="cov8" title="1">{
                                                content = customContent
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if err := writeFS.WriteFile(fullPath, content, entry.Mode); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create file %s: %w", fullPath, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Validate checks if the operation can be performed
func (op *CreateStructureOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        // Check if filesystem supports required operations
        if _, ok := fsys.(WriteFS); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support write operations")
        }</span>

        // Check for symlinks if needed
        <span class="cov0" title="0">hasSymlinks := false
        for _, entry := range op.entries </span><span class="cov0" title="0">{
                if entry.IsSymlink </span><span class="cov0" title="0">{
                        hasSymlinks = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if hasSymlinks </span><span class="cov0" title="0">{
                if _, ok := fsys.(FullFileSystem); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("filesystem does not support symlinks")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CreateStructure creates a directory structure from a string definition
func (s *SynthFS) CreateStructure(structure string) (Operation, error) <span class="cov8" title="1">{
        return s.NewCreateStructureOperation(structure, "")
}</span>

// CreateStructureIn creates a directory structure in a specific base directory
func (s *SynthFS) CreateStructureIn(baseDir, structure string) (Operation, error) <span class="cov8" title="1">{
        return s.NewCreateStructureOperation(structure, baseDir)
}</span>

// StructureBuilder provides a fluent interface for building directory structures
type StructureBuilder struct {
        structure   string
        baseDir     string
        fileContent map[string][]byte
}

// NewStructureBuilder creates a new structure builder
func NewStructureBuilder() *StructureBuilder <span class="cov8" title="1">{
        return &amp;StructureBuilder{
                fileContent: make(map[string][]byte),
        }
}</span>

// FromString sets the structure from a string definition
func (sb *StructureBuilder) FromString(structure string) *StructureBuilder <span class="cov8" title="1">{
        sb.structure = structure
        return sb
}</span>

// InDirectory sets the base directory
func (sb *StructureBuilder) InDirectory(dir string) *StructureBuilder <span class="cov8" title="1">{
        sb.baseDir = dir
        return sb
}</span>

// WithFile adds content for a specific file
func (sb *StructureBuilder) WithFile(path string, content []byte) *StructureBuilder <span class="cov8" title="1">{
        sb.fileContent[path] = content
        return sb
}</span>

// WithTextFile adds text content for a specific file
func (sb *StructureBuilder) WithTextFile(path string, content string) *StructureBuilder <span class="cov8" title="1">{
        return sb.WithFile(path, []byte(content))
}</span>

// Build creates the structure operation
func (sb *StructureBuilder) Build() (Operation, error) <span class="cov8" title="1">{
        op, err := New().NewCreateStructureOperation(sb.structure, sb.baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add file content
        <span class="cov8" title="1">for path, content := range sb.fileContent </span><span class="cov8" title="1">{
                op.WithFileContent(path, content)
        }</span>

        <span class="cov8" title="1">return op, nil</span>
}

// Execute builds and executes the operation
func (sb *StructureBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        op, err := sb.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return op.Execute(ctx, fs)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package synthfs

import (
        "bytes"
        "context"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// SyncOptions configures how directories are synchronized
type SyncOptions struct {
        // DeleteExtra removes files in destination that don't exist in source
        DeleteExtra bool
        // UpdateNewer only updates files if source is newer
        UpdateNewer bool
        // PreserveSymlinks copies symlinks as symlinks (not their targets)
        PreserveSymlinks bool
        // Filter determines which files to sync (return true to include)
        Filter func(path string, info fs.FileInfo) bool
        // DryRun reports what would be done without making changes
        DryRun bool
}

// SyncResult contains information about a sync operation
type SyncResult struct {
        FilesCreated    []string
        FilesUpdated    []string
        FilesDeleted    []string
        DirsCreated     []string
        DirsDeleted     []string
        SymlinksCreated []string
        Errors          []error
}

// SyncOperation synchronizes two directories
type SyncOperation struct {
        id      OperationID
        desc    OperationDesc
        srcDir  string
        dstDir  string
        options SyncOptions
        result  *SyncResult
}

// NewSyncOperation creates a new sync operation
func (s *SynthFS) NewSyncOperation(srcDir, dstDir string, opts ...SyncOptions) *SyncOperation <span class="cov8" title="1">{
        var options SyncOptions
        if len(opts) &gt; 0 </span><span class="cov8" title="1">{
                options = opts[0]
        }</span>

        // Default filter accepts everything
        <span class="cov8" title="1">if options.Filter == nil </span><span class="cov8" title="1">{
                options.Filter = func(path string, info fs.FileInfo) bool </span><span class="cov8" title="1">{ return true }</span>
        }

        <span class="cov8" title="1">id := s.idGen("sync", srcDir)
        return &amp;SyncOperation{
                id: id,
                desc: OperationDesc{
                        Type: "sync",
                        Path: srcDir,
                        Details: map[string]interface{}{
                                "src":          srcDir,
                                "dst":          dstDir,
                                "delete_extra": options.DeleteExtra,
                                "update_newer": options.UpdateNewer,
                                "dry_run":      options.DryRun,
                        },
                },
                srcDir:  srcDir,
                dstDir:  dstDir,
                options: options,
                result:  &amp;SyncResult{},
        }</span>
}

// GetResult returns the sync result after execution
func (op *SyncOperation) GetResult() *SyncResult <span class="cov8" title="1">{
        return op.result
}</span>

// ID returns the operation ID
func (op *SyncOperation) ID() OperationID <span class="cov0" title="0">{
        return op.id
}</span>

// Describe returns the operation description
func (op *SyncOperation) Describe() OperationDesc <span class="cov0" title="0">{
        return op.desc
}</span>

// Dependencies returns empty - no dependencies
func (op *SyncOperation) Dependencies() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Conflicts returns empty - no conflicts
func (op *SyncOperation) Conflicts() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Prerequisites returns prerequisites for the operation
func (op *SyncOperation) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        return []core.Prerequisite{
                core.NewSourceExistsPrerequisite(op.srcDir),
        }
}</span>

// GetItem returns nil - no specific item
func (op *SyncOperation) GetItem() FsItem <span class="cov0" title="0">{
        return nil
}</span>

// SetDescriptionDetail sets a detail in the description
func (op *SyncOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        if op.desc.Details == nil </span><span class="cov0" title="0">{
                op.desc.Details = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">op.desc.Details[key] = value</span>
}

// AddDependency adds a dependency
func (op *SyncOperation) AddDependency(depID OperationID) {<span class="cov0" title="0">
        // Not implemented for this operation
}</span>

// SetPaths sets source and destination paths
func (op *SyncOperation) SetPaths(src, dst string) <span class="cov0" title="0">{
        op.srcDir = src
        op.dstDir = dst
        op.desc.Path = src
        op.desc.Details["src"] = src
        op.desc.Details["dst"] = dst
}</span>

// GetChecksum returns nil
func (op *SyncOperation) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// GetAllChecksums returns nil
func (op *SyncOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// ExecuteV2 is not implemented
func (op *SyncOperation) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ExecuteV2 not implemented for SyncOperation")
}</span>

// ValidateV2 is not implemented
func (op *SyncOperation) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ValidateV2 not implemented for SyncOperation")
}</span>

// Rollback is not implemented yet
func (op *SyncOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        return fmt.Errorf("rollback not implemented for SyncOperation")
}</span>

// ReverseOps generates reverse operations
func (op *SyncOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        return nil, nil, fmt.Errorf("reverse ops not implemented for SyncOperation")
}</span>

// Execute performs the sync operation
func (op *SyncOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Reset result
        op.result = &amp;SyncResult{}

        // Build source file map
        srcFiles := make(map[string]fs.FileInfo)
        err := op.walkDir(fsys, op.srcDir, "", func(relPath string, info fs.FileInfo) error </span><span class="cov8" title="1">{
                if op.options.Filter(relPath, info) </span><span class="cov8" title="1">{
                        srcFiles[relPath] = info
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan source: %w", err)
        }</span>

        // Build destination file map
        <span class="cov8" title="1">dstFiles := make(map[string]fs.FileInfo)
        err = op.walkDir(fsys, op.dstDir, "", func(relPath string, info fs.FileInfo) error </span><span class="cov8" title="1">{
                dstFiles[relPath] = info
                return nil
        }</span>)
        <span class="cov8" title="1">if err != nil &amp;&amp; !isNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan destination: %w", err)
        }</span>

        // Ensure destination exists
        <span class="cov8" title="1">if !op.options.DryRun </span><span class="cov8" title="1">{
                if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                        if err := writeFS.MkdirAll(op.dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create destination: %w", err)
                        }</span>
                }
        }

        // Sync files from source to destination
        <span class="cov8" title="1">for relPath, srcInfo := range srcFiles </span><span class="cov8" title="1">{
                srcPath := filepath.Join(op.srcDir, relPath)
                dstPath := filepath.Join(op.dstDir, relPath)

                dstInfo, exists := dstFiles[relPath]

                if srcInfo.IsDir() </span><span class="cov8" title="1">{
                        // Handle directory
                        if !exists </span><span class="cov8" title="1">{
                                if !op.options.DryRun </span><span class="cov8" title="1">{
                                        if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                                                if err := writeFS.MkdirAll(dstPath, srcInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                                                        op.result.Errors = append(op.result.Errors, err)
                                                        continue</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">op.result.DirsCreated = append(op.result.DirsCreated, relPath)</span>
                        }
                } else<span class="cov8" title="1"> if srcInfo.Mode()&amp;fs.ModeSymlink != 0 &amp;&amp; op.options.PreserveSymlinks </span><span class="cov8" title="1">{
                        // Handle symlink
                        if !exists </span><span class="cov8" title="1">{
                                if !op.options.DryRun </span><span class="cov8" title="1">{
                                        if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov8" title="1">{
                                                target, err := fullFS.Readlink(srcPath)
                                                if err == nil </span><span class="cov8" title="1">{
                                                        if err := fullFS.Symlink(target, dstPath); err != nil </span><span class="cov0" title="0">{
                                                                op.result.Errors = append(op.result.Errors, err)
                                                                continue</span>
                                                        }
                                                }
                                        }
                                }
                                <span class="cov8" title="1">op.result.SymlinksCreated = append(op.result.SymlinksCreated, relPath)</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Handle regular file
                        shouldUpdate := false

                        if !exists </span><span class="cov8" title="1">{
                                shouldUpdate = true
                                op.result.FilesCreated = append(op.result.FilesCreated, relPath)
                        }</span> else<span class="cov8" title="1"> if !dstInfo.IsDir() </span><span class="cov8" title="1">{
                                if op.options.UpdateNewer </span><span class="cov8" title="1">{
                                        // Only update if source is newer
                                        if srcInfo.ModTime().After(dstInfo.ModTime()) </span><span class="cov8" title="1">{
                                                shouldUpdate = true
                                                op.result.FilesUpdated = append(op.result.FilesUpdated, relPath)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        // Always update if content differs
                                        if !op.filesEqual(fsys, srcPath, dstPath) </span><span class="cov8" title="1">{
                                                shouldUpdate = true
                                                op.result.FilesUpdated = append(op.result.FilesUpdated, relPath)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if shouldUpdate &amp;&amp; !op.options.DryRun </span><span class="cov8" title="1">{
                                // Copy file
                                content, err := fs.ReadFile(fsys, srcPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        op.result.Errors = append(op.result.Errors, err)
                                        continue</span>
                                }

                                <span class="cov8" title="1">if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                                        // Ensure parent directory exists
                                        parent := filepath.Dir(dstPath)
                                        if parent != "." &amp;&amp; parent != "/" </span><span class="cov8" title="1">{
                                                _ = writeFS.MkdirAll(parent, 0755)
                                        }</span>

                                        <span class="cov8" title="1">if err := writeFS.WriteFile(dstPath, content, srcInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                                                op.result.Errors = append(op.result.Errors, err)
                                        }</span>
                                }
                        }
                }

                // Remove from destination map (for delete detection)
                <span class="cov8" title="1">delete(dstFiles, relPath)</span>
        }

        // Handle extra files in destination
        <span class="cov8" title="1">if op.options.DeleteExtra </span><span class="cov8" title="1">{
                // Process directories first, then files
                // This ensures we count files in directories before deleting them
                var dirsToDelete []string
                deletedDirs := make(map[string]bool)

                // First pass: identify directories to delete
                for relPath, dstInfo := range dstFiles </span><span class="cov8" title="1">{
                        if dstInfo.IsDir() </span><span class="cov8" title="1">{
                                dirsToDelete = append(dirsToDelete, relPath)
                                deletedDirs[relPath] = true
                        }</span>
                }

                // Second pass: count and delete files not in deleted directories
                <span class="cov8" title="1">for relPath, dstInfo := range dstFiles </span><span class="cov8" title="1">{
                        if !dstInfo.IsDir() </span><span class="cov8" title="1">{
                                // Check if this file is inside a directory we're deleting
                                skipFile := false
                                for dirPath := range deletedDirs </span><span class="cov8" title="1">{
                                        if strings.HasPrefix(relPath, dirPath+"/") </span><span class="cov8" title="1">{
                                                skipFile = true
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">if !skipFile </span><span class="cov8" title="1">{
                                        if !op.options.DryRun </span><span class="cov8" title="1">{
                                                if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                                                        dstPath := filepath.Join(op.dstDir, relPath)
                                                        if err := writeFS.Remove(dstPath); err != nil </span><span class="cov0" title="0">{
                                                                op.result.Errors = append(op.result.Errors, err)
                                                                continue</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">op.result.FilesDeleted = append(op.result.FilesDeleted, relPath)</span>
                                } else<span class="cov8" title="1"> {
                                        // File is inside a directory being deleted, count it
                                        op.result.FilesDeleted = append(op.result.FilesDeleted, relPath)
                                }</span>
                        }
                }

                // Third pass: delete directories
                <span class="cov8" title="1">for _, relPath := range dirsToDelete </span><span class="cov8" title="1">{
                        if !op.options.DryRun </span><span class="cov8" title="1">{
                                if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                                        dstPath := filepath.Join(op.dstDir, relPath)
                                        if err := writeFS.RemoveAll(dstPath); err != nil </span><span class="cov0" title="0">{
                                                op.result.Errors = append(op.result.Errors, err)
                                                continue</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">op.result.DirsDeleted = append(op.result.DirsDeleted, relPath)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// walkDir walks a directory tree
func (op *SyncOperation) walkDir(fsys FileSystem, root, prefix string, fn func(string, fs.FileInfo) error) error <span class="cov8" title="1">{
        f, err := fsys.Open(root)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

        <span class="cov8" title="1">if dirReader, ok := f.(interface {
                ReadDir(int) ([]fs.DirEntry, error)
        }); ok </span><span class="cov8" title="1">{
                entries, err := dirReader.ReadDir(-1)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                        name := entry.Name()
                        path := filepath.Join(root, name)
                        relPath := name
                        if prefix != "" </span><span class="cov8" title="1">{
                                relPath = filepath.Join(prefix, name)
                        }</span>

                        <span class="cov8" title="1">info, err := entry.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if err := fn(relPath, info); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if entry.IsDir() </span><span class="cov8" title="1">{
                                if err := op.walkDir(fsys, path, relPath, fn); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// filesEqual checks if two files have the same content
func (op *SyncOperation) filesEqual(fsys FileSystem, path1, path2 string) bool <span class="cov8" title="1">{
        content1, err1 := fs.ReadFile(fsys, path1)
        content2, err2 := fs.ReadFile(fsys, path2)

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bytes.Equal(content1, content2)</span>
}

// Validate checks if the operation can be performed
func (op *SyncOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Check if filesystem supports required operations
        if _, ok := fsys.(WriteFS); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support write operations")
        }</span>

        // Check if source exists
        <span class="cov8" title="1">if statFS, ok := fsys.(StatFS); ok </span><span class="cov8" title="1">{
                info, err := statFS.Stat(op.srcDir)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("source directory does not exist: %w", err)
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        return fmt.Errorf("source is not a directory: %s", op.srcDir)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Sync creates a sync operation
func (s *SynthFS) Sync(srcDir, dstDir string, opts ...SyncOptions) Operation <span class="cov8" title="1">{
        return s.NewSyncOperation(srcDir, dstDir, opts...)
}</span>

// SyncDirectories is a convenience function that syncs directories directly
func SyncDirectories(ctx context.Context, fs FileSystem, srcDir, dstDir string, opts ...SyncOptions) (*SyncResult, error) <span class="cov8" title="1">{
        op := New().NewSyncOperation(srcDir, dstDir, opts...)
        err := op.Execute(ctx, fs)
        return op.GetResult(), err
}</span>

// SyncBuilder provides a fluent interface for sync operations
type SyncBuilder struct {
        srcDir  string
        dstDir  string
        options SyncOptions
}

// NewSyncBuilder creates a new sync builder
func NewSyncBuilder(srcDir, dstDir string) *SyncBuilder <span class="cov8" title="1">{
        return &amp;SyncBuilder{
                srcDir: srcDir,
                dstDir: dstDir,
                options: SyncOptions{
                        Filter: func(path string, info fs.FileInfo) bool </span><span class="cov0" title="0">{ return true }</span>,
                },
        }
}

// DeleteExtra enables deletion of extra files in destination
func (sb *SyncBuilder) DeleteExtra() *SyncBuilder <span class="cov8" title="1">{
        sb.options.DeleteExtra = true
        return sb
}</span>

// UpdateNewer only updates files if source is newer
func (sb *SyncBuilder) UpdateNewer() *SyncBuilder <span class="cov0" title="0">{
        sb.options.UpdateNewer = true
        return sb
}</span>

// PreserveSymlinks preserves symlinks as symlinks
func (sb *SyncBuilder) PreserveSymlinks() *SyncBuilder <span class="cov0" title="0">{
        sb.options.PreserveSymlinks = true
        return sb
}</span>

// WithFilter sets a filter function
func (sb *SyncBuilder) WithFilter(filter func(path string, info fs.FileInfo) bool) *SyncBuilder <span class="cov8" title="1">{
        sb.options.Filter = filter
        return sb
}</span>

// DryRun enables dry run mode
func (sb *SyncBuilder) DryRun() *SyncBuilder <span class="cov0" title="0">{
        sb.options.DryRun = true
        return sb
}</span>

// Build creates the sync operation
func (sb *SyncBuilder) Build() Operation <span class="cov8" title="1">{
        return New().NewSyncOperation(sb.srcDir, sb.dstDir, sb.options)
}</span>

// Execute builds and executes the operation
func (sb *SyncBuilder) Execute(ctx context.Context, fs FileSystem) (*SyncResult, error) <span class="cov8" title="1">{
        op := sb.Build().(*SyncOperation)
        err := op.Execute(ctx, fs)
        return op.GetResult(), err
}</span>

// isNotExist checks if an error indicates a non-existent file
func isNotExist(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check for PathError with specific error
        <span class="cov8" title="1">if pathErr, ok := err.(*fs.PathError); ok </span><span class="cov8" title="1">{
                return pathErr.Err == fs.ErrNotExist
        }</span>
        <span class="cov0" title="0">return err == fs.ErrNotExist</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package synthfs

import (
        "bytes"
        "context"
        "fmt"
        "io/fs"
        "text/template"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
)

// TemplateData holds template data for rendering
type TemplateData map[string]interface{}

// WriteTemplateOperation writes files from templates
type WriteTemplateOperation struct {
        id       OperationID
        desc     OperationDesc
        path     string
        template string
        data     TemplateData
        mode     fs.FileMode
}

// NewWriteTemplateOperation creates a new template write operation
func (s *SynthFS) NewWriteTemplateOperation(path, templateContent string, data TemplateData, mode fs.FileMode) *WriteTemplateOperation <span class="cov8" title="1">{
        id := s.idGen("write_template", path)
        return &amp;WriteTemplateOperation{
                id: id,
                desc: OperationDesc{
                        Type: "write_template",
                        Path: path,
                        Details: map[string]interface{}{
                                "template": templateContent,
                                "data":     data,
                                "mode":     mode,
                        },
                },
                path:     path,
                template: templateContent,
                data:     data,
                mode:     mode,
        }
}</span>

// ID returns the operation ID
func (op *WriteTemplateOperation) ID() OperationID <span class="cov8" title="1">{
        return op.id
}</span>

// Describe returns the operation description
func (op *WriteTemplateOperation) Describe() OperationDesc <span class="cov0" title="0">{
        return op.desc
}</span>

// Dependencies returns empty - no dependencies
func (op *WriteTemplateOperation) Dependencies() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Conflicts returns empty - no conflicts
func (op *WriteTemplateOperation) Conflicts() []OperationID <span class="cov0" title="0">{
        return nil
}</span>

// Prerequisites returns prerequisites for the operation
func (op *WriteTemplateOperation) Prerequisites() []core.Prerequisite <span class="cov0" title="0">{
        return []core.Prerequisite{
                core.NewParentDirPrerequisite(op.path),
                core.NewNoConflictPrerequisite(op.path),
        }
}</span>

// GetItem returns nil - no specific item
func (op *WriteTemplateOperation) GetItem() FsItem <span class="cov0" title="0">{
        return nil
}</span>

// SetDescriptionDetail sets a detail in the description
func (op *WriteTemplateOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov0" title="0">{
        if op.desc.Details == nil </span><span class="cov0" title="0">{
                op.desc.Details = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">op.desc.Details[key] = value</span>
}

// AddDependency adds a dependency
func (op *WriteTemplateOperation) AddDependency(depID OperationID) {<span class="cov0" title="0">
        // Not implemented for this operation
}</span>

// SetPaths sets source and destination paths
func (op *WriteTemplateOperation) SetPaths(src, dst string) <span class="cov0" title="0">{
        op.path = dst
        op.desc.Path = dst
}</span>

// GetChecksum returns nil
func (op *WriteTemplateOperation) GetChecksum(path string) *ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// GetAllChecksums returns nil
func (op *WriteTemplateOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov0" title="0">{
        return nil
}</span>

// ExecuteV2 is not implemented
func (op *WriteTemplateOperation) ExecuteV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ExecuteV2 not implemented for WriteTemplateOperation")
}</span>

// ValidateV2 is not implemented
func (op *WriteTemplateOperation) ValidateV2(ctx interface{}, execCtx *core.ExecutionContext, fsys interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("ValidateV2 not implemented for WriteTemplateOperation")
}</span>

// Rollback removes the created file
func (op *WriteTemplateOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov0" title="0">{
                return writeFS.Remove(op.path)
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("filesystem does not support Remove")</span>
}

// ReverseOps generates reverse operations
func (op *WriteTemplateOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *core.BackupBudget) ([]Operation, *core.BackupData, error) <span class="cov0" title="0">{
        // Would create a delete operation
        deleteOp := New().Delete(op.path)
        return []Operation{deleteOp}, nil, nil
}</span>

// Execute performs the template write operation
func (op *WriteTemplateOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Parse and execute template
        tmpl, err := template.New("file").Parse(op.template)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, op.data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        // Write the rendered content
        <span class="cov8" title="1">if writeFS, ok := fsys.(WriteFS); ok </span><span class="cov8" title="1">{
                return writeFS.WriteFile(op.path, buf.Bytes(), op.mode)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("filesystem does not support WriteFile")</span>
}

// Validate checks if the operation can be performed
func (op *WriteTemplateOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov8" title="1">{
        // Validate template syntax
        if _, err := template.New("validate").Parse(op.template); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid template syntax: %w", err)
        }</span>

        // Check if filesystem supports write
        <span class="cov8" title="1">if _, ok := fsys.(WriteFS); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support WriteFile")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteTemplate creates a template write operation
func (s *SynthFS) WriteTemplate(path, templateContent string, data TemplateData) Operation <span class="cov8" title="1">{
        return s.NewWriteTemplateOperation(path, templateContent, data, 0644)
}</span>

// WriteTemplateWithMode creates a template write operation with custom mode
func (s *SynthFS) WriteTemplateWithMode(path, templateContent string, data TemplateData, mode fs.FileMode) Operation <span class="cov0" title="0">{
        return s.NewWriteTemplateOperation(path, templateContent, data, mode)
}</span>

// WriteTemplateFile is a convenience function that writes a template directly
func WriteTemplateFile(ctx context.Context, fs FileSystem, path, templateContent string, data TemplateData) error <span class="cov8" title="1">{
        op := New().WriteTemplate(path, templateContent, data)
        return op.Execute(ctx, fs)
}</span>

// TemplateBuilder provides a fluent interface for template operations
type TemplateBuilder struct {
        path     string
        template string
        data     TemplateData
        mode     fs.FileMode
}

// NewTemplateBuilder creates a new template builder
func NewTemplateBuilder(path string) *TemplateBuilder <span class="cov8" title="1">{
        return &amp;TemplateBuilder{
                path: path,
                data: make(TemplateData),
                mode: 0644,
        }
}</span>

// WithTemplate sets the template content
func (tb *TemplateBuilder) WithTemplate(template string) *TemplateBuilder <span class="cov8" title="1">{
        tb.template = template
        return tb
}</span>

// WithData sets all template data at once
func (tb *TemplateBuilder) WithData(data TemplateData) *TemplateBuilder <span class="cov0" title="0">{
        tb.data = data
        return tb
}</span>

// Set adds a single key-value pair to the template data
func (tb *TemplateBuilder) Set(key string, value interface{}) *TemplateBuilder <span class="cov8" title="1">{
        tb.data[key] = value
        return tb
}</span>

// WithMode sets the file mode
func (tb *TemplateBuilder) WithMode(mode fs.FileMode) *TemplateBuilder <span class="cov8" title="1">{
        tb.mode = mode
        return tb
}</span>

// Build creates the write template operation
func (tb *TemplateBuilder) Build() Operation <span class="cov8" title="1">{
        return New().NewWriteTemplateOperation(tb.path, tb.template, tb.data, tb.mode)
}</span>

// Execute builds and executes the operation
func (tb *TemplateBuilder) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        op := tb.Build()
        return op.Execute(ctx, fs)
}</span>

// BatchTemplateWriter helps write multiple templates
type BatchTemplateWriter struct {
        templates map[string]struct {
                template string
                data     TemplateData
                mode     fs.FileMode
        }
}

// NewBatchTemplateWriter creates a new batch template writer
func NewBatchTemplateWriter() *BatchTemplateWriter <span class="cov8" title="1">{
        return &amp;BatchTemplateWriter{
                templates: make(map[string]struct {
                        template string
                        data     TemplateData
                        mode     fs.FileMode
                }),
        }
}</span>

// Add adds a template to the batch
func (btw *BatchTemplateWriter) Add(path, template string, data TemplateData) *BatchTemplateWriter <span class="cov8" title="1">{
        btw.templates[path] = struct {
                template string
                data     TemplateData
                mode     fs.FileMode
        }{
                template: template,
                data:     data,
                mode:     0644,
        }
        return btw
}</span>

// AddWithMode adds a template with custom mode
func (btw *BatchTemplateWriter) AddWithMode(path, template string, data TemplateData, mode fs.FileMode) *BatchTemplateWriter <span class="cov8" title="1">{
        btw.templates[path] = struct {
                template string
                data     TemplateData
                mode     fs.FileMode
        }{
                template: template,
                data:     data,
                mode:     mode,
        }
        return btw
}</span>

// BuildOperations creates all template operations
func (btw *BatchTemplateWriter) BuildOperations() []Operation <span class="cov8" title="1">{
        sfs := New()
        var ops []Operation
        for path, tmpl := range btw.templates </span><span class="cov8" title="1">{
                op := sfs.NewWriteTemplateOperation(path, tmpl.template, tmpl.data, tmpl.mode)
                ops = append(ops, op)
        }</span>
        <span class="cov8" title="1">return ops</span>
}

// Execute writes all templates
func (btw *BatchTemplateWriter) Execute(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        ops := btw.BuildOperations()
        result, err := Run(ctx, fs, ops...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !result.IsSuccess() </span><span class="cov0" title="0">{
                return fmt.Errorf("batch template write failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package synthfs

import (
        "context"

        "github.com/arthur-debert/synthfs/pkg/synthfs/execution"
)

// Pipeline defines an interface for managing a sequence of operations.
type Pipeline interface {
        // Add appends one or more operations to the pipeline.
        // It may return an error, for example, if an operation with a duplicate ID
        // is added.
        Add(ops ...Operation) error

        // Operations returns all operations currently in the pipeline.
        // After Resolve() is called, this returns operations in dependency-resolved order.
        Operations() []Operation

        // Resolve performs dependency resolution using topological sorting.
        // This must be called before execution to ensure operations are in correct order.
        // Returns error if circular dependencies are detected.
        Resolve() error

        // Validate checks if all operations in the pipeline are valid.
        // This includes validating individual operations and checking for dependency conflicts.
        Validate(ctx context.Context, fs FileSystem) error
}

// NewMemPipeline creates a new in-memory operation pipeline.
func NewMemPipeline() Pipeline <span class="cov8" title="1">{
        logger := DefaultLogger()
        return &amp;pipelineAdapter{
                pipeline: execution.NewMemPipeline(NewLoggerAdapter(&amp;logger)),
        }
}</span>

// pipelineAdapter adapts execution.Pipeline to our Pipeline interface
type pipelineAdapter struct {
        pipeline execution.Pipeline
}

// Add appends operations to the pipeline.
func (pa *pipelineAdapter) Add(ops ...Operation) error <span class="cov8" title="1">{
        // Convert Operation to operationWrapper for execution package
        var opsInterface []interface{}
        for _, op := range ops </span><span class="cov8" title="1">{
                wrapper := &amp;operationWrapper{op: op}
                opsInterface = append(opsInterface, wrapper)
        }</span>
        <span class="cov8" title="1">return pa.pipeline.Add(opsInterface...)</span>
}

// Operations returns all operations currently in the pipeline.
func (pa *pipelineAdapter) Operations() []Operation <span class="cov8" title="1">{
        // Convert from interface{} back to Operation
        opsInterface := pa.pipeline.Operations()
        var ops []Operation
        for _, opInterface := range opsInterface </span><span class="cov8" title="1">{
                if wrapper, ok := opInterface.(*operationWrapper); ok </span><span class="cov8" title="1">{
                        ops = append(ops, wrapper.op)
                }</span> else<span class="cov0" title="0"> if op, ok := opInterface.(Operation); ok </span><span class="cov0" title="0">{
                        ops = append(ops, op)
                }</span>
        }
        <span class="cov8" title="1">return ops</span>
}

// Resolve performs dependency resolution using topological sorting.
func (pa *pipelineAdapter) Resolve() error <span class="cov8" title="1">{
        return pa.pipeline.Resolve()
}</span>

// Validate checks if all operations in the pipeline are valid.
func (pa *pipelineAdapter) Validate(ctx context.Context, fs FileSystem) error <span class="cov8" title="1">{
        // The execution package expects a context and filesystem interface
        // We need to handle error conversion for ValidationError
        err := pa.pipeline.Validate(ctx, fs)
        if err != nil </span><span class="cov0" title="0">{
                // Check if we can recover the operation from the error message
                // For now, return the error as-is
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package synthfs

import (
        "context"
)

// PipelineBuilder provides a fluent API for building and executing pipelines
type PipelineBuilder struct {
        pipeline     Pipeline
        dependencies map[OperationID][]OperationID
        lastOp       Operation
}

// BuildPipeline creates a new pipeline with the given operations
func BuildPipeline(ops ...Operation) *PipelineBuilder <span class="cov8" title="1">{
        pb := &amp;PipelineBuilder{
                pipeline:     NewMemPipeline(),
                dependencies: make(map[OperationID][]OperationID),
        }

        // Track operations that create paths
        pathCreators := make(map[string]Operation)

        for _, op := range ops </span><span class="cov8" title="1">{
                // Auto-detect dependencies based on paths
                if adapter, ok := op.(*OperationsPackageAdapter); ok </span><span class="cov8" title="1">{
                        srcPath, dstPath := adapter.opsOperation.GetPaths()
                        desc := adapter.opsOperation.Describe()
                        opType := desc.Type

                        // For operations that read from a source, check if source was created by a previous op
                        if srcPath != "" &amp;&amp; (opType == "copy" || opType == "move") </span><span class="cov8" title="1">{
                                if creator, exists := pathCreators[srcPath]; exists </span><span class="cov0" title="0">{
                                        op.AddDependency(creator.ID())
                                }</span>
                        }

                        // Track paths this operation creates
                        <span class="cov8" title="1">if dstPath != "" </span><span class="cov8" title="1">{
                                pathCreators[dstPath] = op
                        }</span> else<span class="cov8" title="1"> if srcPath != "" &amp;&amp; (opType == "create_file" ||
                                opType == "create_directory" ||
                                opType == "create_symlink") </span><span class="cov0" title="0">{
                                pathCreators[srcPath] = op
                        }</span>
                }

                <span class="cov8" title="1">if err := pb.pipeline.Add(op); err == nil </span><span class="cov8" title="1">{
                        pb.lastOp = op
                }</span>
        }

        <span class="cov8" title="1">return pb</span>
}

// NewPipelineBuilder creates a new empty pipeline builder
func NewPipelineBuilder() *PipelineBuilder <span class="cov8" title="1">{
        return &amp;PipelineBuilder{
                pipeline:     NewMemPipeline(),
                dependencies: make(map[OperationID][]OperationID),
        }
}</span>

// Add adds an operation to the pipeline
func (pb *PipelineBuilder) Add(op Operation) *PipelineBuilder <span class="cov8" title="1">{
        if err := pb.pipeline.Add(op); err == nil </span><span class="cov8" title="1">{
                pb.lastOp = op
        }</span>
        <span class="cov8" title="1">return pb</span>
}

// After specifies that the last added operation depends on the given operations
func (pb *PipelineBuilder) After(deps ...Operation) *PipelineBuilder <span class="cov8" title="1">{
        if pb.lastOp != nil </span><span class="cov8" title="1">{
                for _, dep := range deps </span><span class="cov8" title="1">{
                        pb.lastOp.AddDependency(dep.ID())
                }</span>
        }
        <span class="cov8" title="1">return pb</span>
}

// WithDependency adds a dependency between two operations
func (pb *PipelineBuilder) WithDependency(dependent, dependency Operation) *PipelineBuilder <span class="cov8" title="1">{
        dependent.AddDependency(dependency.ID())
        return pb
}</span>

// Build returns the built pipeline
func (pb *PipelineBuilder) Build() Pipeline <span class="cov0" title="0">{
        return pb.pipeline
}</span>

// Execute runs the pipeline with the given context and filesystem
func (pb *PipelineBuilder) Execute(ctx context.Context, fs FileSystem) (*Result, error) <span class="cov8" title="1">{
        // For BuildPipeline, use sequential execution like simple_api to handle dependencies
        // The pipeline/executor approach validates all operations upfront which fails for
        // operations that depend on files created by previous operations
        ops := pb.pipeline.Operations()
        return RunWithOptions(ctx, fs, DefaultPipelineOptions(), ops...)
}</span>

// ExecuteWith runs the pipeline with a custom executor
func (pb *PipelineBuilder) ExecuteWith(ctx context.Context, fs FileSystem, executor *Executor) (*Result, error) <span class="cov8" title="1">{
        result := executor.Run(ctx, pb.pipeline, fs)

        // Check for errors (same as Execute)
        for i, opResult := range result.GetOperations() </span><span class="cov8" title="1">{
                if opRes, ok := opResult.(OperationResult); ok &amp;&amp; opRes.Error != nil </span><span class="cov0" title="0">{
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if prevRes, ok := result.GetOperations()[j].(OperationResult); ok &amp;&amp; prevRes.Error == nil </span><span class="cov0" title="0">{
                                        successfulOps = append(successfulOps, prevRes.OperationID)
                                }</span>
                        }

                        <span class="cov0" title="0">ops := pb.pipeline.Operations()
                        if i &lt; len(ops) </span><span class="cov0" title="0">{
                                return result, &amp;PipelineError{
                                        FailedOp:      ops[i],
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           opRes.Error,
                                        SuccessfulOps: successfulOps,
                                }
                        }</span>
                        <span class="cov0" title="0">return result, opRes.Error</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// WithOptions sets pipeline options and executes
func (pb *PipelineBuilder) WithOptions(options PipelineOptions) *PipelineExecutor <span class="cov8" title="1">{
        return &amp;PipelineExecutor{
                pipeline: pb.pipeline,
                options:  options,
        }
}</span>

// PipelineExecutor handles execution with options
type PipelineExecutor struct {
        pipeline Pipeline
        options  PipelineOptions
}

// Execute runs the pipeline with the configured options
func (pe *PipelineExecutor) Execute(ctx context.Context, fs FileSystem) (*Result, error) <span class="cov8" title="1">{
        executor := NewExecutor()
        result := executor.RunWithOptions(ctx, pe.pipeline, fs, pe.options)

        // Check for errors
        for i, opResult := range result.GetOperations() </span><span class="cov8" title="1">{
                if opRes, ok := opResult.(OperationResult); ok &amp;&amp; opRes.Error != nil </span><span class="cov0" title="0">{
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if prevRes, ok := result.GetOperations()[j].(OperationResult); ok &amp;&amp; prevRes.Error == nil </span><span class="cov0" title="0">{
                                        successfulOps = append(successfulOps, prevRes.OperationID)
                                }</span>
                        }

                        <span class="cov0" title="0">ops := pe.pipeline.Operations()
                        if i &lt; len(ops) </span><span class="cov0" title="0">{
                                return result, &amp;PipelineError{
                                        FailedOp:      ops[i],
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           opRes.Error,
                                        SuccessfulOps: successfulOps,
                                }
                        }</span>
                        <span class="cov0" title="0">return result, opRes.Error</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package synthfs

import (
        "context"
)

// ExecutablePipeline extends Pipeline with execution capabilities
type ExecutablePipeline interface {
        Pipeline
        Execute(ctx context.Context, fs FileSystem) (*Result, error)
        ExecuteWith(ctx context.Context, fs FileSystem, executor *Executor) (*Result, error)
}

// executablePipeline wraps a Pipeline to add execution methods
type executablePipeline struct {
        Pipeline
}

// NewExecutablePipeline creates a pipeline with execution capabilities
func NewExecutablePipeline() ExecutablePipeline <span class="cov0" title="0">{
        return &amp;executablePipeline{
                Pipeline: NewMemPipeline(),
        }
}</span>

// Execute runs the pipeline with a default executor
func (ep *executablePipeline) Execute(ctx context.Context, fs FileSystem) (*Result, error) <span class="cov0" title="0">{
        executor := NewExecutor()
        result := executor.Run(ctx, ep, fs)

        // Enhanced error handling
        ops := ep.Operations()
        for i, opResult := range result.GetOperations() </span><span class="cov0" title="0">{
                if opRes, ok := opResult.(OperationResult); ok &amp;&amp; opRes.Error != nil </span><span class="cov0" title="0">{
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if prevRes, ok := result.GetOperations()[j].(OperationResult); ok &amp;&amp; prevRes.Error == nil </span><span class="cov0" title="0">{
                                        successfulOps = append(successfulOps, prevRes.OperationID)
                                }</span>
                        }

                        <span class="cov0" title="0">if i &lt; len(ops) </span><span class="cov0" title="0">{
                                return result, &amp;PipelineError{
                                        FailedOp:      ops[i],
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           opRes.Error,
                                        SuccessfulOps: successfulOps,
                                }
                        }</span>
                        <span class="cov0" title="0">return result, opRes.Error</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ExecuteWith runs the pipeline with a custom executor
func (ep *executablePipeline) ExecuteWith(ctx context.Context, fs FileSystem, executor *Executor) (*Result, error) <span class="cov0" title="0">{
        result := executor.Run(ctx, ep, fs)

        // Same error handling as Execute
        ops := ep.Operations()
        for i, opResult := range result.GetOperations() </span><span class="cov0" title="0">{
                if opRes, ok := opResult.(OperationResult); ok &amp;&amp; opRes.Error != nil </span><span class="cov0" title="0">{
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if prevRes, ok := result.GetOperations()[j].(OperationResult); ok &amp;&amp; prevRes.Error == nil </span><span class="cov0" title="0">{
                                        successfulOps = append(successfulOps, prevRes.OperationID)
                                }</span>
                        }

                        <span class="cov0" title="0">if i &lt; len(ops) </span><span class="cov0" title="0">{
                                return result, &amp;PipelineError{
                                        FailedOp:      ops[i],
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           opRes.Error,
                                        SuccessfulOps: successfulOps,
                                }
                        }</span>
                        <span class="cov0" title="0">return result, opRes.Error</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package synthfs

import (
        "fmt"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
        "github.com/arthur-debert/synthfs/pkg/synthfs/operations"
)

// OperationRegistry implements the core.OperationFactory interface
type OperationRegistry struct {
        operationsFactory *operations.Factory
}

// NewOperationRegistry creates a new operation registry
func NewOperationRegistry() *OperationRegistry <span class="cov8" title="1">{
        return &amp;OperationRegistry{
                operationsFactory: operations.NewFactory(),
        }
}</span>

// CreateOperation creates an operation based on type and path
func (r *OperationRegistry) CreateOperation(id core.OperationID, opType string, path string) (interface{}, error) <span class="cov8" title="1">{
        // Always use the operations package
        opsOp, err := r.operationsFactory.CreateOperation(id, opType, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Wrap in adapter to implement main package Operation interface
        <span class="cov8" title="1">return NewOperationsPackageAdapter(opsOp), nil</span>
}

// SetItemForOperation sets the item for an operation
func (r *OperationRegistry) SetItemForOperation(op interface{}, item interface{}) error <span class="cov8" title="1">{
        // Check if it's an adapter
        if adapter, ok := op.(*OperationsPackageAdapter); ok </span><span class="cov8" title="1">{
                adapter.opsOperation.SetItem(item)
                return nil
        }</span>

        // Handle operations package operation directly
        <span class="cov0" title="0">if opsOp, ok := op.(operations.Operation); ok </span><span class="cov0" title="0">{
                return r.operationsFactory.SetItemForOperation(opsOp, item)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("operation is not an OperationsPackageAdapter or operations.Operation")</span>
}

// Global registry instance
var defaultRegistry = NewOperationRegistry()

// GetDefaultRegistry returns the default operation registry
func GetDefaultRegistry() core.OperationFactory <span class="cov0" title="0">{
        return defaultRegistry
}</span>

// RegisterFactory implements the OperationRegistrar interface
func (r *OperationRegistry) RegisterFactory(factory core.OperationFactory) {<span class="cov0" title="0">
        // For now, we don't need to do anything as we have a single factory
        // In the future, this could maintain a map of operation types to factories
}</span>

// init function to initialize the operations package
func init() <span class="cov8" title="1">{
        operations.Initialize(defaultRegistry)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package synthfs

import (
        "context"
        "time"
)

// Run executes a series of operations in sequence.
//
// Operations are executed in the order provided, with each operation's success required
// before proceeding. If an operation fails, subsequent operations are not executed.
// This function does not perform rollback of successful operations.
//
// Example - Simple sequential operations:
//
//        fs := synthfs.NewOSFileSystem("/tmp")
//        sfs := synthfs.New()
//        
//        result, err := synthfs.Run(ctx, fs,
//                sfs.CreateDir("project", 0755),
//                sfs.CreateFile("project/README.md", []byte("# Project"), 0644),
//                sfs.CreateFile("project/main.go", []byte("package main"), 0644),
//        )
//        
//        if err != nil {
//                log.Fatal(err)
//        }
//        log.Printf("Executed %d operations in %v", len(result.Operations), result.Duration)
//
// Example - Operations with dependencies:
//
//        result, err := synthfs.Run(ctx, fs,
//                sfs.CreateDir("data", 0755),                    // Must happen first
//                sfs.CreateFile("data/config.json", data, 0644), // Depends on directory existing
//                sfs.Copy("data/config.json", "backup.json"),    // Depends on file existing
//        )
//
// For complex dependency management, consider using BuildPipeline instead.
func Run(ctx context.Context, fs FileSystem, ops ...Operation) (*Result, error) <span class="cov8" title="1">{
        return RunWithOptions(ctx, fs, DefaultPipelineOptions(), ops...)
}</span>

// RunWithOptions executes operations with custom options.
// Note: This simplified runner does not currently support all pipeline options (e.g., DryRun).
// It executes operations sequentially and does not perform a pre-validation step for the entire pipeline.
func RunWithOptions(ctx context.Context, fs FileSystem, options PipelineOptions, ops ...Operation) (*Result, error) <span class="cov8" title="1">{
        if len(ops) == 0 </span><span class="cov8" title="1">{
                return &amp;Result{
                        success:    true,
                        operations: []interface{}{},
                        duration:   0,
                }, nil
        }</span>

        // For simple API, execute operations sequentially without pipeline validation
        // This allows operations like Copy to work when the source is created by a previous operation
        <span class="cov8" title="1">results := make([]interface{}, 0, len(ops))
        startTime := time.Now()

        for i, op := range ops </span><span class="cov8" title="1">{
                // Validate before execute
                if err := op.Validate(ctx, fs); err != nil </span><span class="cov8" title="1">{
                        // Create failed operation result
                        opResult := OperationResult{
                                OperationID: op.ID(),
                                Operation:   op,
                                Status:      StatusValidation,
                                Error:       err,
                                Duration:    0,
                        }

                        // Get successful operations
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                if res, ok := results[j].(OperationResult); ok &amp;&amp; res.Error == nil </span><span class="cov8" title="1">{
                                        successfulOps = append(successfulOps, res.OperationID)
                                }</span>
                        }

                        // Return partial result with error
                        <span class="cov8" title="1">return &amp;Result{
                                        success:    false,
                                        operations: append(results, opResult),
                                        duration:   time.Since(startTime),
                                        err:        err,
                                }, &amp;PipelineError{
                                        FailedOp:      op,
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           err,
                                        SuccessfulOps: successfulOps,
                                }</span>
                }

                // Execute operation
                <span class="cov8" title="1">startOpTime := time.Now()
                err := op.Execute(ctx, fs)
                duration := time.Since(startOpTime)

                // Create operation result
                opResult := OperationResult{
                        OperationID: op.ID(),
                        Operation:   op,
                        Status:      StatusSuccess,
                        Error:       err,
                        Duration:    duration,
                }

                if err != nil </span><span class="cov0" title="0">{
                        opResult.Status = StatusFailure

                        // Get successful operations
                        var successfulOps []OperationID
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                if res, ok := results[j].(OperationResult); ok &amp;&amp; res.Error == nil </span><span class="cov0" title="0">{
                                        successfulOps = append(successfulOps, res.OperationID)
                                }</span>
                        }

                        // Return partial result with error
                        <span class="cov0" title="0">return &amp;Result{
                                        success:    false,
                                        operations: append(results, opResult),
                                        duration:   time.Since(startTime),
                                        err:        err,
                                }, &amp;PipelineError{
                                        FailedOp:      op,
                                        FailedIndex:   i + 1,
                                        TotalOps:      len(ops),
                                        Err:           err,
                                        SuccessfulOps: successfulOps,
                                }</span>
                }

                <span class="cov8" title="1">results = append(results, opResult)</span>
        }

        <span class="cov8" title="1">return &amp;Result{
                success:    true,
                operations: results,
                duration:   time.Since(startTime),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package synthfs

import (
        "context"
        "io/fs"

        "github.com/arthur-debert/synthfs/pkg/synthfs/filesystem"
)

// SimpleBatch provides a fluent API for building and executing multiple operations.
//
// This is a convenience wrapper that doesn't require a registry and provides method
// chaining for readable operation sequences. Operations are executed in the order
// they were added, with automatic dependency resolution.
//
// Example usage:
//
//        fs := synthfs.NewOSFileSystem("/tmp")
//        batch := synthfs.NewSimpleBatch(fs)
//        
//        err := batch.
//                CreateDir("project", 0755).
//                CreateDir("project/src", 0755).
//                WriteFile("project/README.md", []byte("# My Project"), 0644).
//                WriteFile("project/src/main.go", []byte("package main"), 0644).
//                Copy("template.conf", "project/config.conf").
//                Execute(ctx)
//        
//        if err != nil {
//                log.Fatal(err)
//        }
//
// For operations requiring rollback capability:
//
//        result, err := batch.ExecuteWithRollback(ctx)
//        if err != nil &amp;&amp; result.Rollback != nil {
//                rollbackErr := result.Rollback(ctx)
//                if rollbackErr != nil {
//                        log.Printf("Rollback failed: %v", rollbackErr)
//                }
//        }
type SimpleBatch struct {
        fs         filesystem.FileSystem
        operations []Operation
        ctx        context.Context
}

// NewSimpleBatch creates a new simple batch for the given filesystem
func NewSimpleBatch(fs filesystem.FileSystem) *SimpleBatch <span class="cov8" title="1">{
        return &amp;SimpleBatch{
                fs:         fs,
                operations: []Operation{},
                ctx:        context.Background(),
        }
}</span>

// WithContext sets the context for batch execution
func (sb *SimpleBatch) WithContext(ctx context.Context) *SimpleBatch <span class="cov8" title="1">{
        sb.ctx = ctx
        return sb
}</span>

// CreateDir adds a directory creation operation to the batch
func (sb *SimpleBatch) CreateDir(path string, mode fs.FileMode) *SimpleBatch <span class="cov8" title="1">{
        op := New().CreateDir(path, mode)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// WriteFile adds a file write operation to the batch
func (sb *SimpleBatch) WriteFile(path string, content []byte, mode fs.FileMode) *SimpleBatch <span class="cov8" title="1">{
        op := New().CreateFile(path, content, mode)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// Copy adds a copy operation to the batch
func (sb *SimpleBatch) Copy(src, dst string) *SimpleBatch <span class="cov8" title="1">{
        op := New().Copy(src, dst)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// Move adds a move operation to the batch
func (sb *SimpleBatch) Move(src, dst string) *SimpleBatch <span class="cov8" title="1">{
        op := New().Move(src, dst)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// Delete adds a delete operation to the batch
func (sb *SimpleBatch) Delete(path string) *SimpleBatch <span class="cov8" title="1">{
        op := New().Delete(path)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// CreateSymlink adds a symlink creation operation to the batch
func (sb *SimpleBatch) CreateSymlink(target, linkPath string) *SimpleBatch <span class="cov8" title="1">{
        op := New().CreateSymlink(target, linkPath)
        sb.operations = append(sb.operations, op)
        return sb
}</span>

// Execute runs all operations in the batch
func (sb *SimpleBatch) Execute() error <span class="cov8" title="1">{
        _, err := Run(sb.ctx, sb.fs, sb.operations...)
        return err
}</span>

// ExecuteWithRollback runs all operations and attempts rollback on failure
func (sb *SimpleBatch) ExecuteWithRollback() error <span class="cov8" title="1">{
        result, err := Run(sb.ctx, sb.fs, sb.operations...)
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Determine which operations succeeded
        <span class="cov8" title="1">var successfulOps []Operation
        if result != nil </span><span class="cov8" title="1">{
                for i, opResult := range result.GetOperations() </span><span class="cov8" title="1">{
                        if opRes, ok := opResult.(OperationResult); ok &amp;&amp; opRes.Error == nil </span><span class="cov8" title="1">{
                                if i &lt; len(sb.operations) </span><span class="cov8" title="1">{
                                        successfulOps = append(successfulOps, sb.operations[i])
                                }</span>
                        }
                }
        }

        // Attempt rollback of successful operations only
        <span class="cov8" title="1">rollbackErrs := make(map[OperationID]error)

        // Roll back successful operations in reverse order
        for i := len(successfulOps) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                op := successfulOps[i]
                if rollbackErr := op.Rollback(sb.ctx, sb.fs); rollbackErr != nil </span><span class="cov0" title="0">{
                        // Store rollback errors but continue trying
                        rollbackErrs[op.ID()] = rollbackErr
                }</span>
        }

        <span class="cov8" title="1">if len(rollbackErrs) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;RollbackError{
                        OriginalErr:  err,
                        RollbackErrs: rollbackErrs,
                }
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Operations returns the list of operations in the batch
func (sb *SimpleBatch) Operations() []Operation <span class="cov8" title="1">{
        return sb.operations
}</span>

// Clear removes all operations from the batch
func (sb *SimpleBatch) Clear() *SimpleBatch <span class="cov8" title="1">{
        sb.operations = []Operation{}
        return sb
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package synthfs

import (
        "github.com/arthur-debert/synthfs/pkg/synthfs/execution"
)

// PathState is a type alias for execution.PathState
type PathState = execution.PathState

// PathStateTracker is a wrapper around execution.PathStateTracker
type PathStateTracker struct {
        tracker *execution.PathStateTracker
}

// NewPathStateTracker creates a new tracker.
func NewPathStateTracker(fs FullFileSystem) *PathStateTracker <span class="cov0" title="0">{
        return &amp;PathStateTracker{
                tracker: execution.NewPathStateTracker(fs),
        }
}</span>

// GetState returns the projected state of a path.
func (pst *PathStateTracker) GetState(path string) (*PathState, error) <span class="cov0" title="0">{
        return pst.tracker.GetState(path)
}</span>

// UpdateState applies the effect of an operation to the projected state of a path.
func (pst *PathStateTracker) UpdateState(op Operation) error <span class="cov0" title="0">{
        // Create a wrapper that implements execution.OperationInterface
        wrapper := &amp;operationWrapper{op: op}
        return pst.tracker.UpdateState(wrapper)
}</span>

// IsDeleted returns true if the path is scheduled for deletion by any operation.
func (pst *PathStateTracker) IsDeleted(path string) bool <span class="cov0" title="0">{
        return pst.tracker.IsDeleted(path)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package synthfs

import (
        "io/fs"

        "github.com/arthur-debert/synthfs/pkg/synthfs/core"
        "github.com/arthur-debert/synthfs/pkg/synthfs/operations"
        "github.com/arthur-debert/synthfs/pkg/synthfs/targets"
)

// SynthFS provides a simplified interface for creating and executing filesystem operations.
type SynthFS struct {
        idGen IDGenerator
}

// New creates a new SynthFS instance with the default ID generator.
func New() *SynthFS <span class="cov8" title="1">{
        return &amp;SynthFS{
                idGen: HashIDGenerator,
        }
}</span>

// WithIDGenerator creates a new SynthFS instance with a custom ID generator.
func WithIDGenerator(gen IDGenerator) *SynthFS <span class="cov8" title="1">{
        return &amp;SynthFS{
                idGen: gen,
        }
}</span>

// CreateFile creates a file creation operation with an auto-generated ID.
func (s *SynthFS) CreateFile(path string, content []byte, mode fs.FileMode) Operation <span class="cov8" title="1">{
        id := s.idGen("create_file", path)
        op := operations.NewCreateFileOperation(id, path)
        item := targets.NewFile(path).WithContent(content).WithMode(mode)
        op.SetItem(item)
        return NewOperationsPackageAdapter(op)
}</span>

// CreateDir creates a directory creation operation with an auto-generated ID.
func (s *SynthFS) CreateDir(path string, mode fs.FileMode) Operation <span class="cov8" title="1">{
        id := s.idGen("create_directory", path)
        op := operations.NewCreateDirectoryOperation(id, path)
        item := targets.NewDirectory(path).WithMode(mode)
        op.SetItem(item)
        return NewOperationsPackageAdapter(op)
}</span>

// Delete creates a delete operation with an auto-generated ID.
func (s *SynthFS) Delete(path string) Operation <span class="cov8" title="1">{
        id := s.idGen("delete", path)
        return NewOperationsPackageAdapter(operations.NewDeleteOperation(id, path))
}</span>

// Copy creates a copy operation with an auto-generated ID.
func (s *SynthFS) Copy(src, dst string) Operation <span class="cov8" title="1">{
        id := s.idGen("copy", src)
        op := operations.NewCopyOperation(id, src)
        op.SetPaths(src, dst)
        return NewOperationsPackageAdapter(op)
}</span>

// Move creates a move operation with an auto-generated ID.
func (s *SynthFS) Move(src, dst string) Operation <span class="cov8" title="1">{
        id := s.idGen("move", src)
        op := operations.NewMoveOperation(id, src)
        op.SetPaths(src, dst)
        return NewOperationsPackageAdapter(op)
}</span>

// CreateSymlink creates a symlink operation with an auto-generated ID.
func (s *SynthFS) CreateSymlink(target, linkPath string) Operation <span class="cov8" title="1">{
        id := s.idGen("create_symlink", linkPath)
        op := operations.NewCreateSymlinkOperation(id, linkPath)
        item := targets.NewSymlink(linkPath, target)
        op.SetItem(item)
        op.SetDescriptionDetail("target", target)
        return NewOperationsPackageAdapter(op)
}</span>

// CreateFileWithID creates a file creation operation with an explicit ID.
func (s *SynthFS) CreateFileWithID(id string, path string, content []byte, mode fs.FileMode) Operation <span class="cov0" title="0">{
        op := operations.NewCreateFileOperation(core.OperationID(id), path)
        item := targets.NewFile(path).WithContent(content).WithMode(mode)
        op.SetItem(item)
        return NewOperationsPackageAdapter(op)
}</span>

// CreateDirWithID creates a directory creation operation with an explicit ID.
func (s *SynthFS) CreateDirWithID(id string, path string, mode fs.FileMode) Operation <span class="cov0" title="0">{
        op := operations.NewCreateDirectoryOperation(core.OperationID(id), path)
        item := targets.NewDirectory(path).WithMode(mode)
        op.SetItem(item)
        return NewOperationsPackageAdapter(op)
}</span>

// DeleteWithID creates a delete operation with an explicit ID.
func (s *SynthFS) DeleteWithID(id string, path string) Operation <span class="cov0" title="0">{
        return NewOperationsPackageAdapter(operations.NewDeleteOperation(core.OperationID(id), path))
}</span>

// CopyWithID creates a copy operation with an explicit ID.
func (s *SynthFS) CopyWithID(id string, src, dst string) Operation <span class="cov0" title="0">{
        op := operations.NewCopyOperation(core.OperationID(id), src)
        op.SetPaths(src, dst)
        return NewOperationsPackageAdapter(op)
}</span>

// MoveWithID creates a move operation with an explicit ID.
func (s *SynthFS) MoveWithID(id string, src, dst string) Operation <span class="cov0" title="0">{
        op := operations.NewMoveOperation(core.OperationID(id), src)
        op.SetPaths(src, dst)
        return NewOperationsPackageAdapter(op)
}</span>

// CreateSymlinkWithID creates a symlink operation with an explicit ID.
func (s *SynthFS) CreateSymlinkWithID(id string, target, linkPath string) Operation <span class="cov0" title="0">{
        op := operations.NewCreateSymlinkOperation(core.OperationID(id), linkPath)
        item := targets.NewSymlink(linkPath, target)
        op.SetItem(item)
        op.SetDescriptionDetail("target", target)
        return NewOperationsPackageAdapter(op)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
