The code base has a bad design with too much coupling, god interfaces and poor division of responsibility.

The dependency analysis reveals that the codebase has evolved into a tightly coupled system centered around the Operation interface, which has
become a "god interface" that violates the Single Responsibility Principle. This is indeed a code smell.

The main issues are:

1. The Operation interface is too broad - combining execution logic, data access, metadata, and advanced features
2. Central hub architecture - everything connects through Operation
3. Type definitions in the wrong place - all core types in the main package
4. Feature envy - each component needs features from other components

This tight coupling makes it impossible to extract operations or execution into separate packages without creating circular dependencies. The
current design has high cohesion (everything works together) but also high coupling (everything depends on everything), when good design should have
high cohesion but low coupling.

To fix this would require significant architectural changes like splitting the god interface, using dependency injection, or moving to an
event-driven architecture. However, for now, the refactoring has still achieved meaningful improvements by extracting what could be extracted
(targets, filesystem, validation) and organizing the remaining code into well-structured files.


Below are a series of smaller steps that we can take to improve the design. 
Each step has to be a shippable unit, that is, have the tests passing and working, it's not a valid design if it needs all changes to land before it works.

HOW TO WORK
============

Work on each phases linearly through it's milestones.
commits should have the templatge: Refeac Phase <number> : <milestone number> <description>
it's ok for a milestone to take multiple commits, but we shouldn't bundle various milestones in one commit.
commmits cannot bypass the pre-commit hook, we need tests and linting working, else legal won't accept it.
for each milestone: 
* work on the code
* review the code's tests, add aditional tests as needed, updated tests.
* ensure the suite and linting pass
* mark this milestone with "DONE" here. 
* commit and push.

CRITICAL: NO BACKWARDS COMPATIBILITY!
========================================

This software is unreleased, this means that it has no ouside users or clients. 
For this reason we cannot maintain backwards compatibility (functionally yes, but no on the api , interfaces and so forth). Doing so will impose the cost of various versions working well at the same time, with zero benefits.
This means that yes, as interfaces, files and names change, all calling code must be changed too , including tests..

ARCHITECTURAL IMPROVEMENT PLAN
==============================

## Phase 1: Create Core Types Package (Release 1)
**Goal**: Extract basic types to break import cycles
**Shippable**: Yes - just moving types, no behavior changes

1. Create `pkg/synthfs/core` package - DONE
2. Move to core package:
   - OperationID type - DONE
   - OperationDesc struct - DONE
   - OperationStatus constants - DONE
   - PathStateType constants - DONE
   - ArchiveFormat constants - DONE
   - BackupData struct - DONE
   - BackupBudget struct - DONE
3. Update all imports to use core.OperationID, etc. - DONE
4. Tests pass ✓ - DONE

## Phase 2: Split Operation Interface (Release 2)
**Goal**: Break the god interface into focused interfaces
**Shippable**: Yes - using interface composition

1. In core package, create focused interfaces:
   ```go
   // Metadata about an operation
   type OperationMetadata interface {
       ID() OperationID
       Describe() OperationDesc
   }
   
   // Execution capabilities
   type Executable interface {
       Execute(context.Context, filesystem.FileSystem) error
       Validate(context.Context, filesystem.FileSystem) error
   }
   
   // Dependency management
   type DependencyAware interface {
       Dependencies() []OperationID
       Conflicts() []OperationID
   }
   ```
   - DONE (Executable in main package to avoid circular deps)

2. Keep Operation interface but compose it:
   ```go
   type Operation interface {
       OperationMetadata
       Executable
       DependencyAware
       GetItem() targets.FsItem
       Rollback(context.Context, filesystem.FileSystem) error
   }
   ```
   - DONE

3. Tests still pass because Operation still has all methods ✓ - DONE

## Phase 3: Extract Operation Registry (Release 3)
**Goal**: Decouple operation creation from batch
**Shippable**: Yes - registry pattern is additive

1. Create operation registry in core:
   ```go
   type OperationFactory interface {
       CreateOperation(opType string, item targets.FsItem) (Operation, error)
   }
   ```
   - DONE (signature adapted to avoid circular deps)

2. Implement registry that batch can use - DONE
3. Batch uses registry instead of direct creation - DONE
4. Tests pass with new pattern ✓ - DONE

## Phase 4: Create Operations Package (Release 4)
**Goal**: Now we can extract operations without circular deps
**Shippable**: Yes - registry breaks the circular dependency

1. Create `pkg/synthfs/operations` package
2. Move all operation implementations
3. Operations import:
   - core (for types)
   - targets (for items)
   - filesystem (for fs access)
4. Main package imports operations to register them
5. No circular dependency! Tests pass ✓

## Phase 5: Extract Execution Context (Release 5)
**Goal**: Separate execution concerns from operation data
**Shippable**: Yes - context pattern is well understood

1. Create execution context:
   ```go
   type ExecutionContext struct {
       FileSystem filesystem.FileSystem
       Logger     Logger
       Budget     *core.BackupBudget
   }
   ```

2. Change Execute signature:
   ```go
   Execute(ctx context.Context, execCtx *ExecutionContext) error
   ```

3. Update all operations to use context
4. Tests pass with cleaner separation ✓

## Phase 6: Create Execution Package (Release 6)
**Goal**: Extract execution logic now that it's decoupled
**Shippable**: Yes - execution only depends on interfaces

1. Create `pkg/synthfs/execution` package
2. Move Executor, Pipeline, PathStateTracker
3. They import:
   - core (for interfaces)
   - No direct operation imports!
4. Main package wires everything together
5. Clean architecture achieved! Tests pass ✓

## Phase 7: Introduce Event Bus (Release 7)
**Goal**: Further decouple components for extensibility
**Shippable**: Yes - events are additive

1. Create simple event bus in core
2. Operations emit events:
   - OperationStarted
   - OperationCompleted
   - OperationFailed
3. Components can subscribe to events
4. Enables plugins/extensions
5. Tests pass with new capabilities ✓

## Phase 8: Create Batch Package (Release 8)
**Goal**: Extract batch orchestration
**Shippable**: Yes - batch is now just orchestration

1. Create `pkg/synthfs/batch` package
2. Move batch logic
3. Batch only knows interfaces from core
4. Uses registry for operation creation
5. Clean separation achieved! Tests pass ✓

TO BE DECIDED: 
phase 9 onwards are not approved, let's work on the previous ones.
## Phase 9: Plugin Architecture (Release 9) 
**Goal**: Make system extensible
**Shippable**: Yes - plugins are optional

1. Define plugin interfaces
2. Allow registering:
   - Custom operations
   - Custom validators
   - Custom executors
3. Dynamic loading of plugins
4. Tests pass with plugin support ✓

## Phase 10: Configuration Extraction (Release 10)
**Goal**: Centralize configuration
**Shippable**: Yes - config is separate concern

1. Create config package
2. Move all defaults and constants
3. Support config files
4. Environment variable overrides
5. Tests pass with external config ✓

## Final Architecture

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│    core     │     │  operations  │     │  execution  │
│             │◄────┤              │     │             │
│ interfaces  │     │ impl of ops  │     │  executor   │
│   types     │     │              │     │  pipeline   │
│  registry   │     │              │     │   state     │
└─────────────┘     └──────────────┘     └─────────────┘
       ▲                    ▲                    ▲
       │                    │                    │
       └────────────────────┴────────────────────┘
                            │
                    ┌───────▼────────┐
                    │     batch      │
                    │                │
                    │ orchestration  │
                    └────────────────┘
```

Each phase is independently shippable and improves the architecture incrementally. No "big bang" refactoring needed!