SynthFS Correctness Model - Conceptual Framework

    This document describes the correctness philosophy and behavioral guarantees of SynthFS, focusing on the multi-layered approach to error prevention and reliable operation restoration. The model prioritizes catching obvious errors early while maintaining reasonable performance and avoiding over-engineering.

SynthFS operates on a foundation of pragmatic correctness - acknowledging that perfect transactional guarantees are neither achievable nor necessary for most filesystem operations in controlled environments. Instead, the system employs multiple layers of validation and safety mechanisms to catch errors at the most appropriate times, from immediate feedback during operation creation to runtime detection of concurrent modifications.

The correctness model recognizes that filesystem operations exist in an inherently uncertain environment where other processes, users, or the operating system itself may modify the filesystem state between operation planning and execution. Rather than attempting to solve this fundamental limitation, SynthFS provides robust detection mechanisms and clear failure modes that allow applications to respond appropriately to changed conditions.


1. Multi-Layered Validation Strategy

    The SynthFS correctness model employs a three-stage validation approach, with each layer designed to catch different classes of errors at the most appropriate time for user feedback and system reliability.


    1.1. Immediate Validation

        The first line of defense occurs at operation creation time, when the developer's intent is clear and the application context is available for meaningful error handling. Operations that reference non-existent resources - such as attempting to copy a missing file or unarchive a non-existent archive - fail immediately with clear error messages[1].

        This immediate feedback principle ensures that obvious errors are caught when the application has the most context to handle them appropriately, whether through user notification, alternative logic paths, or graceful degradation.


    1.2. Batch Coherence Validation  

        When operations are composed into batches, a second layer of validation ensures internal consistency within the planned operation set. The system detects conflicting operations that would interfere with each other, such as multiple deletions of the same file or attempts to create both a file and directory at the same path[2].

        Beyond conflict detection, this stage also performs automatic dependency resolution, where the system analyzes operation prerequisites and automatically generates necessary supporting operations. For example, creating a file in a non-existent directory tree automatically generates the required directory creation operations[3].


    1.3. Runtime Integrity Validation

        The final validation layer operates at execution time, detecting changes to the filesystem that occurred between operation planning and execution. Using content checksums computed during operation creation, the system can reliably detect when files have been modified by external processes[4].

        This runtime validation acknowledges the fundamental reality that SynthFS cannot control the broader filesystem environment, but it can detect when its assumptions have been violated and fail gracefully rather than proceeding with potentially incorrect operations.


2. Correctness Mechanisms


    2.1. Existence and Precondition Checking

        The most fundamental correctness mechanism involves verifying that operations reference real, accessible filesystem entities before any execution begins. This eliminates a broad class of runtime failures by ensuring that operations have valid targets from the moment they are created.

        When operations reference source files, directories, or archives, the system immediately verifies their existence and accessibility. This applies broadly across operation types - copy and move operations verify their sources, archive creation verifies all input files, and unarchive operations verify the target archive[5]. For symlink operations, target verification can be configured based on whether broken symlinks are acceptable for the application.

        This approach shifts error detection from runtime to planning time, providing immediate feedback when the application context makes error handling most meaningful.


    2.2. Conflict Detection and Path Management

        SynthFS maintains awareness of how operations within a batch will interact with each other, preventing conflicting operations that would result in undefined or erroneous behavior. The system tracks which paths will be created, modified, or deleted by pending operations, using this information to detect conflicts before execution begins[6].

        Common conflicts include attempting to delete the same file multiple times, creating both a file and directory at the same path, or copying multiple sources to the same destination. By catching these conflicts during batch composition, applications receive clear error messages that identify the specific conflicting operations and can adjust their logic accordingly.


    2.3. Content Integrity Verification

        To address the fundamental challenge of concurrent filesystem access, SynthFS employs content checksumming to detect when files have been modified between operation creation and execution. During operation creation, the system computes cryptographic hashes of relevant file contents and stores these as part of the operation metadata[7].

        At execution time, these checksums are recomputed and compared against the stored values. If a mismatch is detected, indicating external modification, the operation fails rather than proceeding with potentially incorrect assumptions about file contents. This mechanism provides a robust defense against race conditions and concurrent access scenarios.


    2.4. Automatic Dependency Resolution

        A significant aspect of SynthFS correctness involves managing the complex web of dependencies that exist between filesystem operations. Rather than requiring users to manually specify these dependencies, the system employs a declarative prerequisite model where operations specify their requirements and the system automatically resolves them.

        Each operation type declares what conditions must be satisfied for it to succeed. File creation operations require their parent directories to exist, copy operations need their source files to be present, and archive operations depend on all their input files being available[8]. The system analyzes these requirements across an entire batch of operations and automatically generates any missing prerequisite operations.

        This automatic resolution extends recursively through arbitrary directory depths. Creating a file at `project/src/main.go` will automatically generate directory creation operations for both `project/` and `project/src/` if they don't exist. This eliminates the cognitive burden of managing step-by-step dependencies while ensuring that operations execute in a logically correct order.

        The dependency resolution process also performs topological sorting to ensure that prerequisite operations execute before the operations that depend on them. This ordering is computed automatically based on the declared prerequisites, freeing users to focus on their intended outcomes rather than implementation sequencing.


3. Restoration and Recovery Model


    3.1. Composable Reverse Operations

        SynthFS employs a sophisticated restoration model based on the principle that every operation should be capable of generating the operations needed to undo its effects. This approach treats restoration not as a special case, but as another application of the same operation composition and execution pipeline used for forward operations.

        Each operation type understands how to reverse its effects through appropriate counter-operations. File creation can be undone through deletion, copying can be reversed by removing the destination, and move operations can be undone by moving the target back to its original location[9]. The most complex case involves deletion operations, which must capture the original content to enable restoration through file recreation.

        This composable approach means that restoration operations benefit from the same validation, dependency resolution, and error handling mechanisms as regular operations. If restoring a deleted directory requires recreating its entire content tree, those recreation operations will automatically resolve their own dependencies and validate their preconditions.


    3.2. Budget-Controlled Memory Management

        The restoration system addresses the fundamental challenge that backup operations could consume unbounded memory by implementing a budget-based resource management system. Users specify a memory budget (defaulting to 10MB) that limits how much data can be backed up to enable restoration[10].

        When operations require backing up data for potential restoration, they must first check whether sufficient budget remains. Operations that would exceed the available budget fail immediately with clear error messages, rather than proceeding without backup capability or consuming unexpected amounts of memory. This provides predictable memory usage characteristics and prevents resource exhaustion scenarios.

        The budget system operates on a per-pipeline basis, tracking total usage across all operations in a batch. As operations consume budget by backing up data, the remaining capacity decreases, and subsequent operations must work within the remaining constraints. This approach balances restoration capability with resource predictability.


    3.3. Recursive Directory Restoration

        When deletion operations target directories, the restoration model extends to recursively preserve entire directory trees. The system walks the directory structure and captures the content of all contained files, subject to budget constraints[11]. This ensures that complex directory hierarchies can be restored completely, rather than leaving empty directory shells.

        The recursive backup process respects the overall budget limitations, potentially capturing some files within a directory while failing on others if the budget is exhausted. This partial backup capability allows operations to proceed when possible while providing clear feedback about what could not be preserved for restoration.


    3.4. Error Propagation and Recovery

        The budget system is designed with clear error propagation that distinguishes between different failure modes. Operations that cannot proceed due to budget constraints fail immediately with specific error messages indicating the file size and remaining budget capacity. This allows applications to respond appropriately, whether by increasing the budget, excluding problematic files, or proceeding without restoration capability.

        When budget constraints prevent complete backup, the system provides detailed reporting on what was successfully backed up versus what was skipped. This transparency allows users to make informed decisions about whether partial restoration capability meets their requirements or whether alternative approaches are needed.


4. Behavioral Guarantees and Limitations


    4.1. What SynthFS Guarantees

        The SynthFS correctness model provides several concrete guarantees within its operational scope:

        - Operations referencing non-existent sources will fail at creation time, not execution time
        - Conflicting operations within a batch will be detected before any execution begins
        - File content modifications between operation creation and execution will be detected via checksum verification
        - Dependencies between operations will be automatically resolved without user intervention
        - Memory usage for restoration capabilities will never exceed the specified budget
        - Restoration operations will use the same validation mechanisms as forward operations


    4.2. What SynthFS Does Not Guarantee

        The model explicitly acknowledges several limitations that reflect the inherent challenges of filesystem operations:

        - SynthFS cannot prevent external processes from modifying the filesystem during operation execution
        - Restoration operations may fail if the filesystem state has changed in ways that prevent proper rollback
        - Very large files may not be restorable if they exceed the configured backup budget
        - Symbolic links may present special challenges if their targets become invalid between operation creation and execution
        - Performance characteristics may degrade with very large batches or deeply nested directory structures


    4.3. Best Effort Philosophy

        The correctness model operates on a foundation of "best effort" reliability - providing strong protections against common error scenarios while acknowledging that perfect guarantees are neither achievable nor necessary for most filesystem operation use cases. This approach allows SynthFS to provide significant value in controlled environments while maintaining reasonable performance characteristics and avoiding overly complex implementation requirements.



Footnotes
---------

[1] See pkg/synthfs/batch/batch.go Copy() and Move() functions for source existence validation implementation

[2] See pkg/synthfs/batch/batch.go PathTracker for conflict detection logic

[3] See pkg/synthfs/execution/prerequisite_resolver.go for automatic prerequisite resolution

[4] See pkg/synthfs/validation/checksum.go ComputeFileChecksum() function for checksum implementation

[5] See pkg/synthfs/operations/create.go and pkg/synthfs/operations/archive.go for existence validation

[6] See pkg/synthfs/batch/batch.go BatchValidator for path conflict detection

[7] See pkg/synthfs/validation/checksum.go ChecksumRecord type for content integrity verification

[8] See pkg/synthfs/core/prerequisites.go for prerequisite interfaces and types

[9] See pkg/synthfs/operations/base.go ReverseOps interface for reverse operation generation

[10] See pkg/synthfs/core/execution_types.go BackupBudget for budget system implementation

[11] See pkg/synthfs/operations/delete.go ReverseOps() for recursive directory backup logic