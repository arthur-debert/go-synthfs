Intro to Synthfs

	Anything that writes to the filesystem is always a blind spot in development: hard to test, hard to reason about and has to be carefully managed and mocked. For non server-client software, like desktop applications , the file system is every where.

1. What is Synthfs

	synthfs, a synthetic file system is a regular API allowing you to create, move, copy and remove  files, directories, links and archives with a regular form, giving you pure objects for the results.  

	with synthfs, you can develop and unitest you program side-effect free, joying the benefits of pure functions making handling the fs  way much simpler and safer.

 2. Operations
 
	This works through synthfs's operations: api calls representing changes to the file system. But unlike real sys-calls, these operations split the actual side effect from the call. When an operation is created, while the fs is not mutated, we can validate it: does the parent dir exists, do I have the right permissions and so on. Hence, you'd get, as expected, errors at operation creation time. 

	Having validation occur in operations is key, as it allows you program to run confidently that it will work, or notify users or other error handling scenarios at that time, when your program has the context for the operation.

	Operations give you a powerful tool: a side-effect code that are a lazy description of the change. It can be tested, passed around, composed in further operations and evaluated at a later time.

	Since the realization of the lazy operations is handled by synthfs, and is well tested, your capplication can be confident that you can sub it for the real things with ease.

	Operations can be though of as reverse receipt, you get a stub that you can convert for the real thing later. But operations are useless if you can't converting the stub, that is execute the changes.  

	That's why operations in synthfs are usef: they follow fs semantics and are validated at their creation too. For example an operation to create the file hello.txt in directory $HOME/data will fail if the directory doesn't exist. And operation that moves files will verify that source and target exist and you have the right permissions.

	This means that you can validate data, and provide user feedback prior to the actual execution of the fs change, allowing you to program and tests for errors in the same side-effect free way while giving timely feedback.

3. Queues


		All these are atomic operations in file systems, but often, from an application point of view one will compose several of these , like creating a directory, adding a file to it and changing it's contents and execute them in sequence.


2. Model and Guarantees

	If it sounds  too good to be true, it's because it is.  Conceptually, fsynth works like a write ahead log, but one that you can postpone and start executing at your convenience.

	This is just not possible: you can't give guarantees for a file system's' state or behavior at an arbitrary point in the future, *while allowing* changes to the file system between the operation is created and executed. That's how real WAL works. By sequencing operations and being the exclusive executor of these, it can gives you a strong guarantee. 

	By synthfs is nothing like that: the operating system, the user, others applications can alter data betwen an operation's creation and execution.  It's critical to understand this: synthfs validation presumes no concurrent changes to file system.  

	This has clear implications: synthfs is a usefull tool and abstraction for tightly  controlled environments, and should never be used under concurrency (not even low concerrency) and mission critical data.  But for software that runs on the user's machine, in locations that the application controls, it's usually safe enough. If the execution encounters an issue : either because an operation files, or we detect a change to the data we're dealing with we'll stop and, to the best extend possible revert the previous state.

	synthfs does some good sanity checking for conflicts and checking that data has not changed between scheduling and running (with some limits, not a true deep validation but for the files at hand). These are here to make sure that simple bugs (in synthfs and your app) are safer,  and as a sanity check. But don't see these as strong guarantees of any sort, because they are not.


3. Understanding Use Cases

	Say that your application allows uses to bundle a few photos and send them to a friend on discord.  You can use synthfs to copy these photos to a working directory, then zip them and finally uploading them to discord.

	There is a myriad ways in which this could go wrong: 
		- The disk has no space to create the zip files.
		- Between the user selecting the images and the application reading them, another process deleted them.
		- Permissions are altered for one or more files. 
		- The user account is removed between steps.

	And we could go on and on.  Note that many of these, are direct fs changes too. When using the os. yuo can copy the files successfully only to have the archive operation fail for insufficient disk space. 

	But if your files are in control of this applications, under normal conditions things will work. It's just paramount to have the correct expections here.

	First , no-concurrency:  anythin that is multi user or multi-processor writing to the same locations won't work.  Secondly, no strong guarantees: even if the data has not changed, a host of other reasons can break the execution phase: no disk space , user permissions change and so on.


Components

	At it's very core, synthfs gives you a way delcare / queue operations , work on the results and execute them later.  It provides some simple mechanics for restore and can correctly report successes or failures.
