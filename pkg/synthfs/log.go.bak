package synthfs

import (
	"io"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/rs/zerolog"
)

var (
	// Global logger instance for the synthfs library
	libLogger zerolog.Logger
	loggerMu  sync.RWMutex
	logLevel  zerolog.Level = zerolog.WarnLevel // Default to warn level
)

func init() {
	// Initialize the library logger with sensible defaults
	setupLibraryLogger(os.Stderr, zerolog.WarnLevel)
}

// setupLibraryLogger configures the global logger for the synthfs library
func setupLibraryLogger(w io.Writer, level zerolog.Level) {
	loggerMu.Lock()
	defer loggerMu.Unlock()

	logLevel = level

	// Configure zerolog for better console output
	output := zerolog.ConsoleWriter{
		Out:        w,
		TimeFormat: time.RFC3339,
		NoColor:    false,
	}

	// Add synthfs prefix to all log messages to identify library logs
	libLogger = zerolog.New(output).
		Level(level).
		With().
		Timestamp().
		Str("lib", "synthfs").
		Logger()
}

// SetLogLevel sets the global log level for the synthfs library
// This allows applications to control synthfs logging verbosity
func SetLogLevel(level zerolog.Level) {
	loggerMu.Lock()
	defer loggerMu.Unlock()

	logLevel = level
	libLogger = libLogger.Level(level)
}

// SetLogLevelFromString sets the log level from a string
// Supported levels: "trace", "debug", "info", "warn", "error", "fatal", "panic"
func SetLogLevelFromString(levelStr string) error {
	level, err := zerolog.ParseLevel(strings.ToLower(levelStr))
	if err != nil {
		return err
	}
	SetLogLevel(level)
	return nil
}

// GetLogLevel returns the current log level
func GetLogLevel() zerolog.Level {
	loggerMu.RLock()
	defer loggerMu.RUnlock()
	return logLevel
}

// SetLogOutput sets the output writer for the library logger
func SetLogOutput(w io.Writer) {
	loggerMu.Lock()
	defer loggerMu.Unlock()

	output := zerolog.ConsoleWriter{
		Out:        w,
		TimeFormat: time.RFC3339,
		NoColor:    false,
	}

	libLogger = zerolog.New(output).
		Level(logLevel).
		With().
		Timestamp().
		Str("lib", "synthfs").
		Logger()
}

// SetupTestLogging configures logging for tests based on verbosity flags
// Call this in TestMain or test setup functions
func SetupTestLogging(verbose int) {
	var level zerolog.Level

	switch verbose {
	case 0: // No -v flag
		level = zerolog.WarnLevel
	case 1: // -v
		level = zerolog.InfoLevel
	case 2: // -vv
		level = zerolog.DebugLevel
	case 3: // -vvv or more
		level = zerolog.TraceLevel
	default:
		level = zerolog.TraceLevel
	}

	SetLogLevel(level)
}

// DisableLogging completely disables logging (useful for benchmarks)
func DisableLogging() {
	SetLogLevel(zerolog.Disabled)
}

// Logger returns the global synthfs logger instance
func Logger() *zerolog.Logger {
	loggerMu.RLock()
	defer loggerMu.RUnlock()
	return &libLogger
}

// Convenience methods for common logging patterns in synthfs

// LogOperationStart logs the start of an operation
func LogOperationStart(opID OperationID, opType string, path string) {
	loggerMu.RLock()
	defer loggerMu.RUnlock()
	libLogger.Info().
		Str("op_id", string(opID)).
		Str("op_type", opType).
		Str("path", path).
		Msg("operation started")
}

// LogOperationComplete logs the completion of an operation
func LogOperationComplete(opID OperationID, opType string, path string, success bool, duration time.Duration) {
	loggerMu.RLock()
	defer loggerMu.RUnlock()
	event := libLogger.Info().
		Str("op_id", string(opID)).
		Str("op_type", opType).
		Str("path", path).
		Bool("success", success).
		Dur("duration", duration)

	if success {
		event.Msg("operation completed successfully")
	} else {
		event.Msg("operation failed")
	}
}

// LogValidationResult logs validation results
func LogValidationResult(opID OperationID, opType string, path string, valid bool, reason string) {
	loggerMu.RLock()
	defer loggerMu.RUnlock()
	event := libLogger.Debug().
		Str("op_id", string(opID)).
		Str("op_type", opType).
		Str("path", path).
		Bool("valid", valid)

	if !valid && reason != "" {
		event.Str("reason", reason)
	}

	event.Msg("operation validation result")
}
