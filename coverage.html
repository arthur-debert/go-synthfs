
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>synthfs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/arthur-debert/synthfs/cmd/synthfs/main.go (0.0%)</option>

				<option value="file1">github.com/arthur-debert/synthfs/cmd/synthfs/root.go (33.3%)</option>

				<option value="file2">github.com/arthur-debert/synthfs/pkg/synthfs/batch.go (92.7%)</option>

				<option value="file3">github.com/arthur-debert/synthfs/pkg/synthfs/executor.go (80.5%)</option>

				<option value="file4">github.com/arthur-debert/synthfs/pkg/synthfs/fs.go (75.0%)</option>

				<option value="file5">github.com/arthur-debert/synthfs/pkg/synthfs/items.go (97.6%)</option>

				<option value="file6">github.com/arthur-debert/synthfs/pkg/synthfs/log.go (97.7%)</option>

				<option value="file7">github.com/arthur-debert/synthfs/pkg/synthfs/operation.go (76.4%)</option>

				<option value="file8">github.com/arthur-debert/synthfs/pkg/synthfs/pipeline.go (75.9%)</option>

				<option value="file9">github.com/arthur-debert/synthfs/pkg/synthfs/state.go (78.9%)</option>

				<option value="file10">github.com/arthur-debert/synthfs/pkg/synthfs/testing.go (66.7%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package main

// Version information - set by ldflags during build
var (
        version = "dev"     // Set by goreleaser: -X main.version={{.Version}}
        commit  = "unknown" // Set by goreleaser: -X main.commit={{.Commit}}
        date    = "unknown" // Set by goreleaser: -X main.date={{.Date}}
)

func main() <span class="cov0" title="0">{
        Execute()
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "synthfs",
        Short: "A filesystem operation planning and execution tool",
        Long: `synthfs is a tool for creating, managing, and executing filesystem operation plans.
It allows you to define sequences of filesystem operations (like creating files and directories)
in a declarative way, with support for dependencies and conflict resolution.`,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.synthfs.yaml)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")

        // Add version command
        rootCmd.AddCommand(versionCmd)

        // Plan commands temporarily removed during v2 migration
        // rootCmd.AddCommand(newPlanCommand())
}</span>

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number",
        Long:  `Print the version number of synthfs`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("synthfs version %s (commit: %s, built: %s)\n", version, commit, date)
        }</span>,
}
</pre>

		<pre class="file" id="file2" style="display: none">package synthfs

import (
        "context"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"
)

// computeFileChecksum computes MD5 checksum for a file
func (b *Batch) computeFileChecksum(filePath string) (*ChecksumRecord, error) <span class="cov7" title="43">{
        // Phase I, Milestone 3: Basic checksumming for copy/move operations
        return ComputeFileChecksum(b.fs, filePath)
}</span>

// Batch represents a collection of filesystem operations that can be validated and executed as a unit.
// It provides an imperative API with validate-as-you-go and automatic dependency resolution.
type Batch struct {
        operations  []Operation
        fs          FullFileSystem // Use FullFileSystem to have access to Stat method
        ctx         context.Context
        idCounter   int
        pathTracker *PathStateTracker // Phase II: Track projected path state
}

// NewBatch creates a new operation batch with default filesystem and context.
func NewBatch() *Batch <span class="cov8" title="70">{
        fs := NewOSFileSystem(".") // Use current directory as default root
        return &amp;Batch{
                operations:  []Operation{},
                fs:          fs,
                ctx:         context.Background(),
                idCounter:   0,
                pathTracker: NewPathStateTracker(fs), // Phase II: Initialize path state tracker
        }
}</span>

// WithFileSystem sets the filesystem for the batch operations.
func (b *Batch) WithFileSystem(fs FullFileSystem) *Batch <span class="cov8" title="69">{
        b.fs = fs
        b.pathTracker.fs = fs // Keep pathTracker's filesystem in sync
        return b
}</span>

// WithContext sets the context for the batch operations.
func (b *Batch) WithContext(ctx context.Context) *Batch <span class="cov5" title="9">{
        b.ctx = ctx
        return b
}</span>

// Operations returns all operations currently in the batch.
func (b *Batch) Operations() []Operation <span class="cov5" title="12">{
        // Return a copy to prevent external modification
        opsCopy := make([]Operation, len(b.operations))
        copy(opsCopy, b.operations)
        return opsCopy
}</span>

// add adds an operation to the batch and validates it against the projected filesystem state
func (b *Batch) add(op Operation) error <span class="cov9" title="114">{
        // Phase II: Validate against projected state and update it.
        if err := b.pathTracker.UpdateState(op); err != nil </span><span class="cov5" title="11">{
                return err
        }</span>

        // Auto-resolve dependencies (ensure parent directories exist)
        // This will need to be updated to use the PathStateTracker as well.
        <span class="cov9" title="103">var opPath string
        if simpleOp, ok := op.(*SimpleOperation); ok </span><span class="cov9" title="103">{
                if simpleOp.dstPath != "" </span><span class="cov7" title="27">{
                        opPath = simpleOp.dstPath
                }</span> else<span class="cov9" title="76"> {
                        opPath = simpleOp.description.Path
                }</span>
        } else<span class="cov0" title="0"> {
                opPath = op.Describe().Path
        }</span>

        <span class="cov9" title="103">if parentDeps := b.ensureParentDirectories(opPath); len(parentDeps) &gt; 0 </span><span class="cov5" title="11">{
                if simpleOp, ok := op.(*SimpleOperation); ok </span><span class="cov5" title="11">{
                        for _, depID := range parentDeps </span><span class="cov5" title="13">{
                                simpleOp.AddDependency(depID)
                        }</span>
                }
        }

        <span class="cov9" title="103">b.operations = append(b.operations, op)
        return nil</span>
}

// CreateDir adds a directory creation operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) CreateDir(path string, mode ...fs.FileMode) (Operation, error) <span class="cov6" title="16">{
        fileMode := fs.FileMode(0755) // Default directory mode
        if len(mode) &gt; 0 </span><span class="cov0" title="0">{
                fileMode = mode[0]
        }</span>

        // Create the operation directly to avoid circular import
        <span class="cov6" title="16">opID := b.generateID("create_dir", path)
        op := NewSimpleOperation(opID, "create_directory", path)

        // Set the FsItem for this create operation
        dirItem := NewDirectory(path).WithMode(fileMode)
        op.SetItem(dirItem)
        op.SetDescriptionDetail("mode", fileMode.String())

        // Validate immediately against the real filesystem.
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed for CreateDir(%s): %w", path, err)
        }</span>

        <span class="cov6" title="15">if err := b.add(op); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to add CreateDir(%s): %w", path, err)
        }</span>

        <span class="cov5" title="14">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("path", path).
                Str("mode", fileMode.String()).
                Msg("CreateDir operation added to batch")

        return op, nil</span>
}

// CreateFile adds a file creation operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) CreateFile(path string, content []byte, mode ...fs.FileMode) (Operation, error) <span class="cov7" title="33">{
        fileMode := fs.FileMode(0644) // Default file mode
        if len(mode) &gt; 0 </span><span class="cov0" title="0">{
                fileMode = mode[0]
        }</span>

        // Create the operation directly to avoid circular import
        <span class="cov7" title="33">opID := b.generateID("create_file", path)
        op := NewSimpleOperation(opID, "create_file", path)

        // Set the FsItem for this create operation
        fileItem := NewFile(path).WithContent(content).WithMode(fileMode)
        op.SetItem(fileItem)
        op.SetDescriptionDetail("content_length", len(content))
        op.SetDescriptionDetail("mode", fileMode.String())

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("validation failed for CreateFile(%s): %w", path, err)
        }</span>

        <span class="cov7" title="31">if err := b.add(op); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to add CreateFile(%s): %w", path, err)
        }</span>

        <span class="cov7" title="28">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("path", path).
                Int("content_length", len(content)).
                Str("mode", fileMode.String()).
                Msg("CreateFile operation added to batch")

        return op, nil</span>
}

// Copy adds a copy operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) Copy(src, dst string) (Operation, error) <span class="cov6" title="23">{
        // Create the operation directly to avoid circular import
        opID := b.generateID("copy", src+"_to_"+dst)
        op := NewSimpleOperation(opID, "copy", src)
        op.SetDescriptionDetail("destination", dst)
        op.SetPaths(src, dst)

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf("validation failed for Copy(%s, %s): %w", src, dst, err)
        }</span>

        // Phase I, Milestone 3: Compute checksum for source file
        <span class="cov6" title="19">if checksum, err := b.computeFileChecksum(src); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for Copy(%s, %s): failed to compute source checksum: %w", src, dst, err)
        }</span> else<span class="cov6" title="19"> if checksum != nil </span><span class="cov6" title="17">{
                op.SetChecksum(src, checksum)
                op.SetDescriptionDetail("source_checksum", checksum.MD5)
        }</span>

        <span class="cov6" title="19">if err := b.add(op); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to add Copy(%s, %s): %w", src, dst, err)
        }</span>

        <span class="cov6" title="18">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("src", src).
                Str("dst", dst).
                Msg("Copy operation added to batch")

        return op, nil</span>
}

// Move adds a move operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) Move(src, dst string) (Operation, error) <span class="cov5" title="13">{
        // Create the operation directly to avoid circular import
        opID := b.generateID("move", src+"_to_"+dst)
        op := NewSimpleOperation(opID, "move", src)
        op.SetDescriptionDetail("destination", dst)
        op.SetPaths(src, dst)

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("validation failed for Move(%s, %s): %w", src, dst, err)
        }</span>

        // Phase I, Milestone 3: Compute checksum for source file
        <span class="cov5" title="10">if checksum, err := b.computeFileChecksum(src); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for Move(%s, %s): failed to compute source checksum: %w", src, dst, err)
        }</span> else<span class="cov5" title="10"> if checksum != nil </span><span class="cov5" title="10">{
                op.SetChecksum(src, checksum)
                op.SetDescriptionDetail("source_checksum", checksum.MD5)
        }</span>

        <span class="cov5" title="10">if err := b.add(op); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to add Move(%s, %s): %w", src, dst, err)
        }</span>

        <span class="cov5" title="9">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("src", src).
                Str("dst", dst).
                Msg("Move operation added to batch")

        return op, nil</span>
}

// Delete adds a delete operation to the batch.
// It validates the operation immediately.
func (b *Batch) Delete(path string) (Operation, error) <span class="cov6" title="20">{
        // Create the operation directly to avoid circular import
        opID := b.generateID("delete", path)
        op := NewSimpleOperation(opID, "delete", path)

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed for Delete(%s): %w", path, err)
        }</span>

        <span class="cov6" title="19">if err := b.add(op); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to add Delete(%s): %w", path, err)
        }</span>

        // Add to batch (no dependency resolution needed for delete)
        <span class="cov6" title="16">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("path", path).
                Msg("Delete operation added to batch")

        return op, nil</span>
}

// CreateSymlink adds a symbolic link creation operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) CreateSymlink(target, linkPath string) (Operation, error) <span class="cov3" title="5">{
        // Create the operation
        opID := b.generateID("create_symlink", linkPath)
        op := NewSimpleOperation(opID, "create_symlink", linkPath)

        // Set the SymlinkItem for this create operation
        symlinkItem := NewSymlink(linkPath, target)
        op.SetItem(symlinkItem)
        op.SetDescriptionDetail("target", target)

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for CreateSymlink(%s, %s): %w", target, linkPath, err)
        }</span>

        <span class="cov3" title="5">if err := b.add(op); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to add CreateSymlink(%s, %s): %w", target, linkPath, err)
        }</span>

        <span class="cov3" title="4">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("target", target).
                Str("link_path", linkPath).
                Msg("CreateSymlink operation added to batch")

        return op, nil</span>
}

// CreateArchive adds an archive creation operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) CreateArchive(archivePath string, format ArchiveFormat, sources ...string) (Operation, error) <span class="cov5" title="9">{
        // Validate inputs
        if len(sources) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for CreateArchive(%s): must specify at least one source", archivePath)
        }</span>

        // Create the operation
        <span class="cov5" title="9">opID := b.generateID("create_archive", archivePath)
        op := NewSimpleOperation(opID, "create_archive", archivePath)

        // Set the ArchiveItem for this create operation
        archiveItem := NewArchive(archivePath, format, sources)
        op.SetItem(archiveItem)
        op.SetDescriptionDetail("format", format.String())
        op.SetDescriptionDetail("source_count", len(sources))

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed for CreateArchive(%s): %w", archivePath, err)
        }</span>

        // Phase I, Milestone 3: Compute checksums for all source files
        <span class="cov4" title="8">for _, source := range sources </span><span class="cov5" title="14">{
                if checksum, err := b.computeFileChecksum(source); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("validation failed for CreateArchive(%s): failed to compute checksum for source %s: %w", archivePath, source, err)
                }</span> else<span class="cov5" title="14"> if checksum != nil </span><span class="cov5" title="14">{
                        op.SetChecksum(source, checksum)
                }</span>
        }
        <span class="cov4" title="8">op.SetDescriptionDetail("sources_checksummed", len(sources))

        if err := b.add(op); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to add CreateArchive(%s): %w", archivePath, err)
        }</span>

        <span class="cov4" title="7">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("archive_path", archivePath).
                Str("format", format.String()).
                Int("source_count", len(sources)).
                Msg("CreateArchive operation added to batch")

        return op, nil</span>
}

// Unarchive adds an unarchive operation to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) Unarchive(archivePath, extractPath string) (Operation, error) <span class="cov2" title="2">{
        // Create the operation
        opID := b.generateID("unarchive", archivePath+"_to_"+extractPath)
        op := NewSimpleOperation(opID, "unarchive", archivePath)

        // Set the UnarchiveItem for this operation
        unarchiveItem := NewUnarchive(archivePath, extractPath)
        op.SetItem(unarchiveItem)
        op.SetDescriptionDetail("extract_path", extractPath)

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("validation failed for Unarchive(%s, %s): %w", archivePath, extractPath, err)
        }</span>

        <span class="cov1" title="1">if err := b.add(op); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add Unarchive(%s, %s): %w", archivePath, extractPath, err)
        }</span>

        <span class="cov1" title="1">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("archive_path", archivePath).
                Str("extract_path", extractPath).
                Msg("Unarchive operation added to batch")

        return op, nil</span>
}

// UnarchiveWithPatterns adds an unarchive operation with pattern filtering to the batch.
// It validates the operation immediately and resolves dependencies automatically.
func (b *Batch) UnarchiveWithPatterns(archivePath, extractPath string, patterns ...string) (Operation, error) <span class="cov1" title="1">{
        // Create the operation
        opID := b.generateID("unarchive", archivePath+"_to_"+extractPath)
        op := NewSimpleOperation(opID, "unarchive", archivePath)

        // Set the UnarchiveItem for this operation with patterns
        unarchiveItem := NewUnarchive(archivePath, extractPath).WithPatterns(patterns...)
        op.SetItem(unarchiveItem)
        op.SetDescriptionDetail("extract_path", extractPath)
        op.SetDescriptionDetail("patterns", patterns)
        op.SetDescriptionDetail("pattern_count", len(patterns))

        // Validate immediately
        if err := op.Validate(b.ctx, b.fs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed for UnarchiveWithPatterns(%s, %s): %w", archivePath, extractPath, err)
        }</span>

        <span class="cov1" title="1">if err := b.add(op); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add UnarchiveWithPatterns(%s, %s): %w", archivePath, extractPath, err)
        }</span>

        <span class="cov1" title="1">Logger().Info().
                Str("op_id", string(op.ID())).
                Str("archive_path", archivePath).
                Str("extract_path", extractPath).
                Strs("patterns", patterns).
                Msg("UnarchiveWithPatterns operation added to batch")

        return op, nil</span>
}

// Run runs all operations in the batch using the existing infrastructure.
func (b *Batch) Run() (*Result, error) <span class="cov7" title="30">{
        return b.RunWithOptions(DefaultPipelineOptions())
}</span>

// RunWithOptions runs all operations in the batch with specified options (Phase III).
func (b *Batch) RunWithOptions(opts PipelineOptions) (*Result, error) <span class="cov7" title="37">{
        Logger().Info().
                Int("operation_count", len(b.operations)).
                Bool("restorable", opts.Restorable).
                Int("max_backup_mb", opts.MaxBackupSizeMB).
                Msg("executing batch")

        // Resolve implicit dependencies before execution
        if err := b.resolveImplicitDependencies(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve implicit dependencies: %w", err)
        }</span>

        // Create executor and pipeline
        <span class="cov7" title="37">executor := NewExecutor()
        pipeline := NewMemPipeline()

        // Add all operations to pipeline
        if err := pipeline.Add(b.operations...); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add operations to pipeline: %w", err)
        }</span>

        // Run using Phase III infrastructure
        <span class="cov7" title="37">result := executor.RunWithOptions(b.ctx, pipeline, b.fs, opts)

        Logger().Info().
                Bool("success", result.Success).
                Int("operations_executed", len(result.Operations)).
                Int("restore_operations", len(result.RestoreOps)).
                Dur("duration", result.Duration).
                Msg("batch run completed")

        return result, nil</span>
}

// RunRestorable runs all operations with backup enabled using the default 10MB budget (Phase III).
// This is a convenience method for the common case of wanting restorable execution.
func (b *Batch) RunRestorable() (*Result, error) <span class="cov3" title="4">{
        return b.RunWithOptions(PipelineOptions{
                Restorable:      true,
                MaxBackupSizeMB: 10,
        })
}</span>

// RunRestorableWithBudget runs all operations with backup enabled using a custom budget (Phase III).
func (b *Batch) RunRestorableWithBudget(maxBackupMB int) (*Result, error) <span class="cov3" title="3">{
        return b.RunWithOptions(PipelineOptions{
                Restorable:      true,
                MaxBackupSizeMB: maxBackupMB,
        })
}</span>

// generateID creates a unique operation ID based on type and path.
func (b *Batch) generateID(opType, path string) OperationID <span class="cov10" title="127">{
        b.idCounter++
        cleanPath := strings.ReplaceAll(path, "/", "_")
        cleanPath = strings.ReplaceAll(cleanPath, "\\", "_")
        return OperationID(fmt.Sprintf("batch_%d_%s_%s", b.idCounter, opType, cleanPath))
}</span>

// ensureParentDirectories analyzes a path and adds CreateDir operations for missing parent directories.
// Returns the operation IDs of any auto-generated parent directory operations.
func (b *Batch) ensureParentDirectories(path string) []OperationID <span class="cov9" title="108">{
        // Clean and normalize the path
        cleanPath := filepath.Clean(path)
        parentDir := filepath.Dir(cleanPath)

        var dependencyIDs []OperationID

        // If parent is root or current directory, no parent needed
        if parentDir == "." || parentDir == "/" || parentDir == cleanPath </span><span class="cov9" title="93">{
                return dependencyIDs
        }</span>

        // Phase II: Check if parent directory is projected to exist
        <span class="cov6" title="15">parentState, err := b.pathTracker.GetState(parentDir)
        if err == nil &amp;&amp; parentState.WillExist </span><span class="cov5" title="10">{
                if parentState.CreatedBy != "" </span><span class="cov4" title="8">{
                        // If it was created by a previous operation in this batch, we depend on it.
                        dependencyIDs = append(dependencyIDs, parentState.CreatedBy)
                }</span>
                // If it exists (either on disk or projected), we don't need to do anything else.
                <span class="cov5" title="10">return dependencyIDs</span>
        }

        // Recursively ensure parent's parents exist
        <span class="cov3" title="5">parentDeps := b.ensureParentDirectories(parentDir)
        dependencyIDs = append(dependencyIDs, parentDeps...)

        // Create operation for the parent directory
        parentOpID := b.generateID("create_dir_auto", parentDir)
        parentOp := NewSimpleOperation(parentOpID, "create_directory", parentDir)
        parentDirItem := NewDirectory(parentDir).WithMode(0755)
        parentOp.SetItem(parentDirItem)
        parentOp.SetDescriptionDetail("mode", "0755")

        // Add dependencies from parent's parents
        for _, depID := range parentDeps </span><span class="cov3" title="3">{
                parentOp.AddDependency(depID)
        }</span>

        // Validate the auto-generated parent operation and add it to the batch
        <span class="cov3" title="5">if err := b.add(parentOp); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - might be resolved at execution time
                Logger().Warn().
                        Err(err).
                        Str("path", parentDir).
                        Msg("validation warning for auto-generated parent directory")
                // Even if it fails validation (e.g., conflict), other operations might depend on its ID.
                // We'll still add the ID to dependencies. The conflict will be reported when the batch is run.
        }</span>

        <span class="cov3" title="5">dependencyIDs = append(dependencyIDs, parentOp.ID())

        Logger().Info().
                Str("op_id", string(parentOp.ID())).
                Str("path", parentDir).
                Str("reason", "auto-generated for parent directory").
                Msg("CreateDir operation auto-added to batch")

        return dependencyIDs</span>
}

// resolveImplicitDependencies analyzes all operations and adds dependencies to prevent conflicts.
// This ensures operations that depend on the same files are executed in the correct order.
func (b *Batch) resolveImplicitDependencies() error <span class="cov7" title="37">{
        Logger().Info().
                Int("operations", len(b.operations)).
                Msg("resolving implicit dependencies between operations")

        // Build maps of operations by the files they read/write/delete
        fileReaders := make(map[string][]int)    // path -&gt; operation indices that read this file
        fileWriters := make(map[string][]int)    // path -&gt; operation indices that write/create this file
        fileMovers := make(map[string][]int)     // path -&gt; operation indices that move/delete this file
        symlinkTargets := make(map[string][]int) // target path -&gt; operation indices that create symlinks to this target

        for i, op := range b.operations </span><span class="cov8" title="66">{
                desc := op.Describe()

                switch desc.Type </span>{
                case "create_file", "create_directory":<span class="cov7" title="33">
                        fileWriters[desc.Path] = append(fileWriters[desc.Path], i)</span>

                case "copy":<span class="cov5" title="9">
                        // Copy reads source and writes destination
                        if simpleOp, ok := op.(*SimpleOperation); ok </span><span class="cov5" title="9">{
                                srcPath := simpleOp.GetSrcPath()
                                dstPath := simpleOp.GetDstPath()
                                if srcPath != "" </span><span class="cov5" title="9">{
                                        fileReaders[srcPath] = append(fileReaders[srcPath], i)
                                }</span>
                                <span class="cov5" title="9">if dstPath != "" </span><span class="cov5" title="9">{
                                        fileWriters[dstPath] = append(fileWriters[dstPath], i)
                                }</span>
                        }

                case "move":<span class="cov3" title="5">
                        // Move reads source and writes destination, then deletes source
                        if simpleOp, ok := op.(*SimpleOperation); ok </span><span class="cov3" title="5">{
                                srcPath := simpleOp.GetSrcPath()
                                dstPath := simpleOp.GetDstPath()
                                if srcPath != "" </span><span class="cov3" title="5">{
                                        fileReaders[srcPath] = append(fileReaders[srcPath], i)
                                        fileMovers[srcPath] = append(fileMovers[srcPath], i)
                                }</span>
                                <span class="cov3" title="5">if dstPath != "" </span><span class="cov3" title="5">{
                                        fileWriters[dstPath] = append(fileWriters[dstPath], i)
                                }</span>
                        }

                case "delete":<span class="cov5" title="9">
                        fileMovers[desc.Path] = append(fileMovers[desc.Path], i)</span>

                case "create_symlink":<span class="cov3" title="3">
                        // Symlink creation depends on the target existing
                        if target, ok := desc.Details["target"]; ok </span><span class="cov3" title="3">{
                                if targetPath, ok := target.(string); ok </span><span class="cov3" title="3">{
                                        symlinkTargets[targetPath] = append(symlinkTargets[targetPath], i)
                                        // A symlink operation "reads" its target path, so it must happen
                                        // before the target is moved or deleted.
                                        fileReaders[targetPath] = append(fileReaders[targetPath], i)
                                }</span>
                        }
                        <span class="cov3" title="3">fileWriters[desc.Path] = append(fileWriters[desc.Path], i)</span>

                case "create_archive":<span class="cov3" title="5">
                        // Archive reads all source files
                        if archiveItem := op.GetItem(); archiveItem != nil </span><span class="cov3" title="5">{
                                if archive, ok := archiveItem.(*ArchiveItem); ok </span><span class="cov3" title="5">{
                                        for _, source := range archive.Sources() </span><span class="cov5" title="9">{
                                                fileReaders[source] = append(fileReaders[source], i)
                                        }</span>
                                }
                        }
                        <span class="cov3" title="5">fileWriters[desc.Path] = append(fileWriters[desc.Path], i)</span>

                case "unarchive":<span class="cov2" title="2">
                        // Unarchive reads archive file and writes extracted files
                        fileReaders[desc.Path] = append(fileReaders[desc.Path], i)</span>
                        // Note: We can't easily predict all extracted files without opening the archive,
                        // so we'll rely on explicit dependencies and validation at execution time
                }
        }

        // Now add dependencies to ensure correct ordering
        <span class="cov7" title="37">dependenciesAdded := 0

        // Rule 1: Operations that move/delete files must come after operations that read those files
        for filePath, movers := range fileMovers </span><span class="cov5" title="14">{
                if readers, hasReaders := fileReaders[filePath]; hasReaders </span><span class="cov3" title="5">{
                        for _, moverIdx := range movers </span><span class="cov3" title="5">{
                                for _, readerIdx := range readers </span><span class="cov4" title="7">{
                                        if readerIdx != moverIdx </span><span class="cov2" title="2">{
                                                // Reader must come before mover
                                                if simpleOp, ok := b.operations[moverIdx].(*SimpleOperation); ok </span><span class="cov2" title="2">{
                                                        readerID := b.operations[readerIdx].ID()
                                                        // Check if dependency already exists
                                                        exists := false
                                                        for _, dep := range simpleOp.Dependencies() </span><span class="cov3" title="3">{
                                                                if dep == readerID </span><span class="cov0" title="0">{
                                                                        exists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov2" title="2">if !exists </span><span class="cov2" title="2">{
                                                                simpleOp.AddDependency(readerID)
                                                                dependenciesAdded++
                                                                Logger().Info().
                                                                        Str("operation", string(simpleOp.ID())).
                                                                        Str("depends_on", string(readerID)).
                                                                        Str("reason", fmt.Sprintf("mover depends on reader of %s", filePath)).
                                                                        Msg("added implicit dependency")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Rule 2: Operations that create symlinks must come after operations that create their targets
        <span class="cov7" title="37">for targetPath, symlinkCreators := range symlinkTargets </span><span class="cov3" title="3">{
                if writers, hasWriters := fileWriters[targetPath]; hasWriters </span><span class="cov1" title="1">{
                        for _, symlinkIdx := range symlinkCreators </span><span class="cov1" title="1">{
                                for _, writerIdx := range writers </span><span class="cov1" title="1">{
                                        if writerIdx != symlinkIdx </span><span class="cov1" title="1">{
                                                // Writer must come before symlink creator
                                                if simpleOp, ok := b.operations[symlinkIdx].(*SimpleOperation); ok </span><span class="cov1" title="1">{
                                                        writerID := b.operations[writerIdx].ID()
                                                        // Check if dependency already exists
                                                        exists := false
                                                        for _, dep := range simpleOp.Dependencies() </span><span class="cov0" title="0">{
                                                                if dep == writerID </span><span class="cov0" title="0">{
                                                                        exists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov1" title="1">if !exists </span><span class="cov1" title="1">{
                                                                simpleOp.AddDependency(writerID)
                                                                dependenciesAdded++
                                                                Logger().Info().
                                                                        Str("operation", string(simpleOp.ID())).
                                                                        Str("depends_on", string(writerID)).
                                                                        Str("reason", fmt.Sprintf("symlink depends on target creation %s", targetPath)).
                                                                        Msg("added implicit dependency")
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov7" title="37">Logger().Info().
                Int("dependencies_added", dependenciesAdded).
                Msg("implicit dependency resolution completed")

        return nil</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package synthfs

import (
        "context"
        "fmt"
        "time"
)

// OperationStatus indicates the outcome of an individual operation's execution.
type OperationStatus string

const (
        StatusSuccess    OperationStatus = "SUCCESS"
        StatusFailure    OperationStatus = "FAILURE"
        StatusValidation OperationStatus = "VALIDATION_FAILURE"
)

// PipelineOptions controls how operations are executed (Phase III)
type PipelineOptions struct {
        Restorable      bool    // Whether to enable reversible operations with backup
        MaxBackupSizeMB int     // Maximum backup size in MB (default: 10MB)
}

// DefaultPipelineOptions returns sensible defaults for pipeline execution
func DefaultPipelineOptions() PipelineOptions <span class="cov8" title="32">{
        return PipelineOptions{
                Restorable:      false, // No backup overhead by default
                MaxBackupSizeMB: 10,    // 10MB default budget - perfect for config files
        }
}</span>

// OperationResult holds the outcome of a single operation's execution.
type OperationResult struct {
        OperationID  OperationID
        Operation    Operation // The operation that was executed
        Status       OperationStatus
        Error        error
        Duration     time.Duration
        BackupData   *BackupData // Phase III: Backup data for restoration (only if restorable=true)
        BackupSizeMB float64     // Phase III: Actual backup size consumed
}

// Result holds the overall outcome of running a pipeline of operations.
type Result struct {
        Success    bool              // True if all operations were successful
        Operations []OperationResult // Results for each operation attempted
        Duration   time.Duration
        Errors     []error                     // Aggregated errors from operations that failed
        Rollback   func(context.Context) error // Rollback function for failed transactions

        // Phase III: Enhanced restoration functionality
        Budget     *BackupBudget               // Backup budget information (only if restorable=true)
        RestoreOps []Operation                 // Generated reverse operations for restoration
}

// Executor processes a pipeline of operations.
type Executor struct{}

// NewExecutor creates a new Executor.
func NewExecutor() *Executor <span class="cov8" title="40">{
        return &amp;Executor{}
}</span>

// Run runs all operations in the pipeline with default options.
// This is a convenience method that calls RunWithOptions using DefaultPipelineOptions().
func (e *Executor) Run(ctx context.Context, pipeline Pipeline, fs FileSystem) *Result <span class="cov0" title="0">{
        return e.RunWithOptions(ctx, pipeline, fs, DefaultPipelineOptions())
}</span>

// RunWithOptions runs all operations in the pipeline with specified options (Phase III).
//
// Behavior:
// - Resolves dependencies using topological sort
// - Validates all operations before execution
// - Executes operations in dependency order
// - Optionally generates backup data for restoration (if opts.Restorable=true)
// - Continues execution even if individual operations fail
// - Returns a Result with success/failure status and backup/restore information
// - Caller is responsible for calling Rollback if desired
func (e *Executor) RunWithOptions(ctx context.Context, pipeline Pipeline, fs FileSystem, opts PipelineOptions) *Result <span class="cov8" title="40">{
        Logger().Info().
                Int("operation_count", len(pipeline.Operations())).
                Bool("restorable", opts.Restorable).
                Int("max_backup_mb", opts.MaxBackupSizeMB).
                Msg("starting execution")

        start := time.Now()
        result := &amp;Result{
                Operations: []OperationResult{},
                Errors:     []error{},
                Success:    true,
                RestoreOps: []Operation{},
        }

        // Phase III: Initialize budget if restorable mode is enabled
        var budget *BackupBudget
        if opts.Restorable </span><span class="cov5" title="9">{
                budget = &amp;BackupBudget{
                        TotalMB:     float64(opts.MaxBackupSizeMB),
                        RemainingMB: float64(opts.MaxBackupSizeMB),
                        UsedMB:      0,
                }
                result.Budget = budget

                Logger().Info().
                        Float64("total_budget_mb", budget.TotalMB).
                        Msg("backup budget initialized for restorable execution")
        }</span>

        // Resolve dependencies first
        <span class="cov8" title="40">Logger().Info().Msg("resolving operation dependencies")
        if err := pipeline.Resolve(); err != nil </span><span class="cov0" title="0">{
                Logger().Info().Err(err).Msg("dependency resolution failed")
                result.Success = false
                result.Errors = append(result.Errors, fmt.Errorf("dependency resolution failed: %w", err))
                result.Duration = time.Since(start)
                return result
        }</span>
        <span class="cov8" title="40">Logger().Info().Msg("dependency resolution completed successfully")

        // Validate the pipeline
        Logger().Info().Msg("validating operation pipeline")
        if err := pipeline.Validate(ctx, fs); err != nil </span><span class="cov0" title="0">{
                Logger().Info().Err(err).Msg("pipeline validation failed")
                result.Success = false
                result.Errors = append(result.Errors, fmt.Errorf("pipeline validation failed: %w", err))
                result.Duration = time.Since(start)
                return result
        }</span>
        <span class="cov8" title="40">Logger().Info().Msg("pipeline validation completed successfully")

        operations := pipeline.Operations()
        rollbackOps := make([]Operation, 0, len(operations))

        Logger().Info().
                Int("operations_to_execute", len(operations)).
                Msg("beginning operation execution")

        // Execute operations
        for i, op := range operations </span><span class="cov10" title="69">{
                Logger().Info().
                        Str("op_id", string(op.ID())).
                        Str("op_type", op.Describe().Type).
                        Str("path", op.Describe().Path).
                        Int("operation_index", i+1).
                        Int("total_operations", len(operations)).
                        Msg("executing operation")

                // Phase III: Generate reverse operations if restorable mode is enabled
                var reverseOps []Operation
                var backupData *BackupData
                var reverseErr error

                if opts.Restorable </span><span class="cov6" title="14">{
                        Logger().Debug().
                                Str("op_id", string(op.ID())).
                                Float64("remaining_budget_mb", budget.RemainingMB).
                                Msg("generating reverse operations for backup")

                        reverseOps, backupData, reverseErr = op.ReverseOps(ctx, fs, budget)
                        if reverseErr != nil </span><span class="cov3" title="3">{
                                Logger().Warn().
                                        Str("op_id", string(op.ID())).
                                        Err(reverseErr).
                                        Msg("failed to generate reverse operations - operation will execute without backup")
                                // Continue execution even if reverse ops generation fails
                        }</span> else<span class="cov6" title="11"> if backupData != nil </span><span class="cov6" title="11">{
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Float64("backup_size_mb", backupData.SizeMB).
                                        Float64("remaining_budget_mb", budget.RemainingMB).
                                        Str("backup_type", backupData.BackupType).
                                        Msg("backup data generated successfully")
                        }</span>
                }

                <span class="cov10" title="69">opStart := time.Now()
                err := op.Execute(ctx, fs)
                opDuration := time.Since(opStart)

                opResult := OperationResult{
                        OperationID:  op.ID(),
                        Operation:    op,
                        Duration:     opDuration,
                        BackupData:   backupData,
                        BackupSizeMB: 0,
                }

                if backupData != nil </span><span class="cov6" title="11">{
                        opResult.BackupSizeMB = backupData.SizeMB
                }</span>

                <span class="cov10" title="69">if err != nil </span><span class="cov4" title="6">{
                        Logger().Info().
                                Str("op_id", string(op.ID())).
                                Str("op_type", op.Describe().Type).
                                Str("path", op.Describe().Path).
                                Err(err).
                                Dur("duration", opDuration).
                                Msg("operation execution failed")

                        opResult.Status = StatusFailure
                        opResult.Error = err
                        result.Success = false
                        result.Errors = append(result.Errors, fmt.Errorf("operation %s failed: %w", op.ID(), err))

                        // Phase III: Restore budget if operation failed and backup was created
                        if opts.Restorable &amp;&amp; backupData != nil &amp;&amp; budget != nil </span><span class="cov0" title="0">{
                                budget.RestoreBackup(backupData.SizeMB)
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Float64("restored_budget_mb", backupData.SizeMB).
                                        Float64("remaining_budget_mb", budget.RemainingMB).
                                        Msg("restored backup budget due to operation failure")
                        }</span>
                } else<span class="cov9" title="63"> {
                        Logger().Info().
                                Str("op_id", string(op.ID())).
                                Str("op_type", op.Describe().Type).
                                Str("path", op.Describe().Path).
                                Dur("duration", opDuration).
                                Msg("operation execution completed successfully")

                        opResult.Status = StatusSuccess
                        rollbackOps = append(rollbackOps, op)

                        // Phase III: Add reverse operations to result if available
                        if opts.Restorable &amp;&amp; reverseOps != nil </span><span class="cov6" title="11">{
                                result.RestoreOps = append(result.RestoreOps, reverseOps...)
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Int("reverse_ops_count", len(reverseOps)).
                                        Msg("added reverse operations for restoration")
                        }</span>
                }

                <span class="cov10" title="69">result.Operations = append(result.Operations, opResult)</span>
        }

        <span class="cov8" title="40">result.Duration = time.Since(start)
        result.Rollback = e.createRollbackFunc(rollbackOps, fs)

        Logger().Info().
                Bool("success", result.Success).
                Int("total_operations", len(operations)).
                Int("successful_operations", len(rollbackOps)).
                Int("failed_operations", len(result.Errors)).
                Int("restore_operations", len(result.RestoreOps)).
                Dur("total_duration", result.Duration).
                Msg("execution completed")

        // Phase III: Log budget usage summary
        if opts.Restorable &amp;&amp; budget != nil </span><span class="cov5" title="9">{
                Logger().Info().
                        Float64("total_budget_mb", budget.TotalMB).
                        Float64("used_budget_mb", budget.UsedMB).
                        Float64("remaining_budget_mb", budget.RemainingMB).
                        Msg("backup budget usage summary")
        }</span>

        <span class="cov8" title="40">return result</span>
}

// createRollbackFunc creates a rollback function that can undo executed operations.
func (e *Executor) createRollbackFunc(executedOps []Operation, fsys FileSystem) func(context.Context) error <span class="cov8" title="40">{
        if len(executedOps) == 0 </span><span class="cov4" title="6">{
                return func(ctx context.Context) error </span><span class="cov0" title="0">{ return nil }</span>
        }

        <span class="cov8" title="34">return func(ctx context.Context) error </span><span class="cov2" title="2">{
                // Rollback in reverse order
                var rollbackErrors []error
                for i := len(executedOps) - 1; i &gt;= 0; i-- </span><span class="cov2" title="2">{
                        op := executedOps[i]
                        if err := op.Rollback(ctx, fsys); err != nil </span><span class="cov0" title="0">{
                                rollbackErrors = append(rollbackErrors, fmt.Errorf("rollback failed for operation %s: %w", op.ID(), err))
                        }</span>
                }

                <span class="cov2" title="2">if len(rollbackErrors) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("rollback errors: %v", rollbackErrors)
                }</span>
                <span class="cov2" title="2">return nil</span>
        }
}
</pre>

		<pre class="file" id="file4" style="display: none">package synthfs

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// ReadFS is an alias for fs.FS, representing a read-only file system.
type ReadFS = fs.FS

// WriteFS defines the interface for write operations on a file system.
type WriteFS interface {
        // WriteFile writes data to a file named name.
        // If the file does not exist, WriteFile creates it with permissions perm;
        // otherwise WriteFile truncates it before writing.
        WriteFile(name string, data []byte, perm fs.FileMode) error

        // MkdirAll creates a directory named path,
        // along with any necessary parents, and returns nil,
        // or else returns an error.
        // The permission bits perm (before umask) are used for all
        // directories that MkdirAll creates.
        MkdirAll(path string, perm fs.FileMode) error

        // Remove removes the named file or (empty) directory.
        Remove(name string) error

        // RemoveAll removes path and any children it contains.
        // It removes everything it can but returns the first error
        // it encounters. If the path does not exist, RemoveAll
        // returns nil (no error).
        RemoveAll(name string) error

        // Symlink creates newname as a symbolic link to oldname.
        // On Windows, a symlink to a non-existent oldname creates a file symlink;
        // if oldname is later created as a directory, the symlink will not work.
        // If there is an error, it will be of type *LinkError.
        Symlink(oldname, newname string) error

        // Readlink returns the destination of the named symbolic link.
        // If there is an error, it will be of type *PathError.
        Readlink(name string) (string, error)

        // Rename renames (moves) oldpath to newpath.
        // If newpath already exists and is not a directory, Rename replaces it.
        // OS-specific restrictions may apply when oldpath and newpath are in different directories.
        // If there is an error, it will be of type *LinkError.
        Rename(oldpath, newpath string) error
}

// FileSystem combines read and write operations.
type FileSystem interface {
        ReadFS
        WriteFS
}

// StatFS extends ReadFS with Stat capabilities for better io/fs compatibility
type StatFS interface {
        ReadFS
        Stat(name string) (fs.FileInfo, error)
}

// FullFileSystem provides the complete filesystem interface including Stat
type FullFileSystem interface {
        FileSystem
        Stat(name string) (fs.FileInfo, error)
}

// OSFileSystem implements FullFileSystem using the OS filesystem
type OSFileSystem struct {
        root string
}

// NewOSFileSystem creates a new OS-based filesystem rooted at the given path
func NewOSFileSystem(root string) *OSFileSystem <span class="cov10" title="77">{
        return &amp;OSFileSystem{root: root}
}</span>

// Open implements fs.FS
func (osfs *OSFileSystem) Open(name string) (fs.File, error) <span class="cov6" title="14">{
        if !fs.ValidPath(name) </span><span class="cov1" title="1">{
                return nil, &amp;fs.PathError{Op: "open", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov6" title="13">fullPath := filepath.Join(osfs.root, name)
        return os.Open(fullPath)</span>
}

// Stat implements StatFS
func (osfs *OSFileSystem) Stat(name string) (fs.FileInfo, error) <span class="cov8" title="44">{
        if !fs.ValidPath(name) </span><span class="cov3" title="3">{
                return nil, &amp;fs.PathError{Op: "stat", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov8" title="41">fullPath := filepath.Join(osfs.root, name)
        return os.Stat(fullPath)</span>
}

// WriteFile implements WriteFS
func (osfs *OSFileSystem) WriteFile(name string, data []byte, perm fs.FileMode) error <span class="cov7" title="29">{
        if !fs.ValidPath(name) </span><span class="cov1" title="1">{
                return &amp;fs.PathError{Op: "writefile", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov7" title="28">fullPath := filepath.Join(osfs.root, name)
        return os.WriteFile(fullPath, data, perm)</span>
}

// MkdirAll implements WriteFS
func (osfs *OSFileSystem) MkdirAll(path string, perm fs.FileMode) error <span class="cov7" title="21">{
        if !fs.ValidPath(path) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "mkdirall", Path: path, Err: fs.ErrInvalid}
        }</span>
        <span class="cov7" title="21">fullPath := filepath.Join(osfs.root, path)
        return os.MkdirAll(fullPath, perm)</span>
}

// Remove implements WriteFS
func (osfs *OSFileSystem) Remove(name string) error <span class="cov4" title="6">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov4" title="6">fullPath := filepath.Join(osfs.root, name)
        return os.Remove(fullPath)</span>
}

// RemoveAll implements WriteFS
func (osfs *OSFileSystem) RemoveAll(name string) error <span class="cov1" title="1">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov1" title="1">fullPath := filepath.Join(osfs.root, name)
        return os.RemoveAll(fullPath)</span>
}

// Symlink implements WriteFS
func (osfs *OSFileSystem) Symlink(oldname, newname string) error <span class="cov2" title="2">{
        if !fs.ValidPath(oldname) || !fs.ValidPath(newname) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "symlink", Path: newname, Err: fs.ErrInvalid}
        }</span>
        <span class="cov2" title="2">oldPath := filepath.Join(osfs.root, oldname)
        newPath := filepath.Join(osfs.root, newname)
        return os.Symlink(oldPath, newPath)</span>
}

// Readlink implements WriteFS
func (osfs *OSFileSystem) Readlink(name string) (string, error) <span class="cov2" title="2">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov2" title="2">fullPath := filepath.Join(osfs.root, name)
        target, err := os.Readlink(fullPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        // Convert absolute path back to relative if it's within our root
        <span class="cov1" title="1">if filepath.IsAbs(target) </span><span class="cov1" title="1">{
                rel, err := filepath.Rel(osfs.root, target)
                if err == nil &amp;&amp; !strings.HasPrefix(rel, "..") </span><span class="cov1" title="1">{
                        return rel, nil
                }</span>
        }
        <span class="cov0" title="0">return target, nil</span>
}

// Rename implements WriteFS
func (osfs *OSFileSystem) Rename(oldpath, newpath string) error <span class="cov2" title="2">{
        if !fs.ValidPath(oldpath) || !fs.ValidPath(newpath) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "rename", Path: newpath, Err: fs.ErrInvalid}
        }</span>
        <span class="cov2" title="2">oldFullPath := filepath.Join(osfs.root, oldpath)
        newFullPath := filepath.Join(osfs.root, newpath)
        return os.Rename(oldFullPath, newFullPath)</span>
}

// ComputeFileChecksum calculates the MD5 checksum and gathers file metadata.
// It requires a FullFileSystem to access both file content and metadata.
func ComputeFileChecksum(fsys FullFileSystem, filePath string) (*ChecksumRecord, error) <span class="cov9" title="64">{
        // Get file info first
        info, err := fsys.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat file %s: %w", filePath, err)
        }</span>

        // Skip checksumming for directories
        <span class="cov9" title="64">if info.IsDir() </span><span class="cov2" title="2">{
                return nil, nil
        }</span>

        // Open file for reading
        <span class="cov9" title="62">file, err := fsys.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file %s for checksumming: %w", filePath, err)
        }</span>
        <span class="cov9" title="62">defer func() </span><span class="cov9" title="62">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        Logger().Warn().Err(closeErr).Str("path", filePath).Msg("failed to close file during checksumming")
                }</span>
        }()

        // Compute MD5 hash
        <span class="cov9" title="62">hasher := md5.New()
        if _, err := io.Copy(hasher, file); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compute checksum for %s: %w", filePath, err)
        }</span>

        <span class="cov9" title="62">checksum := fmt.Sprintf("%x", hasher.Sum(nil))

        return &amp;ChecksumRecord{
                Path:         filePath,
                MD5:          checksum,
                Size:         info.Size(),
                ModTime:      info.ModTime(),
                ChecksumTime: time.Now(),
        }, nil</span>
}

// ReadOnlyWrapper wraps any fs.FS to provide StatFS functionality if possible
type ReadOnlyWrapper struct {
        fs.FS
}

// NewReadOnlyWrapper creates a wrapper around any fs.FS
func NewReadOnlyWrapper(fsys fs.FS) *ReadOnlyWrapper <span class="cov2" title="2">{
        return &amp;ReadOnlyWrapper{FS: fsys}
}</span>

// Stat implements StatFS if the underlying filesystem supports fs.StatFS
func (w *ReadOnlyWrapper) Stat(name string) (fs.FileInfo, error) <span class="cov3" title="4">{
        if statFS, ok := w.FS.(fs.StatFS); ok </span><span class="cov3" title="4">{
                return statFS.Stat(name)
        }</span>
        // Fallback: try to open and get file info
        <span class="cov0" title="0">file, err := w.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        Logger().Warn().Err(closeErr).Msg("failed to close file in Stat fallback")
                }</span>
        }()
        <span class="cov0" title="0">return file.Stat()</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package synthfs

import "io/fs"

// FsItem represents a filesystem item to be created.
// It's a declarative way to define what should exist on the filesystem.
type FsItem interface {
        Path() string // Path returns the absolute path of the filesystem item.
        Type() string // Type returns a string representation of the item's type (e.g., "file", "directory").
}

// --- FileItem ---

// FileItem represents a file to be created.
type FileItem struct {
        path    string
        content []byte
        mode    fs.FileMode
}

// NewFile creates a new FileItem builder.
// Path is the absolute path to the file.
func NewFile(path string) *FileItem <span class="cov8" title="44">{
        return &amp;FileItem{
                path: path,
                mode: 0644, // Default mode
        }
}</span>

// Path returns the file's path.
func (fi *FileItem) Path() string <span class="cov10" title="77">{
        return fi.path
}</span>

// Type returns "file".
func (fi *FileItem) Type() string <span class="cov1" title="1">{
        return "file"
}</span>

// WithContent sets the content for the file.
func (fi *FileItem) WithContent(content []byte) *FileItem <span class="cov8" title="41">{
        fi.content = content
        return fi
}</span>

// Content returns the file's content.
func (fi *FileItem) Content() []byte <span class="cov7" title="24">{
        return fi.content
}</span>

// WithMode sets the file mode (permissions).
func (fi *FileItem) WithMode(mode fs.FileMode) *FileItem <span class="cov8" title="37">{
        fi.mode = mode
        return fi
}</span>

// Mode returns the file's mode.
func (fi *FileItem) Mode() fs.FileMode <span class="cov7" title="25">{
        return fi.mode
}</span>

// --- DirectoryItem ---

// DirectoryItem represents a directory to be created.
type DirectoryItem struct {
        path string
        mode fs.FileMode
}

// NewDirectory creates a new DirectoryItem builder.
// Path is the absolute path to the directory.
func NewDirectory(path string) *DirectoryItem <span class="cov7" title="26">{
        return &amp;DirectoryItem{
                path: path,
                mode: 0755, // Default mode
        }
}</span>

// Path returns the directory's path.
func (di *DirectoryItem) Path() string <span class="cov8" title="42">{
        return di.path
}</span>

// Type returns "directory".
func (di *DirectoryItem) Type() string <span class="cov1" title="1">{
        return "directory"
}</span>

// WithMode sets the directory mode (permissions).
func (di *DirectoryItem) WithMode(mode fs.FileMode) *DirectoryItem <span class="cov7" title="24">{
        di.mode = mode
        return di
}</span>

// Mode returns the directory's mode.
func (di *DirectoryItem) Mode() fs.FileMode <span class="cov6" title="15">{
        return di.mode
}</span>

// --- SymlinkItem ---

// SymlinkItem represents a symbolic link to be created.
type SymlinkItem struct {
        path   string
        target string
}

// NewSymlink creates a new SymlinkItem builder.
// Path is the absolute path to the symlink.
// Target is the path the symlink should point to.
func NewSymlink(path string, target string) *SymlinkItem <span class="cov5" title="7">{
        return &amp;SymlinkItem{
                path:   path,
                target: target,
        }
}</span>

// Path returns the symlink's path.
func (si *SymlinkItem) Path() string <span class="cov6" title="13">{
        return si.path
}</span>

// Type returns "symlink".
func (si *SymlinkItem) Type() string <span class="cov1" title="1">{
        return "symlink"
}</span>

// Target returns the symlink's target path.
func (si *SymlinkItem) Target() string <span class="cov6" title="13">{
        return si.target
}</span>

// --- ArchiveItem ---

// ArchiveFormat defines the type of archive.
type ArchiveFormat int

const (
        ArchiveFormatTarGz ArchiveFormat = iota
        ArchiveFormatZip
)

// String returns the string representation of the ArchiveFormat.
// This implements the fmt.Stringer interface.
func (af ArchiveFormat) String() string <span class="cov6" title="16">{
        switch af </span>{
        case ArchiveFormatTarGz:<span class="cov6" title="13">
                return "tar.gz"</span>
        case ArchiveFormatZip:<span class="cov3" title="3">
                return "zip"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// ArchiveItem represents an archive to be created.
type ArchiveItem struct {
        path    string
        format  ArchiveFormat
        sources []string
}

// NewArchive creates a new ArchiveItem builder.
// Path is the absolute path to the archive file.
// Format is the archive format (e.g., TarGz, Zip).
// Sources are the paths to the files/directories to be included in the archive.
func NewArchive(path string, format ArchiveFormat, sources []string) *ArchiveItem <span class="cov6" title="14">{
        return &amp;ArchiveItem{
                path:    path,
                format:  format,
                sources: sources,
        }
}</span>

// Path returns the archive's path.
func (ai *ArchiveItem) Path() string <span class="cov7" title="23">{
        return ai.path
}</span>

// Type returns "archive".
func (ai *ArchiveItem) Type() string <span class="cov1" title="1">{
        return "archive"
}</span>

// Format returns the archive's format.
func (ai *ArchiveItem) Format() ArchiveFormat <span class="cov4" title="5">{
        return ai.format
}</span>

// Sources returns the list of source paths for the archive.
func (ai *ArchiveItem) Sources() []string <span class="cov8" title="46">{
        return ai.sources
}</span>

// WithSources sets the sources for the archive.
// This allows modifying sources after initial creation if needed.
func (ai *ArchiveItem) WithSources(sources []string) *ArchiveItem <span class="cov1" title="1">{
        ai.sources = sources
        return ai
}</span>

// --- UnarchiveItem ---

// UnarchiveItem represents an unarchive operation to be performed.
type UnarchiveItem struct {
        archivePath   string
        extractPath   string
        patterns      []string // Optional patterns to filter extracted files
        overwrite     bool     // Whether to overwrite existing files
}

// NewUnarchive creates a new UnarchiveItem builder.
// archivePath is the path to the archive file to extract.
// extractPath is the destination directory where files will be extracted.
func NewUnarchive(archivePath, extractPath string) *UnarchiveItem <span class="cov6" title="17">{
        return &amp;UnarchiveItem{
                archivePath: archivePath,
                extractPath: extractPath,
                patterns:    []string{},
                overwrite:   false,
        }
}</span>

// Path returns the archive's path (primary path for the operation).
func (ui *UnarchiveItem) Path() string <span class="cov1" title="1">{
        return ui.archivePath
}</span>

// Type returns "unarchive".
func (ui *UnarchiveItem) Type() string <span class="cov1" title="1">{
        return "unarchive"
}</span>

// ArchivePath returns the path to the archive file.
func (ui *UnarchiveItem) ArchivePath() string <span class="cov8" title="35">{
        return ui.archivePath
}</span>

// ExtractPath returns the destination path for extraction.
func (ui *UnarchiveItem) ExtractPath() string <span class="cov9" title="49">{
        return ui.extractPath
}</span>

// Patterns returns the list of patterns to filter extracted files.
func (ui *UnarchiveItem) Patterns() []string <span class="cov7" title="25">{
        return ui.patterns
}</span>

// Overwrite returns whether existing files should be overwritten.
func (ui *UnarchiveItem) Overwrite() bool <span class="cov6" title="13">{
        return ui.overwrite
}</span>

// WithPatterns sets the patterns for selective extraction.
// Patterns can include wildcards like "docs/*.html" or "docs/**"
func (ui *UnarchiveItem) WithPatterns(patterns ...string) *UnarchiveItem <span class="cov3" title="3">{
        ui.patterns = patterns
        return ui
}</span>

// WithOverwrite sets whether to overwrite existing files.
func (ui *UnarchiveItem) WithOverwrite(overwrite bool) *UnarchiveItem <span class="cov1" title="1">{
        ui.overwrite = overwrite
        return ui
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package synthfs

import (
        "io"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

var (
        // Global logger instance for the synthfs library
        libLogger zerolog.Logger
        loggerMu  sync.RWMutex
        logLevel  zerolog.Level = zerolog.WarnLevel // Default to warn level
)

func init() <span class="cov1" title="1">{
        // Initialize the library logger with sensible defaults
        setupLibraryLogger(os.Stderr, zerolog.WarnLevel)
}</span>

// setupLibraryLogger configures the global logger for the synthfs library
func setupLibraryLogger(w io.Writer, level zerolog.Level) <span class="cov1" title="1">{
        loggerMu.Lock()
        defer loggerMu.Unlock()

        logLevel = level

        // Configure zerolog for better console output
        output := zerolog.ConsoleWriter{
                Out:        w,
                TimeFormat: time.RFC3339,
                NoColor:    false,
        }

        // Add synthfs prefix to all log messages to identify library logs
        libLogger = zerolog.New(output).
                Level(level).
                With().
                Timestamp().
                Str("lib", "synthfs").
                Logger()
}</span>

// SetLogLevel sets the global log level for the synthfs library
// This allows applications to control synthfs logging verbosity
func SetLogLevel(level zerolog.Level) <span class="cov4" title="18">{
        loggerMu.Lock()
        defer loggerMu.Unlock()

        logLevel = level
        libLogger = libLogger.Level(level)
}</span>

// SetLogLevelFromString sets the log level from a string
// Supported levels: "trace", "debug", "info", "warn", "error", "fatal", "panic"
func SetLogLevelFromString(levelStr string) error <span class="cov3" title="6">{
        level, err := zerolog.ParseLevel(strings.ToLower(levelStr))
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov2" title="5">SetLogLevel(level)
        return nil</span>
}

// GetLogLevel returns the current log level
func GetLogLevel() zerolog.Level <span class="cov3" title="11">{
        loggerMu.RLock()
        defer loggerMu.RUnlock()
        return logLevel
}</span>

// SetLogOutput sets the output writer for the library logger
func SetLogOutput(w io.Writer) <span class="cov3" title="8">{
        loggerMu.Lock()
        defer loggerMu.Unlock()

        output := zerolog.ConsoleWriter{
                Out:        w,
                TimeFormat: time.RFC3339,
                NoColor:    false,
        }

        libLogger = zerolog.New(output).
                Level(logLevel).
                With().
                Timestamp().
                Str("lib", "synthfs").
                Logger()
}</span>

// SetupTestLogging configures logging for tests based on verbosity flags
// Call this in TestMain or test setup functions
func SetupTestLogging(verbose int) <span class="cov2" title="5">{
        var level zerolog.Level

        switch verbose </span>{
        case 0:<span class="cov1" title="1"> // No -v flag
                level = zerolog.WarnLevel</span>
        case 1:<span class="cov1" title="1"> // -v
                level = zerolog.InfoLevel</span>
        case 2:<span class="cov1" title="1"> // -vv
                level = zerolog.DebugLevel</span>
        case 3:<span class="cov1" title="1"> // -vvv or more
                level = zerolog.TraceLevel</span>
        default:<span class="cov1" title="1">
                level = zerolog.TraceLevel</span>
        }

        <span class="cov2" title="5">SetLogLevel(level)</span>
}

// DisableLogging completely disables logging (useful for benchmarks)
func DisableLogging() <span class="cov1" title="1">{
        SetLogLevel(zerolog.Disabled)
}</span>

// Logger returns the global synthfs logger instance
func Logger() *zerolog.Logger <span class="cov10" title="2046">{
        loggerMu.RLock()
        defer loggerMu.RUnlock()
        return &amp;libLogger
}</span>

// Convenience methods for common logging patterns in synthfs

// LogOperationStart logs the start of an operation
func LogOperationStart(opID OperationID, opType string, path string) <span class="cov1" title="1">{
        libLogger.Info().
                Str("op_id", string(opID)).
                Str("op_type", opType).
                Str("path", path).
                Msg("operation started")
}</span>

// LogOperationComplete logs the completion of an operation
func LogOperationComplete(opID OperationID, opType string, path string, success bool, duration time.Duration) <span class="cov1" title="1">{
        event := libLogger.Info().
                Str("op_id", string(opID)).
                Str("op_type", opType).
                Str("path", path).
                Bool("success", success).
                Dur("duration", duration)

        if success </span><span class="cov1" title="1">{
                event.Msg("operation completed successfully")
        }</span> else<span class="cov0" title="0"> {
                event.Msg("operation failed")
        }</span>
}

// LogValidationResult logs validation results
func LogValidationResult(opID OperationID, opType string, path string, valid bool, reason string) <span class="cov1" title="1">{
        event := libLogger.Debug().
                Str("op_id", string(opID)).
                Str("op_type", opType).
                Str("path", path).
                Bool("valid", valid)

        if !valid &amp;&amp; reason != "" </span><span class="cov1" title="1">{
                event.Str("reason", reason)
        }</span>

        <span class="cov1" title="1">event.Msg("operation validation result")</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package synthfs

import (
        "archive/tar"
        "archive/zip"
        "bytes"
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "io/fs"
        "path/filepath"
        "strings"
        "time"
)

// OperationID is a unique identifier for an operation.
type OperationID string

// ChecksumRecord stores file checksum information for validation
type ChecksumRecord struct {
        Path         string
        MD5          string
        Size         int64
        ModTime      time.Time
        ChecksumTime time.Time
}

// FileSystem interface is defined in fs.go

// OperationDesc provides a human-readable description of an operation.
type OperationDesc struct {
        Type    string                 // e.g., "create_file", "delete_directory"
        Path    string                 // Primary path affected
        Details map[string]interface{} // Additional operation-specific details
}

// BackupData stores the data needed to restore an operation's effects
type BackupData struct {
        OperationID   OperationID              `json:"operation_id"`
        BackupType    string                   `json:"backup_type"`    // "file", "directory", "none"
        OriginalPath  string                   `json:"original_path"`  // Path that was affected
        BackupContent []byte                   `json:"backup_content"` // File content backup
        BackupMode    fs.FileMode              `json:"backup_mode"`    // Original file mode
        BackupTime    time.Time                `json:"backup_time"`    // When backup was created
        SizeMB        float64                  `json:"size_mb"`        // Size in MB for budget tracking
        Metadata      map[string]interface{}   `json:"metadata"`       // Additional metadata
}

// BackupBudget tracks memory usage for backup operations
type BackupBudget struct {
        TotalMB     float64 `json:"total_mb"`
        RemainingMB float64 `json:"remaining_mb"`
        UsedMB      float64 `json:"used_mb"`
}

// ConsumeBackup reduces the remaining budget by the specified amount
func (bb *BackupBudget) ConsumeBackup(sizeMB float64) error <span class="cov3" title="10">{
        if sizeMB &gt; bb.RemainingMB </span><span class="cov2" title="4">{
                return fmt.Errorf("backup size %.2fMB exceeds remaining budget %.2fMB", sizeMB, bb.RemainingMB)
        }</span>
        <span class="cov3" title="6">bb.RemainingMB -= sizeMB
        bb.UsedMB += sizeMB
        return nil</span>
}

// RestoreBackup increases the remaining budget by the specified amount
func (bb *BackupBudget) RestoreBackup(sizeMB float64) <span class="cov1" title="2">{
        bb.RemainingMB += sizeMB
        bb.UsedMB -= sizeMB
        if bb.UsedMB &lt; 0 </span><span class="cov1" title="1">{
                bb.UsedMB = 0
        }</span>
        <span class="cov1" title="2">if bb.RemainingMB &gt; bb.TotalMB </span><span class="cov1" title="1">{
                bb.RemainingMB = bb.TotalMB
        }</span>
}

// Operation defines a single abstract filesystem operation.
type Operation interface {
        // ID returns the unique identifier of the operation.
        ID() OperationID

        // Dependencies returns a list of OperationIDs that must be successfully
        // executed before this operation can run.
        Dependencies() []OperationID

        // Conflicts returns a list of OperationIDs that cannot run concurrently
        // with this operation or that represent incompatible desired states.
        Conflicts() []OperationID

        // Execute performs the operation on the given filesystem.
        Execute(ctx context.Context, fsys FileSystem) error

        // Validate checks if the operation can be performed.
        Validate(ctx context.Context, fsys FileSystem) error

        // Rollback attempts to undo the effects of the Execute method.
        Rollback(ctx context.Context, fsys FileSystem) error

        // Describe returns a structured description of the operation.
        Describe() OperationDesc

        // GetItem returns the FsItem associated with this operation, if any.
        // This is primarily relevant for Create operations.
        // Returns nil if no item is directly associated (e.g., for Delete, Copy, Move by path).
        GetItem() FsItem

        // GetChecksum retrieves a checksum record for a file path (Phase I, Milestone 3)
        GetChecksum(path string) *ChecksumRecord

        // GetAllChecksums returns all checksum records (Phase I, Milestone 3)
        GetAllChecksums() map[string]*ChecksumRecord

        // ReverseOps generates operations that would undo this operation's effects (Phase III)
        // Returns a slice of operations that, when executed, will restore the filesystem
        // to the state it was in before this operation was executed.
        ReverseOps(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error)
}

// --- SimpleOperation: Basic Operation Implementation ---

// SimpleOperation provides a straightforward implementation of Operation.
// Operations are created complete and immutable - no post-creation modification.
type SimpleOperation struct {
        id           OperationID
        dependencies []OperationID
        description  OperationDesc
        item         FsItem                     // For Create operations
        srcPath      string                     // For Copy/Move operations
        dstPath      string                     // For Copy/Move operations
        checksums    map[string]*ChecksumRecord // Phase I, Milestone 3: Store file checksums
}

// NewSimpleOperation creates a new simple operation.
func NewSimpleOperation(id OperationID, descType string, path string) *SimpleOperation <span class="cov7" title="198">{
        return &amp;SimpleOperation{
                id: id,
                description: OperationDesc{
                        Type:    descType,
                        Path:    path,
                        Details: make(map[string]interface{}),
                },
                dependencies: []OperationID{},
                checksums:    make(map[string]*ChecksumRecord), // Phase I, Milestone 3: Initialize checksum storage
        }
}</span>

// ID returns the operation's ID.
func (op *SimpleOperation) ID() OperationID <span class="cov10" title="1354">{
        return op.id
}</span>

// Dependencies returns the list of operation dependencies.
func (op *SimpleOperation) Dependencies() []OperationID <span class="cov8" title="351">{
        return op.dependencies
}</span>

// Conflicts returns an empty list (conflicts not implemented yet).
func (op *SimpleOperation) Conflicts() []OperationID <span class="cov7" title="138">{
        return nil
}</span>

// Describe returns the operation's description.
func (op *SimpleOperation) Describe() OperationDesc <span class="cov9" title="1304">{
        return op.description
}</span>

// GetItem returns the FsItem associated with this operation.
func (op *SimpleOperation) GetItem() FsItem <span class="cov3" title="9">{
        return op.item
}</span>

// SetItem sets the FsItem for Create operations.
func (op *SimpleOperation) SetItem(item FsItem) <span class="cov6" title="99">{
        op.item = item
}</span>

// SetPaths sets source and destination paths for Copy/Move operations.
func (op *SimpleOperation) SetPaths(src, dst string) <span class="cov5" title="52">{
        op.srcPath = src
        op.dstPath = dst
}</span>

// AddDependency adds a dependency to the operation.
func (op *SimpleOperation) AddDependency(depID OperationID) <span class="cov4" title="19">{
        op.dependencies = append(op.dependencies, depID)
}</span>

// SetDescriptionDetail sets a detail in the operation's description.
func (op *SimpleOperation) SetDescriptionDetail(key string, value interface{}) <span class="cov7" title="188">{
        if op.description.Details == nil </span><span class="cov0" title="0">{
                op.description.Details = make(map[string]interface{})
        }</span>
        <span class="cov7" title="188">op.description.Details[key] = value</span>
}

// GetSrcPath returns the source path for copy/move operations.
func (op *SimpleOperation) GetSrcPath() string <span class="cov5" title="44">{
        return op.srcPath
}</span>

// GetDstPath returns the destination path for copy/move operations.
func (op *SimpleOperation) GetDstPath() string <span class="cov5" title="44">{
        return op.dstPath
}</span>

// SetChecksum stores a checksum record for a file path (Phase I, Milestone 3)
func (op *SimpleOperation) SetChecksum(path string, checksum *ChecksumRecord) <span class="cov5" title="41">{
        if op.checksums == nil </span><span class="cov0" title="0">{
                op.checksums = make(map[string]*ChecksumRecord)
        }</span>
        <span class="cov5" title="41">op.checksums[path] = checksum</span>
}

// GetChecksum retrieves a checksum record for a file path (Phase I, Milestone 3)
func (op *SimpleOperation) GetChecksum(path string) *ChecksumRecord <span class="cov4" title="12">{
        if op.checksums == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="12">return op.checksums[path]</span>
}

// GetAllChecksums returns all checksum records (Phase I, Milestone 3)
func (op *SimpleOperation) GetAllChecksums() map[string]*ChecksumRecord <span class="cov1" title="1">{
        return op.checksums
}</span>

// verifyChecksums verifies all stored checksums against current file state (Phase I, Milestone 4)
func (op *SimpleOperation) verifyChecksums(ctx context.Context, fsys FileSystem) error <span class="cov4" title="21">{
        if len(op.checksums) == 0 </span><span class="cov2" title="3">{
                return nil // No checksums to verify
        }</span>

        // Check if filesystem supports Stat operation
        <span class="cov4" title="18">fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                // If filesystem doesn't support Stat, we cannot compute a checksum.
                // Log a warning and skip verification.
                Logger().Warn().
                        Str("op_id", string(op.ID())).
                        Msg("skipping checksum verification: filesystem does not support Stat")
                return nil
        }</span>

        <span class="cov4" title="18">for path, expectedChecksum := range op.checksums </span><span class="cov4" title="21">{
                // Re-compute the checksum for the current file state
                currentChecksum, err := ComputeFileChecksum(fullFS, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("checksum verification failed for %s: could not compute current checksum: %w", path, err)
                }</span>

                // It's possible for a file to be replaced by a directory
                <span class="cov4" title="21">if currentChecksum == nil &amp;&amp; expectedChecksum != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("checksum verification failed for %s: expected a file but found a directory", path)
                }</span>

                // Compare the MD5 hashes
                <span class="cov4" title="21">if currentChecksum.MD5 != expectedChecksum.MD5 </span><span class="cov2" title="4">{
                        return fmt.Errorf("checksum verification failed for %s: file content has changed. Expected MD5: %s, got: %s",
                                path, expectedChecksum.MD5, currentChecksum.MD5)
                }</span>

                // Optional: We could still log if modtime/size differ but hash is same, but for now hash equality is sufficient.
                <span class="cov4" title="17">Logger().Debug().
                        Str("op_id", string(op.ID())).
                        Str("path", path).
                        Str("md5", currentChecksum.MD5).
                        Msg("checksum verification passed")</span>
        }

        <span class="cov4" title="14">return nil</span>
}

// Execute performs the actual filesystem operation.
func (op *SimpleOperation) Execute(ctx context.Context, fsys FileSystem) error <span class="cov6" title="78">{
        switch op.description.Type </span>{
        case "create_file":<span class="cov4" title="23">
                return op.executeCreateFile(ctx, fsys)</span>
        case "create_directory":<span class="cov4" title="13">
                return op.executeCreateDirectory(ctx, fsys)</span>
        case "create_symlink":<span class="cov2" title="3">
                return op.executeCreateSymlink(ctx, fsys)</span>
        case "create_archive":<span class="cov3" title="5">
                return op.executeCreateArchive(ctx, fsys)</span>
        case "unarchive":<span class="cov3" title="5">
                return op.executeUnarchive(ctx, fsys)</span>
        case "copy":<span class="cov3" title="10">
                return op.executeCopy(ctx, fsys)</span>
        case "move":<span class="cov3" title="6">
                return op.executeMove(ctx, fsys)</span>
        case "delete":<span class="cov4" title="13">
                return op.executeDelete(ctx, fsys)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown operation type: %s", op.description.Type)</span>
        }
}

// Validate checks if the operation can be performed.
func (op *SimpleOperation) Validate(ctx context.Context, fsys FileSystem) error <span class="cov7" title="217">{
        // Basic validation: reject empty paths
        if op.description.Path == "" </span><span class="cov3" title="7">{
                return &amp;ValidationError{
                        Operation: op,
                        Reason:    "path cannot be empty",
                        Cause:     nil,
                }
        }</span>

        <span class="cov7" title="210">switch op.description.Type </span>{
        case "create_file":<span class="cov5" title="54">
                return op.validateCreateFile(ctx, fsys)</span>
        case "create_directory":<span class="cov5" title="29">
                return op.validateCreateDirectory(ctx, fsys)</span>
        case "create_symlink":<span class="cov3" title="9">
                return op.validateCreateSymlink(ctx, fsys)</span>
        case "create_archive":<span class="cov4" title="18">
                return op.validateCreateArchive(ctx, fsys)</span>
        case "unarchive":<span class="cov4" title="13">
                return op.validateUnarchive(ctx, fsys)</span>
        case "copy":<span class="cov5" title="38">
                return op.validateCopy(ctx, fsys)</span>
        case "move":<span class="cov4" title="20">
                return op.validateMove(ctx, fsys)</span>
        case "delete":<span class="cov5" title="29">
                return op.validateDelete(ctx, fsys)</span>
        default:<span class="cov0" title="0">
                return &amp;ValidationError{
                        Operation: op,
                        Reason:    fmt.Sprintf("unknown operation type: %s", op.description.Type),
                }</span>
        }
}

// Rollback attempts to undo the effects of the Execute method.
func (op *SimpleOperation) Rollback(ctx context.Context, fsys FileSystem) error <span class="cov3" title="7">{
        switch op.description.Type </span>{
        case "create_file", "create_directory", "create_symlink", "create_archive":<span class="cov2" title="3">
                // For create operations, rollback means removing what was created
                return op.rollbackCreate(ctx, fsys)</span>
        case "unarchive":<span class="cov0" title="0">
                // For unarchive operations, rollback means removing extracted files
                return op.rollbackUnarchive(ctx, fsys)</span>
        case "copy":<span class="cov1" title="1">
                // For copy operations, rollback means removing the destination
                return op.rollbackCopy(ctx, fsys)</span>
        case "move":<span class="cov1" title="1">
                // For move operations, rollback means moving back
                return op.rollbackMove(ctx, fsys)</span>
        case "delete":<span class="cov1" title="1">
                // For delete operations, rollback is complex - would need to restore
                // For now, we'll return an error indicating rollback isn't supported
                return fmt.Errorf("rollback of delete operations not yet implemented")</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unknown operation type for rollback: %s", op.description.Type)</span>
        }
}

// ReverseOps generates operations that would undo this operation's effects (Phase III)
func (op *SimpleOperation) ReverseOps(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov4" title="19">{
        switch op.description.Type </span>{
        case "create_file":<span class="cov3" title="5">
                return op.reverseCreateFile(ctx, fsys, budget)</span>
        case "create_directory":<span class="cov1" title="1">
                return op.reverseCreateDirectory(ctx, fsys, budget)</span>
        case "create_symlink":<span class="cov0" title="0">
                return op.reverseCreateSymlink(ctx, fsys, budget)</span>
        case "create_archive":<span class="cov0" title="0">
                return op.reverseCreateArchive(ctx, fsys, budget)</span>
        case "unarchive":<span class="cov0" title="0">
                return op.reverseUnarchive(ctx, fsys, budget)</span>
        case "copy":<span class="cov1" title="2">
                return op.reverseCopy(ctx, fsys, budget)</span>
        case "move":<span class="cov1" title="2">
                return op.reverseMove(ctx, fsys, budget)</span>
        case "delete":<span class="cov3" title="9">
                return op.reverseDelete(ctx, fsys, budget)</span>
        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("unknown operation type for reverse ops: %s", op.description.Type)</span>
        }
}

// --- Error Types ---

// ValidationError represents an error during operation validation.
type ValidationError struct {
        Operation Operation
        Reason    string
        Cause     error
}

func (e *ValidationError) Error() string <span class="cov4" title="24">{
        if e.Cause != nil </span><span class="cov4" title="13">{
                return fmt.Sprintf("validation error for operation %s (%s): %s: %v",
                        e.Operation.ID(), e.Operation.Describe().Path, e.Reason, e.Cause)
        }</span>
        <span class="cov3" title="11">return fmt.Sprintf("validation error for operation %s (%s): %s",
                e.Operation.ID(), e.Operation.Describe().Path, e.Reason)</span>
}

func (e *ValidationError) Unwrap() error <span class="cov1" title="2">{
        return e.Cause
}</span>

// DependencyError represents an error with operation dependencies.
type DependencyError struct {
        Operation    Operation
        Dependencies []OperationID
        Missing      []OperationID
}

func (e *DependencyError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("dependency error for operation %s: missing dependencies %v (required: %v)",
                e.Operation.ID(), e.Missing, e.Dependencies)
}</span>

// ConflictError represents an error when operations conflict with each other.
type ConflictError struct {
        Operation Operation
        Conflicts []OperationID
}

func (e *ConflictError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("conflict error for operation %s: conflicts with operations %v",
                e.Operation.ID(), e.Conflicts)
}</span>

// --- Operation Implementation Methods ---

// executeCreateFile implements file creation
func (op *SimpleOperation) executeCreateFile(ctx context.Context, fsys FileSystem) error <span class="cov4" title="23">{
        if op.item == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no file item provided for create_file operation")
        }</span>

        <span class="cov4" title="23">fileItem, ok := op.item.(*FileItem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected FileItem for create_file operation, got %T", op.item)
        }</span>

        <span class="cov4" title="23">return fsys.WriteFile(fileItem.Path(), fileItem.Content(), fileItem.Mode())</span>
}

// executeCreateDirectory implements directory creation
func (op *SimpleOperation) executeCreateDirectory(ctx context.Context, fsys FileSystem) error <span class="cov4" title="13">{
        if op.item == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no directory item provided for create_directory operation")
        }</span>

        <span class="cov4" title="13">dirItem, ok := op.item.(*DirectoryItem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected DirectoryItem for create_directory operation, got %T", op.item)
        }</span>

        <span class="cov4" title="13">return fsys.MkdirAll(dirItem.Path(), dirItem.Mode())</span>
}

// executeCreateSymlink implements symlink creation
func (op *SimpleOperation) executeCreateSymlink(ctx context.Context, fsys FileSystem) error <span class="cov2" title="3">{
        if op.item == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no symlink item provided for create_symlink operation")
        }</span>

        <span class="cov2" title="3">symlinkItem, ok := op.item.(*SymlinkItem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected SymlinkItem for create_symlink operation, got %T", op.item)
        }</span>

        <span class="cov2" title="3">return fsys.Symlink(symlinkItem.Target(), symlinkItem.Path())</span>
}

// executeCreateArchive implements archive creation
func (op *SimpleOperation) executeCreateArchive(ctx context.Context, fsys FileSystem) error <span class="cov3" title="5">{
        if op.item == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no archive item provided for create_archive operation")
        }</span>

        // Phase I, Milestone 4: Verify checksums before execution
        <span class="cov3" title="5">if err := op.verifyChecksums(ctx, fsys); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("archive creation failed checksum verification: %w", err)
        }</span>

        <span class="cov2" title="4">archiveItem, ok := op.item.(*ArchiveItem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ArchiveItem for create_archive operation, got %T", op.item)
        }</span>

        <span class="cov2" title="4">switch archiveItem.Format() </span>{
        case ArchiveFormatTarGz:<span class="cov2" title="3">
                return op.createTarGzArchive(archiveItem, fsys)</span>
        case ArchiveFormatZip:<span class="cov1" title="1">
                return op.createZipArchive(archiveItem, fsys)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported archive format: %s", archiveItem.Format())</span>
        }
}

// createTarGzArchive creates a tar.gz archive
func (op *SimpleOperation) createTarGzArchive(archiveItem *ArchiveItem, fsys FileSystem) error <span class="cov2" title="3">{
        // Create a buffer to hold the archive data
        var buf bytes.Buffer

        gzipWriter := gzip.NewWriter(&amp;buf)
        defer func() </span><span class="cov2" title="3">{
                if closeErr := gzipWriter.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close gzip writer: %v\n", closeErr)
                }</span>
        }()

        <span class="cov2" title="3">tarWriter := tar.NewWriter(gzipWriter)
        defer func() </span><span class="cov2" title="3">{
                if closeErr := tarWriter.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close tar writer: %v\n", closeErr)
                }</span>
        }()

        <span class="cov2" title="3">for _, source := range archiveItem.Sources() </span><span class="cov2" title="4">{
                if err := op.addToTarArchive(tarWriter, source, fsys); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add %s to archive: %w", source, err)
                }</span>
        }

        // Close writers to flush data
        <span class="cov2" title="3">if err := tarWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close tar writer: %w", err)
        }</span>
        <span class="cov2" title="3">if err := gzipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close gzip writer: %w", err)
        }</span>

        // Write the complete archive to the filesystem
        <span class="cov2" title="3">return fsys.WriteFile(archiveItem.Path(), buf.Bytes(), 0644)</span>
}

// createZipArchive creates a zip archive
func (op *SimpleOperation) createZipArchive(archiveItem *ArchiveItem, fsys FileSystem) error <span class="cov1" title="1">{
        // Create a buffer to hold the archive data
        var buf bytes.Buffer

        zipWriter := zip.NewWriter(&amp;buf)
        defer func() </span><span class="cov1" title="1">{
                if closeErr := zipWriter.Close(); closeErr != nil </span><span class="cov1" title="1">{
                        fmt.Printf("Warning: failed to close zip writer: %v\n", closeErr)
                }</span>
        }()

        <span class="cov1" title="1">for _, source := range archiveItem.Sources() </span><span class="cov1" title="2">{
                if err := op.addToZipArchive(zipWriter, source, fsys); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add %s to archive: %w", source, err)
                }</span>
        }

        // Close writer to flush data
        <span class="cov1" title="1">if err := zipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close zip writer: %w", err)
        }</span>

        // Write the complete archive to the filesystem
        <span class="cov1" title="1">return fsys.WriteFile(archiveItem.Path(), buf.Bytes(), 0644)</span>
}

// addToTarArchive adds a file or directory to a tar archive
func (op *SimpleOperation) addToTarArchive(tarWriter *tar.Writer, sourcePath string, fsys FileSystem) error <span class="cov2" title="4">{
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support Stat operation needed for archiving")
        }</span>

        // Get file info
        <span class="cov2" title="4">info, err := fullFS.Stat(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat %s: %w", sourcePath, err)
        }</span>

        // Create tar header
        <span class="cov2" title="4">header, err := tar.FileInfoHeader(info, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tar header for %s: %w", sourcePath, err)
        }</span>

        // Use relative path in archive
        <span class="cov2" title="4">header.Name = strings.TrimPrefix(sourcePath, "./")

        // Write header
        if err := tarWriter.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write tar header for %s: %w", sourcePath, err)
        }</span>

        // If it's a file, write content
        <span class="cov2" title="4">if !info.IsDir() </span><span class="cov2" title="4">{
                file, err := fsys.Open(sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file %s: %w", sourcePath, err)
                }</span>
                <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to close file %s: %v\n", sourcePath, closeErr)
                        }</span>
                }()

                <span class="cov2" title="4">if _, err := io.Copy(tarWriter, file); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file content for %s: %w", sourcePath, err)
                }</span>
        }

        <span class="cov2" title="4">return nil</span>
}

// addToZipArchive adds a file or directory to a zip archive
func (op *SimpleOperation) addToZipArchive(zipWriter *zip.Writer, sourcePath string, fsys FileSystem) error <span class="cov3" title="7">{
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("filesystem does not support Stat operation needed for archiving")
        }</span>

        // Get file info
        <span class="cov3" title="6">info, err := fullFS.Stat(sourcePath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to stat %s: %w", sourcePath, err)
        }</span>

        // Use relative path in archive
        <span class="cov3" title="5">archivePath := strings.TrimPrefix(sourcePath, "./")

        // If it's a directory, create directory entry
        if info.IsDir() </span><span class="cov1" title="1">{
                if !strings.HasSuffix(archivePath, "/") </span><span class="cov1" title="1">{
                        archivePath += "/"
                }</span>
                <span class="cov1" title="1">_, err := zipWriter.Create(archivePath)
                return err</span>
        }

        // Create file entry
        <span class="cov2" title="4">writer, err := zipWriter.Create(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create zip entry for %s: %w", sourcePath, err)
        }</span>

        // Open and copy file content
        <span class="cov2" title="4">file, err := fsys.Open(sourcePath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to open file %s: %w", sourcePath, err)
        }</span>
        <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close file %s: %v\n", sourcePath, closeErr)
                }</span>
        }()

        <span class="cov2" title="3">if _, err := io.Copy(writer, file); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file content for %s: %w", sourcePath, err)
        }</span>

        <span class="cov2" title="3">return nil</span>
}

// executeUnarchive implements archive extraction
func (op *SimpleOperation) executeUnarchive(ctx context.Context, fsys FileSystem) error <span class="cov3" title="5">{
        if op.item == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no unarchive item provided for unarchive operation")
        }</span>

        <span class="cov3" title="5">unarchiveItem, ok := op.item.(*UnarchiveItem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("expected UnarchiveItem for unarchive operation, got %T", op.item)
        }</span>

        // Determine archive format from file extension
        <span class="cov3" title="5">archivePath := unarchiveItem.ArchivePath()
        var format ArchiveFormat
        if strings.HasSuffix(strings.ToLower(archivePath), ".tar.gz") || strings.HasSuffix(strings.ToLower(archivePath), ".tgz") </span><span class="cov2" title="4">{
                format = ArchiveFormatTarGz
        }</span> else<span class="cov1" title="1"> if strings.HasSuffix(strings.ToLower(archivePath), ".zip") </span><span class="cov1" title="1">{
                format = ArchiveFormatZip
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("unsupported archive format for file: %s", archivePath)
        }</span>

        <span class="cov3" title="5">switch format </span>{
        case ArchiveFormatTarGz:<span class="cov2" title="4">
                return op.extractTarGzArchive(unarchiveItem, fsys)</span>
        case ArchiveFormatZip:<span class="cov1" title="1">
                return op.extractZipArchive(unarchiveItem, fsys)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported archive format: %s", format.String())</span>
        }
}

// extractTarGzArchive extracts a tar.gz archive
func (op *SimpleOperation) extractTarGzArchive(unarchiveItem *UnarchiveItem, fsys FileSystem) error <span class="cov2" title="4">{
        // Open archive file
        file, err := fsys.Open(unarchiveItem.ArchivePath())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open archive %s: %w", unarchiveItem.ArchivePath(), err)
        }</span>
        <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close archive file: %v\n", closeErr)
                }</span>
        }()

        // Create gzip reader
        <span class="cov2" title="4">gzipReader, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create gzip reader: %w", err)
        }</span>
        <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{
                if closeErr := gzipReader.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close gzip reader: %v\n", closeErr)
                }</span>
        }()

        // Create tar reader
        <span class="cov2" title="4">tarReader := tar.NewReader(gzipReader)

        // Extract files
        for </span><span class="cov4" title="24">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov2" title="4">{
                        break</span>
                }
                <span class="cov4" title="20">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read tar header: %w", err)
                }</span>

                // Check if file matches patterns (if any)
                <span class="cov4" title="20">if !op.matchesPatterns(header.Name, unarchiveItem.Patterns()) </span><span class="cov3" title="6">{
                        continue</span>
                }

                // Determine extraction path
                <span class="cov4" title="14">extractPath := filepath.Join(unarchiveItem.ExtractPath(), header.Name)

                // Ensure extract path is safe (prevent directory traversal)
                if !strings.HasPrefix(filepath.Clean(extractPath), filepath.Clean(unarchiveItem.ExtractPath())) </span><span class="cov0" title="0">{
                        return fmt.Errorf("unsafe path in archive: %s", header.Name)
                }</span>

                <span class="cov4" title="14">switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov3" title="5">
                        // Create directory
                        if err := fsys.MkdirAll(extractPath, header.FileInfo().Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", extractPath, err)
                        }</span>

                case tar.TypeReg:<span class="cov3" title="9">
                        // Create file
                        if err := op.extractFileFromTar(tarReader, extractPath, header.FileInfo().Mode(), unarchiveItem.Overwrite(), fsys); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to extract file %s: %w", extractPath, err)
                        }</span>

                case tar.TypeLink, tar.TypeSymlink:<span class="cov0" title="0">
                        // Skip symlinks and hard links for now
                        fmt.Printf("Warning: skipping link %s\n", header.Name)
                        continue</span>

                default:<span class="cov0" title="0">
                        fmt.Printf("Warning: skipping unsupported file type %c for %s\n", header.Typeflag, header.Name)</span>
                }
        }

        <span class="cov2" title="4">return nil</span>
}

// extractZipArchive extracts a zip archive
func (op *SimpleOperation) extractZipArchive(unarchiveItem *UnarchiveItem, fsys FileSystem) error <span class="cov1" title="1">{
        // Read archive file content
        file, err := fsys.Open(unarchiveItem.ArchivePath())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open archive %s: %w", unarchiveItem.ArchivePath(), err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close archive file: %v\n", closeErr)
                }</span>
        }()

        // Get file info for size
        <span class="cov1" title="1">fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support Stat operation needed for zip extraction")
        }</span>

        <span class="cov1" title="1">info, err := fullFS.Stat(unarchiveItem.ArchivePath())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat archive file: %w", err)
        }</span>

        // Read all content into memory (required for zip.NewReader)
        <span class="cov1" title="1">content := make([]byte, info.Size())
        _, err = file.Read(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read archive content: %w", err)
        }</span>

        // Create zip reader
        <span class="cov1" title="1">zipReader, err := zip.NewReader(bytes.NewReader(content), info.Size())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create zip reader: %w", err)
        }</span>

        // Extract files
        <span class="cov1" title="1">for _, f := range zipReader.File </span><span class="cov2" title="3">{
                // Check if file matches patterns (if any)
                if !op.matchesPatterns(f.Name, unarchiveItem.Patterns()) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Determine extraction path
                <span class="cov2" title="3">extractPath := filepath.Join(unarchiveItem.ExtractPath(), f.Name)

                // Ensure extract path is safe (prevent directory traversal)
                if !strings.HasPrefix(filepath.Clean(extractPath), filepath.Clean(unarchiveItem.ExtractPath())) </span><span class="cov0" title="0">{
                        return fmt.Errorf("unsafe path in archive: %s", f.Name)
                }</span>

                <span class="cov2" title="3">if f.FileInfo().IsDir() </span><span class="cov1" title="1">{
                        // Create directory
                        if err := fsys.MkdirAll(extractPath, f.FileInfo().Mode()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", extractPath, err)
                        }</span>
                } else<span class="cov1" title="2"> {
                        // Extract file
                        if err := op.extractFileFromZip(f, extractPath, unarchiveItem.Overwrite(), fsys); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to extract file %s: %w", extractPath, err)
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// extractFileFromTar extracts a single file from a tar archive
func (op *SimpleOperation) extractFileFromTar(tarReader *tar.Reader, extractPath string, mode fs.FileMode, overwrite bool, fsys FileSystem) error <span class="cov3" title="9">{
        // Check if file already exists
        if !overwrite </span><span class="cov3" title="9">{
                if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov3" title="9">{
                        if _, err := fullFS.Stat(extractPath); err == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("file already exists: %s", extractPath)
                        }</span>
                }
        }

        // Ensure parent directory exists
        <span class="cov3" title="9">parentDir := filepath.Dir(extractPath)
        if err := fsys.MkdirAll(parentDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directory %s: %w", parentDir, err)
        }</span>

        // Read file content
        <span class="cov3" title="9">content, err := io.ReadAll(tarReader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file content: %w", err)
        }</span>

        // Write file
        <span class="cov3" title="9">return fsys.WriteFile(extractPath, content, mode)</span>
}

// extractFileFromZip extracts a single file from a zip archive
func (op *SimpleOperation) extractFileFromZip(f *zip.File, extractPath string, overwrite bool, fsys FileSystem) error <span class="cov1" title="2">{
        // Check if file already exists
        if !overwrite </span><span class="cov1" title="2">{
                if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov1" title="2">{
                        if _, err := fullFS.Stat(extractPath); err == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("file already exists: %s", extractPath)
                        }</span>
                }
        }

        // Ensure parent directory exists
        <span class="cov1" title="2">parentDir := filepath.Dir(extractPath)
        if err := fsys.MkdirAll(parentDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directory %s: %w", parentDir, err)
        }</span>

        // Open file in archive
        <span class="cov1" title="2">reader, err := f.Open()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file in archive: %w", err)
        }</span>
        <span class="cov1" title="2">defer func() </span><span class="cov1" title="2">{
                if closeErr := reader.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close zip file reader: %v\n", closeErr)
                }</span>
        }()

        // Read file content
        <span class="cov1" title="2">content, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file content: %w", err)
        }</span>

        // Write file
        <span class="cov1" title="2">return fsys.WriteFile(extractPath, content, f.FileInfo().Mode())</span>
}

// matchesPatterns checks if a file path matches any of the given patterns
func (op *SimpleOperation) matchesPatterns(filePath string, patterns []string) bool <span class="cov5" title="32">{
        // If no patterns specified, match all files
        if len(patterns) == 0 </span><span class="cov3" title="10">{
                return true
        }</span>

        <span class="cov4" title="22">for _, pattern := range patterns </span><span class="cov5" title="36">{
                // Use filepath.Match for simple patterns
                if matched, err := filepath.Match(pattern, filePath); err == nil &amp;&amp; matched </span><span class="cov4" title="13">{
                        return true
                }</span>

                // Also handle directory-based patterns like "docs/**"
                <span class="cov4" title="23">if strings.HasSuffix(pattern, "/**") </span><span class="cov3" title="7">{
                        dirPattern := strings.TrimSuffix(pattern, "/**")
                        if strings.HasPrefix(filePath, dirPattern+"/") || filePath == dirPattern </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // Handle patterns with directory separators
                <span class="cov4" title="23">if strings.Contains(pattern, "/") </span><span class="cov3" title="7">{
                        if matched, err := filepath.Match(pattern, filePath); err == nil &amp;&amp; matched </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov3" title="9">return false</span>
}

// executeCopy implements file/directory copying
func (op *SimpleOperation) executeCopy(ctx context.Context, fsys FileSystem) error <span class="cov3" title="10">{
        if op.srcPath == "" || op.dstPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("source or destination path not set for copy operation")
        }</span>

        // Phase I, Milestone 4: Verify checksums before execution
        <span class="cov3" title="10">if err := op.verifyChecksums(ctx, fsys); err != nil </span><span class="cov1" title="2">{
                return fmt.Errorf("copy operation failed checksum verification: %w", err)
        }</span>

        // For now, implement simple file copy - directory copy is more complex
        // First check if source is a file
        <span class="cov3" title="8">fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("filesystem does not support Stat operation needed for copy")
        }</span>

        <span class="cov3" title="8">srcInfo, err := fullFS.Stat(op.srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat source %s: %w", op.srcPath, err)
        }</span>

        <span class="cov3" title="8">if srcInfo.IsDir() </span><span class="cov1" title="1">{
                return fmt.Errorf("directory copying not yet implemented")
        }</span>

        // Read source file content
        <span class="cov3" title="7">file, err := fsys.Open(op.srcPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file %s: %w", op.srcPath, err)
        }</span>
        <span class="cov3" title="7">defer func() </span><span class="cov3" title="7">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close source file %s: %v\n", op.srcPath, closeErr)
                }</span>
        }()

        <span class="cov3" title="7">content := make([]byte, srcInfo.Size())
        _, err = file.Read(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source file %s: %w", op.srcPath, err)
        }</span>

        // Write to destination
        <span class="cov3" title="7">return fsys.WriteFile(op.dstPath, content, srcInfo.Mode())</span>
}

// executeMove implements file/directory moving
func (op *SimpleOperation) executeMove(ctx context.Context, fsys FileSystem) error <span class="cov3" title="6">{
        if op.srcPath == "" || op.dstPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("source or destination path not set for move operation")
        }</span>

        // Phase I, Milestone 4: Verify checksums before execution
        <span class="cov3" title="6">if err := op.verifyChecksums(ctx, fsys); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("move operation failed checksum verification: %w", err)
        }</span>

        <span class="cov3" title="5">return fsys.Rename(op.srcPath, op.dstPath)</span>
}

// executeDelete implements file/directory deletion
func (op *SimpleOperation) executeDelete(ctx context.Context, fsys FileSystem) error <span class="cov4" title="13">{
        path := op.description.Path

        // Check if it's a directory or file
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov1" title="1">{
                // Fallback: try Remove first, then RemoveAll
                err := fsys.Remove(path)
                if err != nil </span><span class="cov1" title="1">{
                        return fsys.RemoveAll(path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov4" title="12">info, err := fullFS.Stat(path)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to stat path for deletion %s: %w", path, err)
        }</span>

        <span class="cov3" title="11">if info.IsDir() </span><span class="cov2" title="3">{
                return fsys.RemoveAll(path)
        }</span>
        <span class="cov3" title="8">return fsys.Remove(path)</span>
}

// validateCreateFile validates file creation
func (op *SimpleOperation) validateCreateFile(ctx context.Context, fsys FileSystem) error <span class="cov5" title="54">{
        if op.item == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "no file item provided"}
        }</span>

        <span class="cov5" title="54">fileItem, ok := op.item.(*FileItem)
        if !ok </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: fmt.Sprintf("expected FileItem, got %T", op.item)}
        }</span>

        <span class="cov5" title="53">if fileItem.Path() == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "file path cannot be empty"}
        }</span>

        <span class="cov5" title="53">return nil</span>
}

// validateCreateDirectory validates directory creation
func (op *SimpleOperation) validateCreateDirectory(ctx context.Context, fsys FileSystem) error <span class="cov5" title="29">{
        if op.item == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "no directory item provided"}
        }</span>

        <span class="cov5" title="29">dirItem, ok := op.item.(*DirectoryItem)
        if !ok </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: fmt.Sprintf("expected DirectoryItem, got %T", op.item)}
        }</span>

        <span class="cov5" title="28">if dirItem.Path() == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "directory path cannot be empty"}
        }</span>

        <span class="cov5" title="28">return nil</span>
}

// validateCreateSymlink validates symlink creation
func (op *SimpleOperation) validateCreateSymlink(ctx context.Context, fsys FileSystem) error <span class="cov3" title="9">{
        if op.item == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "no symlink item provided"}
        }</span>

        <span class="cov3" title="9">symlinkItem, ok := op.item.(*SymlinkItem)
        if !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: fmt.Sprintf("expected SymlinkItem, got %T", op.item)}
        }</span>

        <span class="cov3" title="9">if symlinkItem.Path() == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "symlink path cannot be empty"}
        }</span>

        <span class="cov3" title="9">if symlinkItem.Target() == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "symlink target cannot be empty"}
        }</span>

        <span class="cov3" title="8">return nil</span>
}

// validateCreateArchive validates archive creation
func (op *SimpleOperation) validateCreateArchive(ctx context.Context, fsys FileSystem) error <span class="cov4" title="18">{
        if op.item == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "no archive item provided"}
        }</span>

        <span class="cov4" title="18">archiveItem, ok := op.item.(*ArchiveItem)
        if !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: fmt.Sprintf("expected ArchiveItem, got %T", op.item)}
        }</span>

        <span class="cov4" title="18">if archiveItem.Path() == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "archive path cannot be empty"}
        }</span>

        <span class="cov4" title="18">if len(archiveItem.Sources()) == 0 </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "archive must have at least one source"}
        }</span>

        // Phase I, Milestone 1: Source existence validation
        // Check if all source files/directories exist at validation time
        <span class="cov4" title="17">if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov4" title="17">{
                for _, source := range archiveItem.Sources() </span><span class="cov5" title="30">{
                        if _, err := fullFS.Stat(source); err != nil </span><span class="cov1" title="2">{
                                return &amp;ValidationError{
                                        Operation: op,
                                        Reason:    fmt.Sprintf("archive source does not exist: %s", source),
                                        Cause:     err,
                                }
                        }</span>
                }
        }

        <span class="cov4" title="15">return nil</span>
}

// validateUnarchive validates unarchive operation
func (op *SimpleOperation) validateUnarchive(ctx context.Context, fsys FileSystem) error <span class="cov4" title="13">{
        if op.item == nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "no unarchive item provided"}
        }</span>

        <span class="cov4" title="13">unarchiveItem, ok := op.item.(*UnarchiveItem)
        if !ok </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: fmt.Sprintf("expected UnarchiveItem, got %T", op.item)}
        }</span>

        <span class="cov4" title="12">if unarchiveItem.ArchivePath() == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "archive path cannot be empty"}
        }</span>

        <span class="cov4" title="12">if unarchiveItem.ExtractPath() == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "extract path cannot be empty"}
        }</span>

        // Validate archive format is supported
        <span class="cov3" title="11">archivePath := unarchiveItem.ArchivePath()
        if !strings.HasSuffix(strings.ToLower(archivePath), ".tar.gz") &amp;&amp;
                !strings.HasSuffix(strings.ToLower(archivePath), ".tgz") &amp;&amp;
                !strings.HasSuffix(strings.ToLower(archivePath), ".zip") </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "unsupported archive format (supported: .tar.gz, .tgz, .zip)"}
        }</span>

        // Phase I, Milestone 1: Source existence validation
        // Check if archive file exists at validation time
        <span class="cov3" title="10">if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov3" title="10">{
                if _, err := fullFS.Stat(archivePath); err != nil </span><span class="cov1" title="2">{
                        return &amp;ValidationError{
                                Operation: op,
                                Reason:    fmt.Sprintf("archive file does not exist: %s", archivePath),
                                Cause:     err,
                        }
                }</span>
        }

        <span class="cov3" title="8">return nil</span>
}

// validateCopy validates copy operation
func (op *SimpleOperation) validateCopy(ctx context.Context, fsys FileSystem) error <span class="cov5" title="38">{
        if op.srcPath == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "copy source path cannot be empty"}
        }</span>

        <span class="cov5" title="37">if op.dstPath == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "copy destination path cannot be empty"}
        }</span>

        // Phase I, Milestone 1: Source existence validation
        // Check if source file/directory exists at validation time
        <span class="cov5" title="36">if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov5" title="35">{
                if _, err := fullFS.Stat(op.srcPath); err != nil </span><span class="cov3" title="5">{
                        return &amp;ValidationError{
                                Operation: op,
                                Reason:    fmt.Sprintf("copy source does not exist: %s", op.srcPath),
                                Cause:     err,
                        }
                }</span>
        }

        <span class="cov5" title="31">return nil</span>
}

// validateMove validates move operation
func (op *SimpleOperation) validateMove(ctx context.Context, fsys FileSystem) error <span class="cov4" title="20">{
        if op.srcPath == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "move source path cannot be empty"}
        }</span>

        <span class="cov4" title="20">if op.dstPath == "" </span><span class="cov1" title="1">{
                return &amp;ValidationError{Operation: op, Reason: "move destination path cannot be empty"}
        }</span>

        // Phase I, Milestone 1: Source existence validation
        // Check if source file/directory exists at validation time
        <span class="cov4" title="19">if fullFS, ok := fsys.(FullFileSystem); ok </span><span class="cov4" title="19">{
                if _, err := fullFS.Stat(op.srcPath); err != nil </span><span class="cov2" title="3">{
                        return &amp;ValidationError{
                                Operation: op,
                                Reason:    fmt.Sprintf("move source does not exist: %s", op.srcPath),
                                Cause:     err,
                        }
                }</span>
        }

        <span class="cov4" title="16">return nil</span>
}

// validateDelete validates delete operation
func (op *SimpleOperation) validateDelete(ctx context.Context, fsys FileSystem) error <span class="cov5" title="29">{
        path := op.description.Path
        if path == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Operation: op, Reason: "delete path cannot be empty"}
        }</span>

        // For delete operations, we don't check if target exists at validation time
        // because it might be created by an earlier operation in the same batch.
        // We'll check existence at execution time instead.

        <span class="cov5" title="29">return nil</span>
}

// rollbackCreate removes what was created
func (op *SimpleOperation) rollbackCreate(ctx context.Context, fsys FileSystem) error <span class="cov2" title="3">{
        return fsys.Remove(op.description.Path)
}</span>

// rollbackCopy removes the destination of the copy
func (op *SimpleOperation) rollbackCopy(ctx context.Context, fsys FileSystem) error <span class="cov1" title="1">{
        return fsys.Remove(op.dstPath)
}</span>

// rollbackMove moves the file back to its original location
func (op *SimpleOperation) rollbackMove(ctx context.Context, fsys FileSystem) error <span class="cov1" title="1">{
        return fsys.Rename(op.dstPath, op.srcPath)
}</span>

// rollbackUnarchive removes extracted files (this is complex and potentially dangerous)
func (op *SimpleOperation) rollbackUnarchive(ctx context.Context, fsys FileSystem) error <span class="cov0" title="0">{
        // For safety, we don't automatically remove extracted files as it could be destructive
        // A proper implementation would need to track what was extracted during the operation
        return fmt.Errorf("rollback of unarchive operations is not automatically supported for safety reasons")
}</span>

// --- Phase III: Reverse Operation Implementations ---

// reverseCreateFile generates delete operation to undo file creation
func (op *SimpleOperation) reverseCreateFile(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov3" title="5">{
        // Simple case: just delete the file that was created
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "delete",
                op.description.Path,
        )

        // No backup needed for create operations - we just delete what was created
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.description.Path,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_created_file"},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseCreateDirectory generates delete operation to undo directory creation
func (op *SimpleOperation) reverseCreateDirectory(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov1" title="1">{
        // Simple case: just delete the directory that was created
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "delete",
                op.description.Path,
        )

        // No backup needed for create operations - we just delete what was created
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.description.Path,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_created_directory"},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseCreateSymlink generates delete operation to undo symlink creation
func (op *SimpleOperation) reverseCreateSymlink(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov0" title="0">{
        // Simple case: just delete the symlink that was created
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "delete",
                op.description.Path,
        )

        // No backup needed for create operations - we just delete what was created
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.description.Path,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_created_symlink"},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseCreateArchive generates delete operation to undo archive creation
func (op *SimpleOperation) reverseCreateArchive(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov0" title="0">{
        // Simple case: just delete the archive that was created
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "delete",
                op.description.Path,
        )

        // No backup needed for create operations - we just delete what was created
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.description.Path,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_created_archive"},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseUnarchive generates delete operations to undo file extraction
func (op *SimpleOperation) reverseUnarchive(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov0" title="0">{
        // For unarchive, we need to delete the extraction directory
        // This is simplified - a full implementation might track individual extracted files
        var reverseOps []Operation

        if item := op.GetItem(); item != nil </span><span class="cov0" title="0">{
                if unarchiveItem, ok := item.(*UnarchiveItem); ok </span><span class="cov0" title="0">{
                        // Delete the extraction directory
                        reverseOp := NewSimpleOperation(
                                OperationID("reverse_"+string(op.ID())),
                                "delete",
                                unarchiveItem.ExtractPath(),
                        )
                        reverseOps = append(reverseOps, reverseOp)
                }</span>
        }

        // No backup needed for unarchive operations - we just delete what was extracted
        <span class="cov0" title="0">backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.description.Path,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_extracted_files"},
        }

        return reverseOps, backupData, nil</span>
}

// reverseCopy generates delete operation to undo copy
func (op *SimpleOperation) reverseCopy(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov1" title="2">{
        // For copy, we just delete the destination file
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "delete",
                op.dstPath,
        )

        // No backup needed for copy operations - we just delete the copy
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.dstPath,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "delete_copied_file"},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseMove generates move operation to undo move
func (op *SimpleOperation) reverseMove(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov1" title="2">{
        // For move, we move the file back to its original location
        reverseOp := NewSimpleOperation(
                OperationID("reverse_"+string(op.ID())),
                "move",
                op.dstPath,
        )
        reverseOp.SetPaths(op.dstPath, op.srcPath)
        reverseOp.SetDescriptionDetail("destination", op.srcPath)

        // No backup needed for move operations - we just move it back
        backupData := &amp;BackupData{
                OperationID:   op.ID(),
                BackupType:    "none",
                OriginalPath:  op.srcPath,
                BackupContent: nil,
                BackupTime:    time.Now(),
                SizeMB:        0,
                Metadata:      map[string]interface{}{"reverse_type": "move_back", "original_src": op.srcPath, "original_dst": op.dstPath},
        }

        return []Operation{reverseOp}, backupData, nil
}</span>

// reverseDelete generates create operation to undo delete (with budget-aware backup)
func (op *SimpleOperation) reverseDelete(ctx context.Context, fsys FileSystem, budget *BackupBudget) ([]Operation, *BackupData, error) <span class="cov3" title="9">{
        path := op.description.Path

        // Check if the filesystem supports Stat to determine file type and size
        fullFS, ok := fsys.(FullFileSystem)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("reverse delete requires filesystem with Stat support")
        }</span>

        // Get file info to determine type and size
        <span class="cov3" title="9">info, err := fullFS.Stat(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("cannot backup file for delete operation: %w", err)
        }</span>

        <span class="cov3" title="8">var reverseOps []Operation
        var backupData *BackupData

        if info.IsDir() </span><span class="cov1" title="2">{
                // Directory - no content backup needed, but check if it fits in budget conceptually
                sizeMB := 0.01 // Small overhead for directory metadata

                if budget != nil </span><span class="cov1" title="2">{
                        if err := budget.ConsumeBackup(sizeMB); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("cannot backup directory '%s': %w", path, err)
                        }</span>
                }

                // Create reverse operation to recreate the directory
                <span class="cov1" title="2">reverseOp := NewSimpleOperation(
                        OperationID("reverse_"+string(op.ID())),
                        "create_directory",
                        path,
                )
                dirItem := NewDirectory(path).WithMode(info.Mode())
                reverseOp.SetItem(dirItem)
                reverseOps = append(reverseOps, reverseOp)

                backupData = &amp;BackupData{
                        OperationID:   op.ID(),
                        BackupType:    "directory",
                        OriginalPath:  path,
                        BackupContent: nil,
                        BackupMode:    info.Mode(),
                        BackupTime:    time.Now(),
                        SizeMB:        sizeMB,
                        Metadata: map[string]interface{}{
                                "reverse_type":      "recreate_directory",
                                "contents_restored": false,
                                "note":              "Directory structure restored empty; contents are not backed up.",
                        },
                }</span>

        } else<span class="cov3" title="6"> {
                // Regular file - backup content
                sizeMB := float64(info.Size()) / (1024 * 1024)

                if budget != nil </span><span class="cov3" title="6">{
                        if err := budget.ConsumeBackup(sizeMB); err != nil </span><span class="cov2" title="3">{
                                return nil, nil, fmt.Errorf("cannot backup file '%s' (%.2fMB): %w", path, sizeMB, err)
                        }</span>
                }

                // Read file content for backup
                <span class="cov2" title="3">file, err := fullFS.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        if budget != nil </span><span class="cov0" title="0">{
                                budget.RestoreBackup(sizeMB) // Restore budget on error
                        }</span>
                        <span class="cov0" title="0">return nil, nil, fmt.Errorf("cannot open file for backup: %w", err)</span>
                }
                <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                Logger().Warn().Err(closeErr).Str("path", path).Msg("failed to close file during backup")
                        }</span>
                }()

                <span class="cov2" title="3">content, err := io.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        if budget != nil </span><span class="cov0" title="0">{
                                budget.RestoreBackup(sizeMB) // Restore budget on error
                        }</span>
                        <span class="cov0" title="0">return nil, nil, fmt.Errorf("cannot read file content for backup: %w", err)</span>
                }

                // Create reverse operation to recreate the file
                <span class="cov2" title="3">reverseOp := NewSimpleOperation(
                        OperationID("reverse_"+string(op.ID())),
                        "create_file",
                        path,
                )
                fileItem := NewFile(path).WithContent(content).WithMode(info.Mode())
                reverseOp.SetItem(fileItem)
                reverseOps = append(reverseOps, reverseOp)

                backupData = &amp;BackupData{
                        OperationID:   op.ID(),
                        BackupType:    "file",
                        OriginalPath:  path,
                        BackupContent: content,
                        BackupMode:    info.Mode(),
                        BackupTime:    time.Now(),
                        SizeMB:        sizeMB,
                        Metadata:      map[string]interface{}{"reverse_type": "recreate_file"},
                }</span>
        }

        <span class="cov3" title="5">return reverseOps, backupData, nil</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package synthfs

import (
        "context"
        "fmt"

        "github.com/gammazero/toposort"
)

// Pipeline defines an interface for managing a sequence of operations.
type Pipeline interface {
        // Add appends one or more operations to the pipeline.
        // It may return an error, for example, if an operation with a duplicate ID
        // is added.
        Add(ops ...Operation) error

        // Operations returns all operations currently in the pipeline.
        // After Resolve() is called, this returns operations in dependency-resolved order.
        Operations() []Operation

        // Resolve performs dependency resolution using topological sorting.
        // This must be called before execution to ensure operations are in correct order.
        // Returns error if circular dependencies are detected.
        Resolve() error

        // Validate checks if all operations in the pipeline are valid.
        // This includes validating individual operations and checking for dependency conflicts.
        Validate(ctx context.Context, fs FileSystem) error
}

// memPipeline is an in-memory implementation of the Pipeline interface.
type memPipeline struct {
        ops      []Operation
        idIndex  map[OperationID]int // Maps operation ID to index in ops slice
        resolved bool                // Whether dependency resolution has been performed
}

// NewMemPipeline creates a new in-memory operation pipeline.
func NewMemPipeline() Pipeline <span class="cov7" title="40">{
        return &amp;memPipeline{
                ops:      make([]Operation, 0),
                idIndex:  make(map[OperationID]int),
                resolved: false,
        }
}</span>

// Add appends operations to the pipeline.
func (mp *memPipeline) Add(ops ...Operation) error <span class="cov7" title="40">{
        Logger().Trace().
                Interface("pipeline_add_full_context", map[string]interface{}{
                        "existing_pipeline_state": func() []map[string]interface{} </span><span class="cov7" title="40">{
                                var existing []map[string]interface{}
                                for i, op := range mp.ops </span><span class="cov0" title="0">{
                                        existing = append(existing, map[string]interface{}{
                                                "index":        i,
                                                "id":           string(op.ID()),
                                                "type":         op.Describe().Type,
                                                "path":         op.Describe().Path,
                                                "details":      op.Describe().Details,
                                                "dependencies": op.Dependencies(),
                                                "conflicts":    op.Conflicts(),
                                        })
                                }</span>
                                <span class="cov7" title="40">return existing</span>
                        }(),
                        "new_operations": func() []map[string]interface{} <span class="cov7" title="40">{
                                var newOps []map[string]interface{}
                                for _, op := range ops </span><span class="cov8" title="69">{
                                        if op == nil </span><span class="cov0" title="0">{
                                                newOps = append(newOps, map[string]interface{}{
                                                        "id":           "&lt;nil&gt;",
                                                        "type":         "&lt;nil&gt;",
                                                        "path":         "&lt;nil&gt;",
                                                        "details":      nil,
                                                        "dependencies": nil,
                                                        "conflicts":    nil,
                                                })
                                        }</span> else<span class="cov8" title="69"> {
                                                newOps = append(newOps, map[string]interface{}{
                                                        "id":           string(op.ID()),
                                                        "type":         op.Describe().Type,
                                                        "path":         op.Describe().Path,
                                                        "details":      op.Describe().Details,
                                                        "dependencies": op.Dependencies(),
                                                        "conflicts":    op.Conflicts(),
                                                })
                                        }</span>
                                }
                                <span class="cov7" title="40">return newOps</span>
                        }(),
                        "pipeline_resolved": mp.resolved,
                        "pipeline_size":     len(mp.ops),
                }).
                Msg("pipeline add operation - complete state dump")

        <span class="cov7" title="40">Logger().Info().
                Int("existing_operations", len(mp.ops)).
                Int("new_operations", len(ops)).
                Msg("adding operations to queue")

        for _, op := range ops </span><span class="cov8" title="69">{
                if op == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot add a nil operation to the pipeline")
                }</span>

                // Check for duplicate IDs
                <span class="cov8" title="69">if _, exists := mp.idIndex[op.ID()]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation with ID '%s' already exists in the pipeline", op.ID())
                }</span>

                <span class="cov8" title="69">Logger().Info().
                        Str("op_id", string(op.ID())).
                        Str("op_type", op.Describe().Type).
                        Str("path", op.Describe().Path).
                        Int("dependencies", len(op.Dependencies())).
                        Msg("operation added to queue")

                // Add operation to queue
                index := len(mp.ops)
                mp.ops = append(mp.ops, op)
                mp.idIndex[op.ID()] = index

                // Mark as unresolved since we added new operations
                mp.resolved = false</span>
        }

        <span class="cov7" title="40">Logger().Info().
                Int("total_operations", len(mp.ops)).
                Msg("operations added to queue successfully")

        return nil</span>
}

// Operations returns all operations currently in the pipeline.
func (mp *memPipeline) Operations() []Operation <span class="cov9" title="80">{
        // Return a copy to prevent external modification
        opsCopy := make([]Operation, len(mp.ops))
        copy(opsCopy, mp.ops)
        return opsCopy
}</span>

// Resolve performs dependency resolution using topological sorting.
func (mp *memPipeline) Resolve() error <span class="cov7" title="40">{
        Logger().Info().
                Int("operations", len(mp.ops)).
                Bool("already_resolved", mp.resolved).
                Msg("starting dependency resolution")

        if len(mp.ops) == 0 </span><span class="cov1" title="1">{
                mp.resolved = true
                Logger().Info().Msg("no operations to resolve")
                return nil
        }</span>

        <span class="cov7" title="39">if mp.resolved </span><span class="cov0" title="0">{
                Logger().Info().Msg("dependencies already resolved")
                return nil
        }</span>

        // Validate that all dependencies exist
        <span class="cov7" title="39">Logger().Info().Msg("validating dependency references")
        if err := mp.validateDependencies(); err != nil </span><span class="cov0" title="0">{
                Logger().Info().
                        Err(err).
                        Msg("dependency validation failed")
                return fmt.Errorf("dependency validation failed: %w", err)
        }</span>
        <span class="cov7" title="39">Logger().Info().Msg("dependency references validated successfully")

        // Build dependency graph using topological sort library
        edges := make([]toposort.Edge, 0)

        for _, op := range mp.ops </span><span class="cov8" title="69">{
                for _, depID := range op.Dependencies() </span><span class="cov6" title="18">{
                        // Edge is [2]interface{} where element 0 comes before element 1
                        // So dependency -&gt; operation (dependency must come first)
                        edges = append(edges, toposort.Edge{string(depID), string(op.ID())})
                }</span>
        }

        <span class="cov7" title="39">Logger().Info().
                Int("dependency_edges", len(edges)).
                Msg("performing topological sort")

        // Perform topological sort
        sortedIDs, err := toposort.Toposort(edges)
        if err != nil </span><span class="cov0" title="0">{
                Logger().Trace().
                        Interface("topological_sort_failure", map[string]interface{}{
                                "edges": func() []map[string]interface{} </span><span class="cov0" title="0">{
                                        var edgeList []map[string]interface{}
                                        for _, edge := range edges </span><span class="cov0" title="0">{
                                                edgeList = append(edgeList, map[string]interface{}{
                                                        "from": edge[0],
                                                        "to":   edge[1],
                                                })
                                        }</span>
                                        <span class="cov0" title="0">return edgeList</span>
                                }(),
                                "operation_dependencies": func() []map[string]interface{} <span class="cov0" title="0">{
                                        var opDeps []map[string]interface{}
                                        for _, op := range mp.ops </span><span class="cov0" title="0">{
                                                opDeps = append(opDeps, map[string]interface{}{
                                                        "id":           string(op.ID()),
                                                        "dependencies": op.Dependencies(),
                                                })
                                        }</span>
                                        <span class="cov0" title="0">return opDeps</span>
                                }(),
                                "error":      err.Error(),
                                "error_type": fmt.Sprintf("%T", err),
                        }).
                        Msg("topological sort failed - complete dependency graph dump")

                <span class="cov0" title="0">Logger().Info().
                        Err(err).
                        Msg("topological sort failed - circular dependency detected")
                return fmt.Errorf("circular dependency detected: %w", err)</span>
        }

        <span class="cov7" title="39">Logger().Trace().
                Interface("topological_sort_success", map[string]interface{}{
                        "sorted_ids": sortedIDs,
                        "edges": func() []map[string]interface{} </span><span class="cov7" title="39">{
                                var edgeList []map[string]interface{}
                                for _, edge := range edges </span><span class="cov6" title="18">{
                                        edgeList = append(edgeList, map[string]interface{}{
                                                "from": edge[0],
                                                "to":   edge[1],
                                        })
                                }</span>
                                <span class="cov7" title="39">return edgeList</span>
                        }(),
                        "original_order": func() []string <span class="cov7" title="39">{
                                var ids []string
                                for _, op := range mp.ops </span><span class="cov8" title="69">{
                                        ids = append(ids, string(op.ID()))
                                }</span>
                                <span class="cov7" title="39">return ids</span>
                        }(),
                }).
                Msg("topological sort succeeded - complete sorting details")

        // Rebuild operations slice in topologically sorted order
        <span class="cov7" title="39">resolvedOps := make([]Operation, 0, len(mp.ops))
        newIdIndex := make(map[OperationID]int)

        // Add operations in dependency order
        for _, idInterface := range sortedIDs </span><span class="cov6" title="21">{
                idStr, ok := idInterface.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type in topological sort result: %T", idInterface)
                }</span>
                <span class="cov6" title="21">opID := OperationID(idStr)
                if oldIndex, exists := mp.idIndex[opID]; exists </span><span class="cov6" title="21">{
                        newIndex := len(resolvedOps)
                        resolvedOps = append(resolvedOps, mp.ops[oldIndex])
                        newIdIndex[opID] = newIndex
                }</span>
        }

        // Add any operations that weren't in the dependency graph (no dependencies or dependents)
        <span class="cov7" title="39">for _, op := range mp.ops </span><span class="cov8" title="69">{
                if _, alreadyAdded := newIdIndex[op.ID()]; !alreadyAdded </span><span class="cov8" title="48">{
                        newIndex := len(resolvedOps)
                        resolvedOps = append(resolvedOps, op)
                        newIdIndex[op.ID()] = newIndex
                }</span>
        }

        <span class="cov7" title="39">mp.ops = resolvedOps
        mp.idIndex = newIdIndex
        mp.resolved = true

        Logger().Info().
                Int("resolved_operations", len(resolvedOps)).
                Msg("dependency resolution completed successfully")

        return nil</span>
}

// Validate checks if all operations in the pipeline are valid.
func (mp *memPipeline) Validate(ctx context.Context, fs FileSystem) error <span class="cov7" title="40">{
        Logger().Debug().
                Int("total_operations", len(mp.ops)).
                Bool("resolved", mp.resolved).
                Msg("starting comprehensive pipeline validation")

        // First validate dependencies exist
        Logger().Debug().Msg("validating operation dependencies")
        if err := mp.validateDependencies(); err != nil </span><span class="cov0" title="0">{
                Logger().Debug().
                        Err(err).
                        Msg("dependency validation failed")
                return err
        }</span>
        <span class="cov7" title="40">Logger().Debug().Msg("dependency validation completed successfully")

        // Validate each operation individually
        Logger().Debug().Msg("validating individual operations")
        for i, op := range mp.ops </span><span class="cov8" title="69">{
                Logger().Debug().
                        Int("operation_index", i+1).
                        Int("total_operations", len(mp.ops)).
                        Str("op_id", string(op.ID())).
                        Str("op_type", op.Describe().Type).
                        Str("path", op.Describe().Path).
                        Msg("validating individual operation")

                if err := op.Validate(ctx, fs); err != nil </span><span class="cov0" title="0">{
                        Logger().Debug().
                                Str("op_id", string(op.ID())).
                                Str("op_type", op.Describe().Type).
                                Str("path", op.Describe().Path).
                                Err(err).
                                Msg("individual operation validation failed")
                        return &amp;ValidationError{
                                Operation: op,
                                Reason:    "operation validation failed",
                                Cause:     err,
                        }
                }</span>

                <span class="cov8" title="69">Logger().Debug().
                        Str("op_id", string(op.ID())).
                        Str("op_type", op.Describe().Type).
                        Str("path", op.Describe().Path).
                        Msg("individual operation validation passed")</span>
        }
        <span class="cov7" title="40">Logger().Debug().
                Int("validated_operations", len(mp.ops)).
                Msg("individual operation validation completed successfully")

        // Check for conflicts
        Logger().Debug().Msg("validating operation conflicts")
        if err := mp.validateConflicts(); err != nil </span><span class="cov0" title="0">{
                Logger().Debug().
                        Err(err).
                        Msg("conflict validation failed")
                return err
        }</span>
        <span class="cov7" title="40">Logger().Debug().Msg("conflict validation completed successfully")

        Logger().Debug().
                Int("total_operations", len(mp.ops)).
                Msg("comprehensive pipeline validation completed successfully")

        return nil</span>
}

// validateDependencies ensures all referenced dependencies exist in the pipeline.
func (mp *memPipeline) validateDependencies() error <span class="cov8" title="79">{
        Logger().Debug().
                Int("operations_to_check", len(mp.ops)).
                Msg("checking dependency references")

        dependencyCount := 0
        for _, op := range mp.ops </span><span class="cov10" title="138">{
                deps := op.Dependencies()
                dependencyCount += len(deps)

                Logger().Debug().
                        Str("op_id", string(op.ID())).
                        Str("op_type", op.Describe().Type).
                        Interface("dependencies", deps).
                        Int("dependency_count", len(deps)).
                        Msg("checking operation dependencies")

                for _, depID := range deps </span><span class="cov7" title="36">{
                        if _, exists := mp.idIndex[depID]; !exists </span><span class="cov0" title="0">{
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Str("missing_dependency", string(depID)).
                                        Interface("all_dependencies", deps).
                                        Msg("dependency reference validation failed - missing dependency")
                                return &amp;DependencyError{
                                        Operation:    op,
                                        Dependencies: op.Dependencies(),
                                        Missing:      []OperationID{depID},
                                }
                        }</span> else<span class="cov7" title="36"> {
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Str("dependency", string(depID)).
                                        Msg("dependency reference found")
                        }</span>
                }
        }

        <span class="cov8" title="79">Logger().Debug().
                Int("total_dependencies", dependencyCount).
                Int("operations_checked", len(mp.ops)).
                Msg("dependency reference validation completed")

        return nil</span>
}

// validateConflicts checks for operations that conflict with each other.
func (mp *memPipeline) validateConflicts() error <span class="cov7" title="40">{
        Logger().Debug().
                Int("operations_to_check", len(mp.ops)).
                Msg("checking operation conflicts")

        conflictCount := 0
        for _, op := range mp.ops </span><span class="cov8" title="69">{
                conflicts := op.Conflicts()
                conflictCount += len(conflicts)

                if len(conflicts) &gt; 0 </span><span class="cov0" title="0">{
                        Logger().Debug().
                                Str("op_id", string(op.ID())).
                                Str("op_type", op.Describe().Type).
                                Interface("conflicts", conflicts).
                                Int("conflict_count", len(conflicts)).
                                Msg("checking operation conflicts")
                }</span>

                <span class="cov8" title="69">for _, conflictID := range conflicts </span><span class="cov0" title="0">{
                        if _, exists := mp.idIndex[conflictID]; exists </span><span class="cov0" title="0">{
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Str("conflicting_operation", string(conflictID)).
                                        Interface("all_conflicts", conflicts).
                                        Msg("conflict validation failed - conflicting operation found in queue")
                                return &amp;ConflictError{
                                        Operation: op,
                                        Conflicts: []OperationID{conflictID},
                                }
                        }</span> else<span class="cov0" title="0"> {
                                Logger().Debug().
                                        Str("op_id", string(op.ID())).
                                        Str("potential_conflict", string(conflictID)).
                                        Msg("potential conflict not in queue - no actual conflict")
                        }</span>
                }
        }

        <span class="cov7" title="40">Logger().Debug().
                Int("total_potential_conflicts", conflictCount).
                Int("operations_checked", len(mp.ops)).
                Msg("conflict validation completed - no conflicts found")

        return nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package synthfs

import (
        "fmt"
        "io/fs"
)

// PathStateType represents the type of a filesystem object in the projected state.
type PathStateType int

const (
        // PathStateUnknown represents an unknown or non-existent path.
        PathStateUnknown PathStateType = iota
        // PathStateFile represents a file.
        PathStateFile
        // PathStateDir represents a directory.
        PathStateDir
        // PathStateSymlink represents a symbolic link.
        PathStateSymlink
)

// String returns the string representation of the PathStateType.
func (t PathStateType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case PathStateFile:<span class="cov0" title="0">
                return "file"</span>
        case PathStateDir:<span class="cov0" title="0">
                return "directory"</span>
        case PathStateSymlink:<span class="cov0" title="0">
                return "symlink"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// PathState holds the projected state of a single path after all operations in a batch are applied.
// This is central to the Smart Dependencies feature (Phase II).
type PathState struct {
        // Path is the full path being tracked.
        Path string
        // WillExist is true if the path is expected to exist after the batch runs.
        WillExist bool
        // WillBeType is the projected type of the path (file, directory, etc.).
        WillBeType PathStateType
        // CreatedBy is the ID of the operation that creates this path.
        CreatedBy OperationID
        // DeletedBy is the ID of the operation that deletes this path.
        DeletedBy OperationID
        // ModifiedBy is a list of operation IDs that modify this path (e.g., copy to, unarchive to).
        ModifiedBy []OperationID
        // InitialState stores the fs.FileInfo of the path from the real filesystem at validation time.
        // It is nil if the path does not exist initially.
        InitialState fs.FileInfo
}

// PathStateTracker manages the projected state of all paths affected by a batch of operations.
type PathStateTracker struct {
        states map[string]*PathState
        fs     FullFileSystem
}

// NewPathStateTracker creates a new tracker.
func NewPathStateTracker(fs FullFileSystem) *PathStateTracker <span class="cov8" title="70">{
        return &amp;PathStateTracker{
                states: make(map[string]*PathState),
                fs:     fs,
        }
}</span>

// GetState returns the projected state of a path. If the path is not yet in the tracker,
// it queries the real filesystem and creates an initial state.
func (pst *PathStateTracker) GetState(path string) (*PathState, error) <span class="cov10" title="160">{
        if state, exists := pst.states[path]; exists </span><span class="cov6" title="25">{
                return state, nil
        }</span>

        // If not tracked, check the real filesystem to create an initial state.
        <span class="cov9" title="135">info, err := pst.fs.Stat(path)
        if err != nil </span><span class="cov8" title="88">{
                // An error here means it doesn't exist. This is a valid state.
                initialState := &amp;PathState{
                        Path:      path,
                        WillExist: false,
                }
                pst.states[path] = initialState
                return initialState, nil
        }</span>

        // The path exists on the filesystem.
        <span class="cov7" title="47">var initialType PathStateType
        if info.IsDir() </span><span class="cov3" title="5">{
                initialType = PathStateDir
        }</span> else<span class="cov7" title="42"> if info.Mode()&amp;fs.ModeSymlink != 0 </span><span class="cov0" title="0">{
                initialType = PathStateSymlink
        }</span> else<span class="cov7" title="42"> {
                initialType = PathStateFile
        }</span>

        <span class="cov7" title="47">initialState := &amp;PathState{
                Path:         path,
                WillExist:    true,
                WillBeType:   initialType,
                InitialState: info,
        }
        pst.states[path] = initialState
        return initialState, nil</span>
}

// UpdateState applies the effect of an operation to the projected state of a path.
// This is where conflict detection will happen.
func (pst *PathStateTracker) UpdateState(op Operation) error <span class="cov9" title="114">{
        desc := op.Describe()
        opID := op.ID()

        switch desc.Type </span>{
        case "create_file":<span class="cov7" title="31">
                return pst.updateStateForCreate(opID, desc.Path, PathStateFile)</span>
        case "create_directory":<span class="cov6" title="20">
                return pst.updateStateForCreate(opID, desc.Path, PathStateDir)</span>
        case "create_symlink":<span class="cov3" title="5">
                return pst.updateStateForCreate(opID, desc.Path, PathStateSymlink)</span>
        case "create_archive":<span class="cov4" title="8">
                return pst.updateStateForCreate(opID, desc.Path, PathStateFile)</span> // Archives are files

        case "delete":<span class="cov6" title="19">
                state, err := pst.GetState(desc.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // In Phase II, it's a conflict to delete something that isn't projected to exist.
                <span class="cov6" title="19">if !state.WillExist </span><span class="cov2" title="2">{
                        return fmt.Errorf("validation conflict for %s: path %s to be deleted is not projected to exist", opID, desc.Path)
                }</span>
                // It's also a conflict to delete something that's already been deleted.
                <span class="cov6" title="17">if state.DeletedBy != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation %s conflicts with %s: cannot delete %s, already scheduled for deletion", opID, state.DeletedBy, desc.Path)
                }</span>
                // It is also a conflict to delete a path that was just created in this batch.
                <span class="cov6" title="17">if state.CreatedBy != "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("operation %s conflicts with %s: cannot delete %s, it was created in the same batch", opID, state.CreatedBy, desc.Path)
                }</span>
                <span class="cov5" title="16">state.WillExist = false
                state.DeletedBy = opID</span>

        case "copy":<span class="cov6" title="19">
                simpleOp, ok := op.(*SimpleOperation)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid operation type for copy: expected SimpleOperation")
                }</span>
                <span class="cov6" title="19">srcPath := simpleOp.GetSrcPath()
                dstPath := simpleOp.GetDstPath()

                // Validate source
                srcState, err := pst.GetState(srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="19">if !srcState.WillExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation conflict for %s: copy source %s does not exist", opID, srcPath)
                }</span>

                // Update destination
                <span class="cov6" title="19">return pst.updateStateForCreate(opID, dstPath, srcState.WillBeType)</span>

        case "move":<span class="cov5" title="10">
                simpleOp, ok := op.(*SimpleOperation)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid operation type for move: expected SimpleOperation")
                }</span>
                <span class="cov5" title="10">srcPath := simpleOp.GetSrcPath()
                dstPath := simpleOp.GetDstPath()

                // Validate source
                srcState, err := pst.GetState(srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="10">if !srcState.WillExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation conflict for %s: move source %s does not exist", opID, srcPath)
                }</span>
                <span class="cov5" title="10">if srcState.DeletedBy != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation %s conflicts with %s: cannot move %s, already scheduled for deletion", opID, srcState.DeletedBy, srcPath)
                }</span>

                // Update source to be deleted
                <span class="cov5" title="10">srcState.WillExist = false
                srcState.DeletedBy = opID

                // Update destination to be created
                return pst.updateStateForCreate(opID, dstPath, srcState.WillBeType)</span>

        case "unarchive":<span class="cov2" title="2">
                // This is more complex as it affects an unknown number of paths.
                // For now, we'll just check the source archive exists and treat the destination as modified.
                state, err := pst.GetState(desc.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">if !state.WillExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation conflict for %s: source archive %s does not exist", opID, desc.Path)
                }</span>

                // Mark destination directory as modified. A more advanced implementation could
                // inspect the archive or handle conflicts at execution time.
                <span class="cov2" title="2">if unarchiveItem, ok := op.GetItem().(*UnarchiveItem); ok </span><span class="cov2" title="2">{
                        destPath := unarchiveItem.ExtractPath()
                        destState, err := pst.GetState(destPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="2">destState.ModifiedBy = append(destState.ModifiedBy, opID)</span>
                }
        }

        <span class="cov6" title="18">return nil</span>
}

func (pst *PathStateTracker) updateStateForCreate(opID OperationID, path string, createType PathStateType) error <span class="cov9" title="93">{
        state, err := pst.GetState(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov9" title="93">if state.WillExist </span><span class="cov4" title="6">{
                return fmt.Errorf("operation %s conflicts with existing state: cannot create %s because it is projected to already exist", opID, path)
        }</span>
        <span class="cov8" title="87">if state.DeletedBy != "" </span><span class="cov2" title="2">{
                // A file was deleted, now we are creating it again. This should probably be a "modify" operation.
                // For now, let's treat it as a conflict to keep it simple.
                return fmt.Errorf("operation %s conflicts with %s: cannot create %s, path was scheduled for deletion", opID, state.DeletedBy, path)
        }</span>

        <span class="cov8" title="85">state.WillExist = true
        state.WillBeType = createType
        state.CreatedBy = opID
        state.DeletedBy = "" // Reset deleted status
        return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package synthfs

import (
        "context"
        "io/fs"
        "testing"
        "testing/fstest"
)

// TestFileSystem extends fstest.MapFS to implement our WriteFS interface
// This allows using testing/fstest with synthfs operations
type TestFileSystem struct {
        fstest.MapFS
}

// NewTestFileSystem creates a new test filesystem based on fstest.MapFS
func NewTestFileSystem() *TestFileSystem <span class="cov7" title="85">{
        return &amp;TestFileSystem{
                MapFS: make(fstest.MapFS),
        }
}</span>

// NewTestFileSystemFromMap creates a test filesystem from an existing map
func NewTestFileSystemFromMap(files map[string]*fstest.MapFile) *TestFileSystem <span class="cov2" title="2">{
        return &amp;TestFileSystem{
                MapFS: files,
        }
}</span>

// WriteFile implements WriteFS for testing
func (tfs *TestFileSystem) WriteFile(name string, data []byte, perm fs.FileMode) error <span class="cov8" title="114">{
        if !fs.ValidPath(name) </span><span class="cov1" title="1">{
                return &amp;fs.PathError{Op: "writefile", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov8" title="113">tfs.MapFS[name] = &amp;fstest.MapFile{
                Data: data,
                Mode: perm,
        }
        return nil</span>
}

// MkdirAll implements WriteFS for testing
func (tfs *TestFileSystem) MkdirAll(path string, perm fs.FileMode) error <span class="cov6" title="27">{
        if !fs.ValidPath(path) </span><span class="cov1" title="1">{
                return &amp;fs.PathError{Op: "mkdirall", Path: path, Err: fs.ErrInvalid}
        }</span>

        // Check if a file (not directory) already exists at this path
        <span class="cov5" title="26">if existing, exists := tfs.MapFS[path]; exists </span><span class="cov0" title="0">{
                if !existing.Mode.IsDir() </span><span class="cov0" title="0">{
                        // Can't create directory where file exists
                        return &amp;fs.PathError{Op: "mkdirall", Path: path, Err: fs.ErrExist}
                }</span>
                // Directory already exists, that's fine for MkdirAll
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov5" title="26">tfs.MapFS[path] = &amp;fstest.MapFile{
                Mode: perm | fs.ModeDir,
        }
        return nil</span>
}

// Remove implements WriteFS for testing
func (tfs *TestFileSystem) Remove(name string) error <span class="cov4" title="13">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "remove", Path: name, Err: fs.ErrInvalid}
        }</span>
        <span class="cov4" title="13">if _, exists := tfs.MapFS[name]; !exists </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "remove", Path: name, Err: fs.ErrNotExist}
        }</span>
        <span class="cov4" title="13">delete(tfs.MapFS, name)
        return nil</span>
}

// RemoveAll implements WriteFS for testing
func (tfs *TestFileSystem) RemoveAll(name string) error <span class="cov3" title="5">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "removeall", Path: name, Err: fs.ErrInvalid}
        }</span>
        // Remove the path and all its children
        <span class="cov3" title="5">for path := range tfs.MapFS </span><span class="cov4" title="12">{
                if path == name || isSubPath(name, path) </span><span class="cov4" title="9">{
                        delete(tfs.MapFS, path)
                }</span>
        }
        <span class="cov3" title="5">return nil</span>
}

// Symlink implements WriteFS for testing
func (tfs *TestFileSystem) Symlink(oldname, newname string) error <span class="cov3" title="5">{
        if !fs.ValidPath(oldname) || !fs.ValidPath(newname) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "symlink", Path: newname, Err: fs.ErrInvalid}
        }</span>

        // Check if target exists
        <span class="cov3" title="5">if _, exists := tfs.MapFS[oldname]; !exists </span><span class="cov1" title="1">{
                // Unlike real symlinks, for testing we'll require the target to exist
                return &amp;fs.PathError{Op: "symlink", Path: oldname, Err: fs.ErrNotExist}
        }</span>

        // Check if newname already exists
        <span class="cov3" title="4">if _, exists := tfs.MapFS[newname]; exists </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "symlink", Path: newname, Err: fs.ErrExist}
        }</span>

        // Create symlink as a special file with ModeSymlink
        <span class="cov3" title="4">tfs.MapFS[newname] = &amp;fstest.MapFile{
                Data: []byte(oldname), // Store target path as data
                Mode: fs.ModeSymlink | 0777,
        }
        return nil</span>
}

// Readlink implements WriteFS for testing
func (tfs *TestFileSystem) Readlink(name string) (string, error) <span class="cov2" title="3">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: fs.ErrInvalid}
        }</span>

        <span class="cov2" title="3">file, exists := tfs.MapFS[name]
        if !exists </span><span class="cov0" title="0">{
                return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: fs.ErrNotExist}
        }</span>

        <span class="cov2" title="3">if file.Mode&amp;fs.ModeSymlink == 0 </span><span class="cov1" title="1">{
                return "", &amp;fs.PathError{Op: "readlink", Path: name, Err: fs.ErrInvalid}
        }</span>

        <span class="cov2" title="2">return string(file.Data), nil</span>
}

// Rename implements WriteFS for testing
func (tfs *TestFileSystem) Rename(oldpath, newpath string) error <span class="cov4" title="8">{
        if !fs.ValidPath(oldpath) || !fs.ValidPath(newpath) </span><span class="cov0" title="0">{
                return &amp;fs.PathError{Op: "rename", Path: newpath, Err: fs.ErrInvalid}
        }</span>

        // Check if source exists
        <span class="cov4" title="8">file, exists := tfs.MapFS[oldpath]
        if !exists </span><span class="cov1" title="1">{
                return &amp;fs.PathError{Op: "rename", Path: oldpath, Err: fs.ErrNotExist}
        }</span>

        // Check if destination already exists and is not a directory
        <span class="cov3" title="7">if destFile, destExists := tfs.MapFS[newpath]; destExists </span><span class="cov0" title="0">{
                if destFile.Mode.IsDir() </span><span class="cov0" title="0">{
                        return &amp;fs.PathError{Op: "rename", Path: newpath, Err: fs.ErrExist}
                }</span>
                // File exists, will be overwritten (matches os.Rename behavior)
        }

        // Move the file
        <span class="cov3" title="7">tfs.MapFS[newpath] = file
        delete(tfs.MapFS, oldpath)

        return nil</span>
}

// Stat implements StatFS for testing
func (tfs *TestFileSystem) Stat(name string) (fs.FileInfo, error) <span class="cov10" title="356">{
        if !fs.ValidPath(name) </span><span class="cov0" title="0">{
                return nil, &amp;fs.PathError{Op: "stat", Path: name, Err: fs.ErrInvalid}
        }</span>

        // Use Open to get the file and then get its info
        <span class="cov10" title="356">file, err := tfs.Open(name)
        if err != nil </span><span class="cov8" title="116">{
                return nil, err
        }</span>
        <span class="cov9" title="240">defer func() </span><span class="cov9" title="240">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        Logger().Warn().Err(closeErr).Msg("failed to close file in Stat")
                }</span>
        }()

        <span class="cov9" title="240">return file.Stat()</span>
}

// isSubPath returns true if child is a subpath of parent
func isSubPath(parent, child string) bool <span class="cov4" title="9">{
        if parent == "" || parent == "." </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov4" title="9">if len(child) &lt;= len(parent) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="9">return child[:len(parent)+1] == parent+"/"</span>
}

// TestHelper provides utilities for testing synthfs operations
type TestHelper struct {
        t   *testing.T
        fs  *TestFileSystem
        ctx context.Context
}

// NewTestHelper creates a new test helper with a fresh filesystem
func NewTestHelper(t *testing.T) *TestHelper <span class="cov3" title="6">{
        return &amp;TestHelper{
                t:   t,
                fs:  NewTestFileSystem(),
                ctx: context.Background(),
        }
}</span>

// NewTestHelperWithFiles creates a test helper with predefined files
func NewTestHelperWithFiles(t *testing.T, files map[string]*fstest.MapFile) *TestHelper <span class="cov1" title="1">{
        return &amp;TestHelper{
                t:   t,
                fs:  NewTestFileSystemFromMap(files),
                ctx: context.Background(),
        }
}</span>

// FS returns the test filesystem
func (th *TestHelper) FS() *TestFileSystem <span class="cov3" title="5">{
        return th.fs
}</span>

// Context returns the test context
func (th *TestHelper) Context() context.Context <span class="cov1" title="1">{
        return th.ctx
}</span>

// AssertFileExists verifies that a file exists with optional content check
func (th *TestHelper) AssertFileExists(path string, expectedContent ...[]byte) <span class="cov2" title="2">{
        th.t.Helper()

        file, err := th.fs.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected file %s to exist, but got error: %v", path, err)
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        th.t.Logf("Warning: failed to close file %s: %v", path, closeErr)
                }</span>
        }()

        <span class="cov2" title="2">info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                th.t.Fatalf("Failed to stat file %s: %v", path, err)
        }</span>

        <span class="cov2" title="2">if info.IsDir() </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected %s to be a file, but it's a directory", path)
        }</span>

        // Check content if provided
        <span class="cov2" title="2">if len(expectedContent) &gt; 0 </span><span class="cov2" title="2">{
                mapFile := th.fs.MapFS[path]
                if mapFile == nil </span><span class="cov0" title="0">{
                        th.t.Fatalf("File %s exists but has no content data", path)
                }</span>

                <span class="cov2" title="2">expected := expectedContent[0]
                if string(mapFile.Data) != string(expected) </span><span class="cov0" title="0">{
                        th.t.Errorf("File %s content mismatch.\nExpected: %q\nGot: %q",
                                path, string(expected), string(mapFile.Data))
                }</span>
        }
}

// AssertDirExists verifies that a directory exists
func (th *TestHelper) AssertDirExists(path string) <span class="cov1" title="1">{
        th.t.Helper()

        info, err := th.fs.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected directory %s to exist, but got error: %v", path, err)
        }</span>

        <span class="cov1" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected %s to be a directory, but it's a file", path)
        }</span>
}

// AssertNotExists verifies that a path does not exist
func (th *TestHelper) AssertNotExists(path string) <span class="cov1" title="1">{
        th.t.Helper()

        _, err := th.fs.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected %s to not exist, but it does", path)
        }</span>

        <span class="cov1" title="1">if !isNotExistError(err) </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected %s to not exist, but got unexpected error: %v", path, err)
        }</span>
}

// RunAndAssert runs a pipeline and asserts it succeeds
func (th *TestHelper) RunAndAssert(pipeline Pipeline) *Result <span class="cov0" title="0">{
        th.t.Helper()

        executor := NewExecutor()
        result := executor.Run(th.ctx, pipeline, th.fs)

        if !result.Success </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected run to succeed, but it failed with errors: %v", result.Errors)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// RunAndExpectError runs a pipeline and expects it to fail
func (th *TestHelper) RunAndExpectError(pipeline Pipeline) *Result <span class="cov0" title="0">{
        th.t.Helper()

        executor := NewExecutor()
        result := executor.Run(th.ctx, pipeline, th.fs)

        if result.Success </span><span class="cov0" title="0">{
                th.t.Fatalf("Expected run to fail, but it succeeded")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateTestFS validates a TestFileSystem using testing/fstest
func ValidateTestFS(t *testing.T, testFS *TestFileSystem) <span class="cov1" title="1">{
        t.Helper()

        // Collect expected files from the filesystem
        expectedFiles := make([]string, 0, len(testFS.MapFS))
        for path := range testFS.MapFS </span><span class="cov2" title="2">{
                expectedFiles = append(expectedFiles, path)
        }</span>

        // Use testing/fstest to validate the filesystem
        <span class="cov1" title="1">if err := fstest.TestFS(testFS.MapFS, expectedFiles...); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("TestFileSystem validation failed: %v", err)
        }</span>
}

// isNotExistError checks if an error indicates that a file/directory doesn't exist
func isNotExistError(err error) bool <span class="cov1" title="1">{
        if pathErr, ok := err.(*fs.PathError); ok </span><span class="cov1" title="1">{
                return pathErr.Err == fs.ErrNotExist
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
